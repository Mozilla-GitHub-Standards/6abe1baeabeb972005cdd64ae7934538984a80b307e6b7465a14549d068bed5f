// This Source Code Form is subject to the terms of the Mozilla Public License,
// v. 2.0. If a copy of the MPL was not distributed with this file, You can
// obtain one at http://mozilla.org/MPL/2.0/.

#![cfg(feature = "proto")]
#![allow(deprecated)]
// Otherwise rustc warns that we're using our own deprecated types...


// The following code is automatically generated using a JSON specification of
// the Chrome DevTools Protocol published by the Chromium project. The JSON
// files themselves are covered by their own BSD 3-Clause license. Please see
// the LICENSE-CHROMIUM file for more information.

#[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Inspector\n\n## Commands\n\n- [`Inspector.enable`](struct.EnableCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Enables inspector domain notifications.\n- [`Inspector.disable`](struct.DisableCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Disables inspector domain notifications.\n\n## Events\n\n- [`Inspector.detached`](struct.DetachedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Fired when remote debugging connection is about to be terminated. Contains detach reason.\n- [`Inspector.targetCrashed`](struct.TargetCrashedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Fired when debugging target has crashed\n"]
pub mod inspector {
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables inspector domain notifications.\n\n# Command `Inspector.enable`\n\n*Domain Module:* [`cdp::proto::inspector`](index.html)  \n*Command Struct:* [`cdp::proto::inspector::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::proto::inspector::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableCommand;
    impl ::serde::Serialize for EnableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for EnableCommand {
        fn command_name(&self) -> &str {
            "Inspector.enable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for EnableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Inspector.enable" {
                Ok(
                    <EnableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables inspector domain notifications.\n\n# Command `Inspector.enable`\n\n*Domain Module:* [`cdp::proto::inspector`](index.html)  \n*Command Struct:* [`cdp::proto::inspector::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::proto::inspector::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableResponse;
    impl ::serde::Serialize for EnableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for EnableCommand {
        type Response = EnableResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for EnableResponse {
        type Command = EnableCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Disables inspector domain notifications.\n\n# Command `Inspector.disable`\n\n*Domain Module:* [`cdp::proto::inspector`](index.html)  \n*Command Struct:* [`cdp::proto::inspector::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::proto::inspector::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableCommand;
    impl ::serde::Serialize for DisableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for DisableCommand {
        fn command_name(&self) -> &str {
            "Inspector.disable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for DisableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Inspector.disable" {
                Ok(
                    <DisableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Disables inspector domain notifications.\n\n# Command `Inspector.disable`\n\n*Domain Module:* [`cdp::proto::inspector`](index.html)  \n*Command Struct:* [`cdp::proto::inspector::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::proto::inspector::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableResponse;
    impl ::serde::Serialize for DisableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for DisableCommand {
        type Response = DisableResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for DisableResponse {
        type Command = DisableCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Fired when remote debugging connection is about to be terminated. Contains detach reason.\n\n# Event `Inspector.detached`\n\n*Domain Module:* [`cdp::proto::inspector`](index.html)  \n*Event Struct:* [`cdp::proto::inspector::DetachedEvent`](struct.DetachedEvent.html)"]
    pub struct DetachedEvent<'a> {
        #[serde(rename = "reason")]
        #[doc = "The reason why connection has been terminated."]
        pub reason: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpEvent for DetachedEvent<'a> {
        fn event_name(&self) -> &str {
            "Inspector.detached"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for DetachedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Inspector.detached" {
                Ok(
                    <DetachedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Fired when debugging target has crashed\n\n# Event `Inspector.targetCrashed`\n\n*Domain Module:* [`cdp::proto::inspector`](index.html)  \n*Event Struct:* [`cdp::proto::inspector::TargetCrashedEvent`](struct.TargetCrashedEvent.html)"]
    pub struct TargetCrashedEvent;
    impl ::serde::Serialize for TargetCrashedEvent {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for TargetCrashedEvent {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| TargetCrashedEvent)
        }
    }
    impl ::traits::SerializeCdpEvent for TargetCrashedEvent {
        fn event_name(&self) -> &str {
            "Inspector.targetCrashed"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpEvent<'de> for TargetCrashedEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Inspector.targetCrashed" {
                Ok(
                    <TargetCrashedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
}
#[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Memory\n\n## Commands\n\n- [`Memory.getDOMCounters`](struct.GetDomCountersCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`Memory.setPressureNotificationsSuppressed`](struct.SetPressureNotificationsSuppressedCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Enable/disable suppressing memory pressure notifications in all processes.\n- [`Memory.simulatePressureNotification`](struct.SimulatePressureNotificationCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Simulate a memory pressure notification in all processes.\n\n##Types\n\n- [`PressureLevel`](enum.PressureLevel.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Memory pressure level.\n"]
pub mod memory {
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `Memory.getDOMCounters`\n\n*Domain Module:* [`cdp::proto::memory`](index.html)  \n*Command Struct:* [`cdp::proto::memory::GetDomCountersCommand`](struct.GetDomCountersCommand.html)  \n*Response Struct:* [`cdp::proto::memory::GetDomCountersResponse`](struct.GetDomCountersResponse.html)"]
    pub struct GetDomCountersCommand;
    impl ::serde::Serialize for GetDomCountersCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetDomCountersCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| GetDomCountersCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for GetDomCountersCommand {
        fn command_name(&self) -> &str {
            "Memory.getDOMCounters"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for GetDomCountersCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Memory.getDOMCounters" {
                Ok(
                    <GetDomCountersCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `Memory.getDOMCounters`\n\n*Domain Module:* [`cdp::proto::memory`](index.html)  \n*Command Struct:* [`cdp::proto::memory::GetDomCountersCommand`](struct.GetDomCountersCommand.html)  \n*Response Struct:* [`cdp::proto::memory::GetDomCountersResponse`](struct.GetDomCountersResponse.html)"]
    pub struct GetDomCountersResponse {
        #[serde(rename = "documents")]
        pub documents: i32,
        #[serde(rename = "nodes")]
        pub nodes: i32,
        #[serde(rename = "jsEventListeners")]
        pub js_event_listeners: i32,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for GetDomCountersCommand {
        type Response = GetDomCountersResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for GetDomCountersResponse {
        type Command = GetDomCountersCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enable/disable suppressing memory pressure notifications in all processes.\n\n# Command `Memory.setPressureNotificationsSuppressed`\n\n*Domain Module:* [`cdp::proto::memory`](index.html)  \n*Command Struct:* [`cdp::proto::memory::SetPressureNotificationsSuppressedCommand`](struct.SetPressureNotificationsSuppressedCommand.html)  \n*Response Struct:* [`cdp::proto::memory::SetPressureNotificationsSuppressedResponse`](struct.SetPressureNotificationsSuppressedResponse.html)"]
    pub struct SetPressureNotificationsSuppressedCommand {
        #[serde(rename = "suppressed")]
        #[doc = "If true, memory pressure notifications will be suppressed."]
        pub suppressed: bool,
    }
    impl ::traits::SerializeCdpCommand for SetPressureNotificationsSuppressedCommand {
        fn command_name(&self) -> &str {
            "Memory.setPressureNotificationsSuppressed"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for SetPressureNotificationsSuppressedCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Memory.setPressureNotificationsSuppressed" {
                Ok ( < SetPressureNotificationsSuppressedCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enable/disable suppressing memory pressure notifications in all processes.\n\n# Command `Memory.setPressureNotificationsSuppressed`\n\n*Domain Module:* [`cdp::proto::memory`](index.html)  \n*Command Struct:* [`cdp::proto::memory::SetPressureNotificationsSuppressedCommand`](struct.SetPressureNotificationsSuppressedCommand.html)  \n*Response Struct:* [`cdp::proto::memory::SetPressureNotificationsSuppressedResponse`](struct.SetPressureNotificationsSuppressedResponse.html)"]
    pub struct SetPressureNotificationsSuppressedResponse;
    impl ::serde::Serialize for SetPressureNotificationsSuppressedResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetPressureNotificationsSuppressedResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetPressureNotificationsSuppressedResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetPressureNotificationsSuppressedCommand {
        type Response = SetPressureNotificationsSuppressedResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetPressureNotificationsSuppressedResponse {
        type Command = SetPressureNotificationsSuppressedCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Simulate a memory pressure notification in all processes.\n\n# Command `Memory.simulatePressureNotification`\n\n*Domain Module:* [`cdp::proto::memory`](index.html)  \n*Command Struct:* [`cdp::proto::memory::SimulatePressureNotificationCommand`](struct.SimulatePressureNotificationCommand.html)  \n*Response Struct:* [`cdp::proto::memory::SimulatePressureNotificationResponse`](struct.SimulatePressureNotificationResponse.html)"]
    pub struct SimulatePressureNotificationCommand {
        #[serde(rename = "level")]
        #[doc = "Memory pressure level of the notification."]
        pub level: ::proto::memory::PressureLevel,
    }
    impl ::traits::SerializeCdpCommand for SimulatePressureNotificationCommand {
        fn command_name(&self) -> &str {
            "Memory.simulatePressureNotification"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for SimulatePressureNotificationCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Memory.simulatePressureNotification" {
                Ok ( < SimulatePressureNotificationCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Simulate a memory pressure notification in all processes.\n\n# Command `Memory.simulatePressureNotification`\n\n*Domain Module:* [`cdp::proto::memory`](index.html)  \n*Command Struct:* [`cdp::proto::memory::SimulatePressureNotificationCommand`](struct.SimulatePressureNotificationCommand.html)  \n*Response Struct:* [`cdp::proto::memory::SimulatePressureNotificationResponse`](struct.SimulatePressureNotificationResponse.html)"]
    pub struct SimulatePressureNotificationResponse;
    impl ::serde::Serialize for SimulatePressureNotificationResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SimulatePressureNotificationResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SimulatePressureNotificationResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SimulatePressureNotificationCommand {
        type Response = SimulatePressureNotificationResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SimulatePressureNotificationResponse {
        type Command = SimulatePressureNotificationCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Memory pressure level."]
    pub enum PressureLevel {
        #[serde(rename = "moderate")]
        #[doc = "Represented as `\"moderate\"`."]
        Moderate,
        #[serde(rename = "critical")]
        #[doc = "Represented as `\"critical\"`."]
        Critical,
    }
    impl PressureLevel {
        pub const ENUM_VALUES: &'static [PressureLevel] =
            &[PressureLevel::Moderate, PressureLevel::Critical];
        pub const STR_VALUES: &'static [&'static str] = &["moderate", "critical"];
    }
    impl ::std::str::FromStr for PressureLevel {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "moderate" => Ok(PressureLevel::Moderate),
                "critical" => Ok(PressureLevel::Critical),
                _ => Err(::proto::ParseEnumError {
                    expected: PressureLevel::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for PressureLevel {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    PressureLevel::Moderate => "moderate",
                    PressureLevel::Critical => "critical",
                }
            )
        }
    }
}
#[doc = "Actions and events related to the inspected page belong to the page domain.\n\n# Page\n\n## Commands\n\n- [`Page.enable`](struct.EnableCommand.html)\n\n  Enables page domain notifications.\n- [`Page.disable`](struct.DisableCommand.html)\n\n  Disables page domain notifications.\n- [`Page.addScriptToEvaluateOnLoad`](struct.AddScriptToEvaluateOnLoadCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n  \n  <span class=\"stab deprecated\">please use addScriptToEvaluateOnNewDocument instead.</span>\n- [`Page.removeScriptToEvaluateOnLoad`](struct.RemoveScriptToEvaluateOnLoadCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n  \n  <span class=\"stab deprecated\">please use removeScriptToEvaluateOnNewDocument instead.</span>\n- [`Page.addScriptToEvaluateOnNewDocument`](struct.AddScriptToEvaluateOnNewDocumentCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Evaluates given script in every frame upon creation \\(before loading frame's scripts\\).\n- [`Page.removeScriptToEvaluateOnNewDocument`](struct.RemoveScriptToEvaluateOnNewDocumentCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Removes given script from the list.\n- [`Page.setAutoAttachToCreatedPages`](struct.SetAutoAttachToCreatedPagesCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Controls whether browser will open a new inspector window for connected pages.\n- [`Page.reload`](struct.ReloadCommand.html)\n\n  Reloads given page optionally ignoring the cache.\n- [`Page.navigate`](struct.NavigateCommand.html)\n\n  Navigates current page to the given URL.\n- [`Page.stopLoading`](struct.StopLoadingCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Force the page stop all navigations and pending resource fetches.\n- [`Page.getNavigationHistory`](struct.GetNavigationHistoryCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns navigation history for the current page.\n- [`Page.navigateToHistoryEntry`](struct.NavigateToHistoryEntryCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Navigates current page to the given history entry.\n- [`Page.getCookies`](struct.GetCookiesCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns all browser cookies. Depending on the backend support, will return detailed cookie information in the <code>cookies</code> field.\n- [`Page.deleteCookie`](struct.DeleteCookieCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Deletes browser cookie with given name, domain and path.\n- [`Page.getResourceTree`](struct.GetResourceTreeCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns present frame / resource tree structure.\n- [`Page.getResourceContent`](struct.GetResourceContentCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns content of the given resource.\n- [`Page.searchInResource`](struct.SearchInResourceCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Searches for given string in resource content.\n- [`Page.setDocumentContent`](struct.SetDocumentContentCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Sets given markup as the document's HTML.\n- [`Page.setDeviceMetricsOverride`](struct.SetDeviceMetricsOverrideCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Overrides the values of device screen dimensions \\(window.screen.width, window.screen.height, window.innerWidth, window.innerHeight, and \"device-width\"/\"device-height\"-related CSS media query results\\).\n- [`Page.clearDeviceMetricsOverride`](struct.ClearDeviceMetricsOverrideCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Clears the overriden device metrics.\n- [`Page.setGeolocationOverride`](struct.SetGeolocationOverrideCommand.html)\n\n  Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position unavailable.\n- [`Page.clearGeolocationOverride`](struct.ClearGeolocationOverrideCommand.html)\n\n  Clears the overriden Geolocation Position and Error.\n- [`Page.setDeviceOrientationOverride`](struct.SetDeviceOrientationOverrideCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Overrides the Device Orientation.\n- [`Page.clearDeviceOrientationOverride`](struct.ClearDeviceOrientationOverrideCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Clears the overridden Device Orientation.\n- [`Page.setTouchEmulationEnabled`](struct.SetTouchEmulationEnabledCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Toggles mouse event-based touch event emulation.\n- [`Page.captureScreenshot`](struct.CaptureScreenshotCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Capture page screenshot.\n- [`Page.printToPDF`](struct.PrintToPdfCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Print page as PDF.\n- [`Page.startScreencast`](struct.StartScreencastCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Starts sending each frame using the <code>screencastFrame</code> event.\n- [`Page.stopScreencast`](struct.StopScreencastCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Stops sending each frame in the <code>screencastFrame</code>.\n- [`Page.screencastFrameAck`](struct.ScreencastFrameAckCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Acknowledges that a screencast frame has been received by the frontend.\n- [`Page.handleJavaScriptDialog`](struct.HandleJavaScriptDialogCommand.html)\n\n  Accepts or dismisses a JavaScript initiated dialog \\(alert, confirm, prompt, or onbeforeunload\\).\n- [`Page.getAppManifest`](struct.GetAppManifestCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`Page.requestAppBanner`](struct.RequestAppBannerCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`Page.setControlNavigations`](struct.SetControlNavigationsCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Toggles navigation throttling which allows programatic control over navigation and redirect response.\n- [`Page.processNavigation`](struct.ProcessNavigationCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Should be sent in response to a navigationRequested or a redirectRequested event, telling the browser how to handle the navigation.\n- [`Page.getLayoutMetrics`](struct.GetLayoutMetricsCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns metrics relating to the layouting of the page, such as viewport bounds/scale.\n- [`Page.createIsolatedWorld`](struct.CreateIsolatedWorldCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Creates an isolated world for the given frame.\n\n## Events\n\n- [`Page.domContentEventFired`](struct.DomContentEventFiredEvent.html)\n- [`Page.loadEventFired`](struct.LoadEventFiredEvent.html)\n- [`Page.frameAttached`](struct.FrameAttachedEvent.html)\n\n  Fired when frame has been attached to its parent.\n- [`Page.frameNavigated`](struct.FrameNavigatedEvent.html)\n\n  Fired once navigation of the frame has completed. Frame is now associated with the new loader.\n- [`Page.frameDetached`](struct.FrameDetachedEvent.html)\n\n  Fired when frame has been detached from its parent.\n- [`Page.frameStartedLoading`](struct.FrameStartedLoadingEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Fired when frame has started loading.\n- [`Page.frameStoppedLoading`](struct.FrameStoppedLoadingEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Fired when frame has stopped loading.\n- [`Page.frameScheduledNavigation`](struct.FrameScheduledNavigationEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Fired when frame schedules a potential navigation.\n- [`Page.frameClearedScheduledNavigation`](struct.FrameClearedScheduledNavigationEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Fired when frame no longer has a scheduled navigation.\n- [`Page.frameResized`](struct.FrameResizedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`Page.javascriptDialogOpening`](struct.JavascriptDialogOpeningEvent.html)\n\n  Fired when a JavaScript initiated dialog \\(alert, confirm, prompt, or onbeforeunload\\) is about to open.\n- [`Page.javascriptDialogClosed`](struct.JavascriptDialogClosedEvent.html)\n\n  Fired when a JavaScript initiated dialog \\(alert, confirm, prompt, or onbeforeunload\\) has been closed.\n- [`Page.screencastFrame`](struct.ScreencastFrameEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Compressed image data requested by the <code>startScreencast</code>.\n- [`Page.screencastVisibilityChanged`](struct.ScreencastVisibilityChangedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Fired when the page with currently enabled screencast was shown or hidden </code>.\n- [`Page.interstitialShown`](struct.InterstitialShownEvent.html)\n\n  Fired when interstitial page was shown\n- [`Page.interstitialHidden`](struct.InterstitialHiddenEvent.html)\n\n  Fired when interstitial page was hidden\n- [`Page.navigationRequested`](struct.NavigationRequestedEvent.html)\n\n  Fired when a navigation is started if navigation throttles are enabled.  The navigation will be deferred until processNavigation is called.\n\n##Types\n\n- [`ResourceType`](enum.ResourceType.html)\n\n  Resource type as it was perceived by the rendering engine.\n- [`FrameId`](type.FrameId.html)\n\n  Unique frame identifier.\n- [`Frame`](struct.Frame.html)\n\n  Information about the Frame on the page.\n- [`FrameResource`](struct.FrameResource.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Information about the Resource on the page.\n- [`FrameResourceTree`](struct.FrameResourceTree.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Information about the Frame hierarchy along with their cached resources.\n- [`ScriptIdentifier`](type.ScriptIdentifier.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Unique script identifier.\n- [`TransitionType`](enum.TransitionType.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Transition type.\n- [`NavigationEntry`](struct.NavigationEntry.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Navigation history entry.\n- [`ScreencastFrameMetadata`](struct.ScreencastFrameMetadata.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Screencast frame metadata.\n- [`DialogType`](enum.DialogType.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Javascript dialog type.\n- [`AppManifestError`](struct.AppManifestError.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Error while paring app manifest.\n- [`NavigationResponse`](enum.NavigationResponse.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Proceed: allow the navigation; Cancel: cancel the navigation; CancelAndIgnore: cancels the navigation and makes the requester of the navigation acts like the request was never made.\n- [`LayoutViewport`](struct.LayoutViewport.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Layout viewport position and dimensions.\n- [`VisualViewport`](struct.VisualViewport.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Visual viewport position, dimensions, and scale.\n- [`Viewport`](struct.Viewport.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Viewport for capturing screenshot.\n"]
pub mod page {
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Enables page domain notifications.\n\n# Command `Page.enable`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::proto::page::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableCommand;
    impl ::serde::Serialize for EnableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for EnableCommand {
        fn command_name(&self) -> &str {
            "Page.enable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for EnableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.enable" {
                Ok(
                    <EnableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Enables page domain notifications.\n\n# Command `Page.enable`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::proto::page::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableResponse;
    impl ::serde::Serialize for EnableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for EnableCommand {
        type Response = EnableResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for EnableResponse {
        type Command = EnableCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Disables page domain notifications.\n\n# Command `Page.disable`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::proto::page::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableCommand;
    impl ::serde::Serialize for DisableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for DisableCommand {
        fn command_name(&self) -> &str {
            "Page.disable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for DisableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.disable" {
                Ok(
                    <DisableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Disables page domain notifications.\n\n# Command `Page.disable`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::proto::page::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableResponse;
    impl ::serde::Serialize for DisableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for DisableCommand {
        type Response = DisableResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for DisableResponse {
        type Command = DisableCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `Page.addScriptToEvaluateOnLoad`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::AddScriptToEvaluateOnLoadCommand`](struct.AddScriptToEvaluateOnLoadCommand.html)  \n*Response Struct:* [`cdp::proto::page::AddScriptToEvaluateOnLoadResponse`](struct.AddScriptToEvaluateOnLoadResponse.html)"]
    #[deprecated(note = "please use addScriptToEvaluateOnNewDocument instead.")]
    pub struct AddScriptToEvaluateOnLoadCommand<'a> {
        #[serde(rename = "scriptSource")]
        pub script_source: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpCommand for AddScriptToEvaluateOnLoadCommand<'a> {
        fn command_name(&self) -> &str {
            "Page.addScriptToEvaluateOnLoad"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for AddScriptToEvaluateOnLoadCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.addScriptToEvaluateOnLoad" {
                Ok ( < AddScriptToEvaluateOnLoadCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `Page.addScriptToEvaluateOnLoad`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::AddScriptToEvaluateOnLoadCommand`](struct.AddScriptToEvaluateOnLoadCommand.html)  \n*Response Struct:* [`cdp::proto::page::AddScriptToEvaluateOnLoadResponse`](struct.AddScriptToEvaluateOnLoadResponse.html)"]
    #[deprecated(note = "please use addScriptToEvaluateOnNewDocument instead.")]
    pub struct AddScriptToEvaluateOnLoadResponse<'a> {
        #[serde(rename = "identifier")]
        #[doc = "Identifier of the added script."]
        pub identifier: ::proto::page::ScriptIdentifier<'a>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for AddScriptToEvaluateOnLoadCommand<'a> {
        type Response = AddScriptToEvaluateOnLoadResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for AddScriptToEvaluateOnLoadResponse<'a> {
        type Command = AddScriptToEvaluateOnLoadCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `Page.removeScriptToEvaluateOnLoad`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::RemoveScriptToEvaluateOnLoadCommand`](struct.RemoveScriptToEvaluateOnLoadCommand.html)  \n*Response Struct:* [`cdp::proto::page::RemoveScriptToEvaluateOnLoadResponse`](struct.RemoveScriptToEvaluateOnLoadResponse.html)"]
    #[deprecated(note = "please use removeScriptToEvaluateOnNewDocument instead.")]
    pub struct RemoveScriptToEvaluateOnLoadCommand<'a> {
        #[serde(rename = "identifier")]
        pub identifier: ::proto::page::ScriptIdentifier<'a>,
    }
    impl<'a> ::traits::SerializeCdpCommand for RemoveScriptToEvaluateOnLoadCommand<'a> {
        fn command_name(&self) -> &str {
            "Page.removeScriptToEvaluateOnLoad"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for RemoveScriptToEvaluateOnLoadCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.removeScriptToEvaluateOnLoad" {
                Ok ( < RemoveScriptToEvaluateOnLoadCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `Page.removeScriptToEvaluateOnLoad`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::RemoveScriptToEvaluateOnLoadCommand`](struct.RemoveScriptToEvaluateOnLoadCommand.html)  \n*Response Struct:* [`cdp::proto::page::RemoveScriptToEvaluateOnLoadResponse`](struct.RemoveScriptToEvaluateOnLoadResponse.html)"]
    #[deprecated(note = "please use removeScriptToEvaluateOnNewDocument instead.")]
    pub struct RemoveScriptToEvaluateOnLoadResponse;
    impl ::serde::Serialize for RemoveScriptToEvaluateOnLoadResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for RemoveScriptToEvaluateOnLoadResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| RemoveScriptToEvaluateOnLoadResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for RemoveScriptToEvaluateOnLoadCommand<'a> {
        type Response = RemoveScriptToEvaluateOnLoadResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for RemoveScriptToEvaluateOnLoadResponse {
        type Command = RemoveScriptToEvaluateOnLoadCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Evaluates given script in every frame upon creation \\(before loading frame's scripts\\).\n\n# Command `Page.addScriptToEvaluateOnNewDocument`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::AddScriptToEvaluateOnNewDocumentCommand`](struct.AddScriptToEvaluateOnNewDocumentCommand.html)  \n*Response Struct:* [`cdp::proto::page::AddScriptToEvaluateOnNewDocumentResponse`](struct.AddScriptToEvaluateOnNewDocumentResponse.html)"]
    pub struct AddScriptToEvaluateOnNewDocumentCommand<'a> {
        #[serde(rename = "source")]
        pub source: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpCommand for AddScriptToEvaluateOnNewDocumentCommand<'a> {
        fn command_name(&self) -> &str {
            "Page.addScriptToEvaluateOnNewDocument"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for AddScriptToEvaluateOnNewDocumentCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.addScriptToEvaluateOnNewDocument" {
                Ok ( < AddScriptToEvaluateOnNewDocumentCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Evaluates given script in every frame upon creation \\(before loading frame's scripts\\).\n\n# Command `Page.addScriptToEvaluateOnNewDocument`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::AddScriptToEvaluateOnNewDocumentCommand`](struct.AddScriptToEvaluateOnNewDocumentCommand.html)  \n*Response Struct:* [`cdp::proto::page::AddScriptToEvaluateOnNewDocumentResponse`](struct.AddScriptToEvaluateOnNewDocumentResponse.html)"]
    pub struct AddScriptToEvaluateOnNewDocumentResponse<'a> {
        #[serde(rename = "identifier")]
        #[doc = "Identifier of the added script."]
        pub identifier: ::proto::page::ScriptIdentifier<'a>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for AddScriptToEvaluateOnNewDocumentCommand<'a> {
        type Response = AddScriptToEvaluateOnNewDocumentResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for AddScriptToEvaluateOnNewDocumentResponse<'a> {
        type Command = AddScriptToEvaluateOnNewDocumentCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Removes given script from the list.\n\n# Command `Page.removeScriptToEvaluateOnNewDocument`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::RemoveScriptToEvaluateOnNewDocumentCommand`](struct.RemoveScriptToEvaluateOnNewDocumentCommand.html)  \n*Response Struct:* [`cdp::proto::page::RemoveScriptToEvaluateOnNewDocumentResponse`](struct.RemoveScriptToEvaluateOnNewDocumentResponse.html)"]
    pub struct RemoveScriptToEvaluateOnNewDocumentCommand<'a> {
        #[serde(rename = "identifier")]
        pub identifier: ::proto::page::ScriptIdentifier<'a>,
    }
    impl<'a> ::traits::SerializeCdpCommand for RemoveScriptToEvaluateOnNewDocumentCommand<'a> {
        fn command_name(&self) -> &str {
            "Page.removeScriptToEvaluateOnNewDocument"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de>
        for RemoveScriptToEvaluateOnNewDocumentCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.removeScriptToEvaluateOnNewDocument" {
                Ok ( < RemoveScriptToEvaluateOnNewDocumentCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Removes given script from the list.\n\n# Command `Page.removeScriptToEvaluateOnNewDocument`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::RemoveScriptToEvaluateOnNewDocumentCommand`](struct.RemoveScriptToEvaluateOnNewDocumentCommand.html)  \n*Response Struct:* [`cdp::proto::page::RemoveScriptToEvaluateOnNewDocumentResponse`](struct.RemoveScriptToEvaluateOnNewDocumentResponse.html)"]
    pub struct RemoveScriptToEvaluateOnNewDocumentResponse;
    impl ::serde::Serialize for RemoveScriptToEvaluateOnNewDocumentResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for RemoveScriptToEvaluateOnNewDocumentResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| RemoveScriptToEvaluateOnNewDocumentResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for RemoveScriptToEvaluateOnNewDocumentCommand<'a> {
        type Response = RemoveScriptToEvaluateOnNewDocumentResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for RemoveScriptToEvaluateOnNewDocumentResponse {
        type Command = RemoveScriptToEvaluateOnNewDocumentCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Controls whether browser will open a new inspector window for connected pages.\n\n# Command `Page.setAutoAttachToCreatedPages`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::SetAutoAttachToCreatedPagesCommand`](struct.SetAutoAttachToCreatedPagesCommand.html)  \n*Response Struct:* [`cdp::proto::page::SetAutoAttachToCreatedPagesResponse`](struct.SetAutoAttachToCreatedPagesResponse.html)"]
    pub struct SetAutoAttachToCreatedPagesCommand {
        #[serde(rename = "autoAttach")]
        #[doc = "If true, browser will open a new inspector window for every page created from this one."]
        pub auto_attach: bool,
    }
    impl ::traits::SerializeCdpCommand for SetAutoAttachToCreatedPagesCommand {
        fn command_name(&self) -> &str {
            "Page.setAutoAttachToCreatedPages"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for SetAutoAttachToCreatedPagesCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.setAutoAttachToCreatedPages" {
                Ok ( < SetAutoAttachToCreatedPagesCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Controls whether browser will open a new inspector window for connected pages.\n\n# Command `Page.setAutoAttachToCreatedPages`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::SetAutoAttachToCreatedPagesCommand`](struct.SetAutoAttachToCreatedPagesCommand.html)  \n*Response Struct:* [`cdp::proto::page::SetAutoAttachToCreatedPagesResponse`](struct.SetAutoAttachToCreatedPagesResponse.html)"]
    pub struct SetAutoAttachToCreatedPagesResponse;
    impl ::serde::Serialize for SetAutoAttachToCreatedPagesResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetAutoAttachToCreatedPagesResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetAutoAttachToCreatedPagesResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetAutoAttachToCreatedPagesCommand {
        type Response = SetAutoAttachToCreatedPagesResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetAutoAttachToCreatedPagesResponse {
        type Command = SetAutoAttachToCreatedPagesCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Reloads given page optionally ignoring the cache.\n\n# Command `Page.reload`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::ReloadCommand`](struct.ReloadCommand.html)  \n*Response Struct:* [`cdp::proto::page::ReloadResponse`](struct.ReloadResponse.html)"]
    pub struct ReloadCommand<'a> {
        #[serde(rename = "ignoreCache", skip_serializing_if = "Option::is_none")]
        #[doc = "If true, browser cache is ignored \\(as if the user pressed Shift+refresh\\)."]
        pub ignore_cache: Option<bool>,
        #[serde(rename = "scriptToEvaluateOnLoad", skip_serializing_if = "Option::is_none")]
        #[doc = "If set, the script will be injected into all frames of the inspected page after reload."]
        pub script_to_evaluate_on_load: Option<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::traits::SerializeCdpCommand for ReloadCommand<'a> {
        fn command_name(&self) -> &str {
            "Page.reload"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for ReloadCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.reload" {
                Ok(
                    <ReloadCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Reloads given page optionally ignoring the cache.\n\n# Command `Page.reload`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::ReloadCommand`](struct.ReloadCommand.html)  \n*Response Struct:* [`cdp::proto::page::ReloadResponse`](struct.ReloadResponse.html)"]
    pub struct ReloadResponse;
    impl ::serde::Serialize for ReloadResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ReloadResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ReloadResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for ReloadCommand<'a> {
        type Response = ReloadResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for ReloadResponse {
        type Command = ReloadCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Navigates current page to the given URL.\n\n# Command `Page.navigate`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::NavigateCommand`](struct.NavigateCommand.html)  \n*Response Struct:* [`cdp::proto::page::NavigateResponse`](struct.NavigateResponse.html)"]
    pub struct NavigateCommand<'a> {
        #[serde(rename = "url")]
        #[doc = "URL to navigate the page to."]
        pub url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "referrer", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Referrer URL."]
        pub referrer: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "transitionType", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Intended transition type."]
        pub transition_type: Option<::proto::page::TransitionType>,
    }
    impl<'a> ::traits::SerializeCdpCommand for NavigateCommand<'a> {
        fn command_name(&self) -> &str {
            "Page.navigate"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for NavigateCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.navigate" {
                Ok(
                    <NavigateCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Navigates current page to the given URL.\n\n# Command `Page.navigate`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::NavigateCommand`](struct.NavigateCommand.html)  \n*Response Struct:* [`cdp::proto::page::NavigateResponse`](struct.NavigateResponse.html)"]
    pub struct NavigateResponse<'a> {
        #[serde(rename = "frameId")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Frame id that will be navigated."]
        pub frame_id: ::proto::page::FrameId<'a>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for NavigateCommand<'a> {
        type Response = NavigateResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for NavigateResponse<'a> {
        type Command = NavigateCommand<'a>;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Force the page stop all navigations and pending resource fetches.\n\n# Command `Page.stopLoading`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::StopLoadingCommand`](struct.StopLoadingCommand.html)  \n*Response Struct:* [`cdp::proto::page::StopLoadingResponse`](struct.StopLoadingResponse.html)"]
    pub struct StopLoadingCommand;
    impl ::serde::Serialize for StopLoadingCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StopLoadingCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StopLoadingCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for StopLoadingCommand {
        fn command_name(&self) -> &str {
            "Page.stopLoading"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for StopLoadingCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.stopLoading" {
                Ok(
                    <StopLoadingCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Force the page stop all navigations and pending resource fetches.\n\n# Command `Page.stopLoading`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::StopLoadingCommand`](struct.StopLoadingCommand.html)  \n*Response Struct:* [`cdp::proto::page::StopLoadingResponse`](struct.StopLoadingResponse.html)"]
    pub struct StopLoadingResponse;
    impl ::serde::Serialize for StopLoadingResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StopLoadingResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StopLoadingResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for StopLoadingCommand {
        type Response = StopLoadingResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for StopLoadingResponse {
        type Command = StopLoadingCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns navigation history for the current page.\n\n# Command `Page.getNavigationHistory`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::GetNavigationHistoryCommand`](struct.GetNavigationHistoryCommand.html)  \n*Response Struct:* [`cdp::proto::page::GetNavigationHistoryResponse`](struct.GetNavigationHistoryResponse.html)"]
    pub struct GetNavigationHistoryCommand;
    impl ::serde::Serialize for GetNavigationHistoryCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetNavigationHistoryCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| GetNavigationHistoryCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for GetNavigationHistoryCommand {
        fn command_name(&self) -> &str {
            "Page.getNavigationHistory"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for GetNavigationHistoryCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.getNavigationHistory" {
                Ok ( < GetNavigationHistoryCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns navigation history for the current page.\n\n# Command `Page.getNavigationHistory`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::GetNavigationHistoryCommand`](struct.GetNavigationHistoryCommand.html)  \n*Response Struct:* [`cdp::proto::page::GetNavigationHistoryResponse`](struct.GetNavigationHistoryResponse.html)"]
    pub struct GetNavigationHistoryResponse<'a> {
        #[serde(rename = "currentIndex")]
        #[doc = "Index of the current navigation history entry."]
        pub current_index: i32,
        #[serde(rename = "entries")]
        #[doc = "Array of navigation history entries."]
        pub entries: Vec<::proto::page::NavigationEntry<'a>>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for GetNavigationHistoryCommand {
        type Response = GetNavigationHistoryResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for GetNavigationHistoryResponse<'a> {
        type Command = GetNavigationHistoryCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Navigates current page to the given history entry.\n\n# Command `Page.navigateToHistoryEntry`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::NavigateToHistoryEntryCommand`](struct.NavigateToHistoryEntryCommand.html)  \n*Response Struct:* [`cdp::proto::page::NavigateToHistoryEntryResponse`](struct.NavigateToHistoryEntryResponse.html)"]
    pub struct NavigateToHistoryEntryCommand {
        #[serde(rename = "entryId")]
        #[doc = "Unique id of the entry to navigate to."]
        pub entry_id: i32,
    }
    impl ::traits::SerializeCdpCommand for NavigateToHistoryEntryCommand {
        fn command_name(&self) -> &str {
            "Page.navigateToHistoryEntry"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for NavigateToHistoryEntryCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.navigateToHistoryEntry" {
                Ok ( < NavigateToHistoryEntryCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Navigates current page to the given history entry.\n\n# Command `Page.navigateToHistoryEntry`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::NavigateToHistoryEntryCommand`](struct.NavigateToHistoryEntryCommand.html)  \n*Response Struct:* [`cdp::proto::page::NavigateToHistoryEntryResponse`](struct.NavigateToHistoryEntryResponse.html)"]
    pub struct NavigateToHistoryEntryResponse;
    impl ::serde::Serialize for NavigateToHistoryEntryResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for NavigateToHistoryEntryResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| NavigateToHistoryEntryResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for NavigateToHistoryEntryCommand {
        type Response = NavigateToHistoryEntryResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for NavigateToHistoryEntryResponse {
        type Command = NavigateToHistoryEntryCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns all browser cookies. Depending on the backend support, will return detailed cookie information in the <code>cookies</code> field.\n\n# Command `Page.getCookies`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::GetCookiesCommand`](struct.GetCookiesCommand.html)  \n*Response Struct:* [`cdp::proto::page::GetCookiesResponse`](struct.GetCookiesResponse.html)"]
    pub struct GetCookiesCommand;
    impl ::serde::Serialize for GetCookiesCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetCookiesCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| GetCookiesCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for GetCookiesCommand {
        fn command_name(&self) -> &str {
            "Page.getCookies"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for GetCookiesCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.getCookies" {
                Ok(
                    <GetCookiesCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns all browser cookies. Depending on the backend support, will return detailed cookie information in the <code>cookies</code> field.\n\n# Command `Page.getCookies`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::GetCookiesCommand`](struct.GetCookiesCommand.html)  \n*Response Struct:* [`cdp::proto::page::GetCookiesResponse`](struct.GetCookiesResponse.html)"]
    pub struct GetCookiesResponse<'a> {
        #[serde(rename = "cookies")]
        #[doc = "Array of cookie objects."]
        pub cookies: Vec<::proto::network::Cookie<'a>>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for GetCookiesCommand {
        type Response = GetCookiesResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for GetCookiesResponse<'a> {
        type Command = GetCookiesCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Deletes browser cookie with given name, domain and path.\n\n# Command `Page.deleteCookie`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::DeleteCookieCommand`](struct.DeleteCookieCommand.html)  \n*Response Struct:* [`cdp::proto::page::DeleteCookieResponse`](struct.DeleteCookieResponse.html)"]
    pub struct DeleteCookieCommand<'a> {
        #[serde(rename = "cookieName")]
        #[doc = "Name of the cookie to remove."]
        pub cookie_name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "url")]
        #[doc = "URL to match cooke domain and path."]
        pub url: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpCommand for DeleteCookieCommand<'a> {
        fn command_name(&self) -> &str {
            "Page.deleteCookie"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for DeleteCookieCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.deleteCookie" {
                Ok(
                    <DeleteCookieCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Deletes browser cookie with given name, domain and path.\n\n# Command `Page.deleteCookie`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::DeleteCookieCommand`](struct.DeleteCookieCommand.html)  \n*Response Struct:* [`cdp::proto::page::DeleteCookieResponse`](struct.DeleteCookieResponse.html)"]
    pub struct DeleteCookieResponse;
    impl ::serde::Serialize for DeleteCookieResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DeleteCookieResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DeleteCookieResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for DeleteCookieCommand<'a> {
        type Response = DeleteCookieResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for DeleteCookieResponse {
        type Command = DeleteCookieCommand<'a>;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns present frame / resource tree structure.\n\n# Command `Page.getResourceTree`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::GetResourceTreeCommand`](struct.GetResourceTreeCommand.html)  \n*Response Struct:* [`cdp::proto::page::GetResourceTreeResponse`](struct.GetResourceTreeResponse.html)"]
    pub struct GetResourceTreeCommand;
    impl ::serde::Serialize for GetResourceTreeCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetResourceTreeCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| GetResourceTreeCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for GetResourceTreeCommand {
        fn command_name(&self) -> &str {
            "Page.getResourceTree"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for GetResourceTreeCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.getResourceTree" {
                Ok(
                    <GetResourceTreeCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns present frame / resource tree structure.\n\n# Command `Page.getResourceTree`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::GetResourceTreeCommand`](struct.GetResourceTreeCommand.html)  \n*Response Struct:* [`cdp::proto::page::GetResourceTreeResponse`](struct.GetResourceTreeResponse.html)"]
    pub struct GetResourceTreeResponse<'a> {
        #[serde(rename = "frameTree")]
        #[doc = "Present frame / resource tree structure."]
        pub frame_tree: ::proto::page::FrameResourceTree<'a>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for GetResourceTreeCommand {
        type Response = GetResourceTreeResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for GetResourceTreeResponse<'a> {
        type Command = GetResourceTreeCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns content of the given resource.\n\n# Command `Page.getResourceContent`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::GetResourceContentCommand`](struct.GetResourceContentCommand.html)  \n*Response Struct:* [`cdp::proto::page::GetResourceContentResponse`](struct.GetResourceContentResponse.html)"]
    pub struct GetResourceContentCommand<'a> {
        #[serde(rename = "frameId")]
        #[doc = "Frame id to get resource for."]
        pub frame_id: ::proto::page::FrameId<'a>,
        #[serde(rename = "url")]
        #[doc = "URL of the resource to get content for."]
        pub url: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpCommand for GetResourceContentCommand<'a> {
        fn command_name(&self) -> &str {
            "Page.getResourceContent"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for GetResourceContentCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.getResourceContent" {
                Ok ( < GetResourceContentCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns content of the given resource.\n\n# Command `Page.getResourceContent`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::GetResourceContentCommand`](struct.GetResourceContentCommand.html)  \n*Response Struct:* [`cdp::proto::page::GetResourceContentResponse`](struct.GetResourceContentResponse.html)"]
    pub struct GetResourceContentResponse<'a> {
        #[serde(rename = "content")]
        #[doc = "Resource content."]
        pub content: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "base64Encoded")]
        #[doc = "True, if content was served as base64."]
        pub base_64_encoded: bool,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for GetResourceContentCommand<'a> {
        type Response = GetResourceContentResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for GetResourceContentResponse<'a> {
        type Command = GetResourceContentCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Searches for given string in resource content.\n\n# Command `Page.searchInResource`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::SearchInResourceCommand`](struct.SearchInResourceCommand.html)  \n*Response Struct:* [`cdp::proto::page::SearchInResourceResponse`](struct.SearchInResourceResponse.html)"]
    pub struct SearchInResourceCommand<'a> {
        #[serde(rename = "frameId")]
        #[doc = "Frame id for resource to search in."]
        pub frame_id: ::proto::page::FrameId<'a>,
        #[serde(rename = "url")]
        #[doc = "URL of the resource to search in."]
        pub url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "query")]
        #[doc = "String to search for."]
        pub query: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "caseSensitive", skip_serializing_if = "Option::is_none")]
        #[doc = "If true, search is case sensitive."]
        pub case_sensitive: Option<bool>,
        #[serde(rename = "isRegex", skip_serializing_if = "Option::is_none")]
        #[doc = "If true, treats string parameter as regex."]
        pub is_regex: Option<bool>,
    }
    impl<'a> ::traits::SerializeCdpCommand for SearchInResourceCommand<'a> {
        fn command_name(&self) -> &str {
            "Page.searchInResource"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for SearchInResourceCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.searchInResource" {
                Ok ( < SearchInResourceCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Searches for given string in resource content.\n\n# Command `Page.searchInResource`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::SearchInResourceCommand`](struct.SearchInResourceCommand.html)  \n*Response Struct:* [`cdp::proto::page::SearchInResourceResponse`](struct.SearchInResourceResponse.html)"]
    pub struct SearchInResourceResponse<'a> {
        #[serde(rename = "result")]
        #[doc = "List of search matches."]
        pub result: Vec<::proto::debugger::SearchMatch<'a>>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SearchInResourceCommand<'a> {
        type Response = SearchInResourceResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SearchInResourceResponse<'a> {
        type Command = SearchInResourceCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Sets given markup as the document's HTML.\n\n# Command `Page.setDocumentContent`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::SetDocumentContentCommand`](struct.SetDocumentContentCommand.html)  \n*Response Struct:* [`cdp::proto::page::SetDocumentContentResponse`](struct.SetDocumentContentResponse.html)"]
    pub struct SetDocumentContentCommand<'a> {
        #[serde(rename = "frameId")]
        #[doc = "Frame id to set HTML for."]
        pub frame_id: ::proto::page::FrameId<'a>,
        #[serde(rename = "html")]
        #[doc = "HTML content to set."]
        pub html: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpCommand for SetDocumentContentCommand<'a> {
        fn command_name(&self) -> &str {
            "Page.setDocumentContent"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for SetDocumentContentCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.setDocumentContent" {
                Ok ( < SetDocumentContentCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Sets given markup as the document's HTML.\n\n# Command `Page.setDocumentContent`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::SetDocumentContentCommand`](struct.SetDocumentContentCommand.html)  \n*Response Struct:* [`cdp::proto::page::SetDocumentContentResponse`](struct.SetDocumentContentResponse.html)"]
    pub struct SetDocumentContentResponse;
    impl ::serde::Serialize for SetDocumentContentResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetDocumentContentResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetDocumentContentResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetDocumentContentCommand<'a> {
        type Response = SetDocumentContentResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetDocumentContentResponse {
        type Command = SetDocumentContentCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Overrides the values of device screen dimensions \\(window.screen.width, window.screen.height, window.innerWidth, window.innerHeight, and \"device-width\"/\"device-height\"-related CSS media query results\\).\n\n# Command `Page.setDeviceMetricsOverride`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::SetDeviceMetricsOverrideCommand`](struct.SetDeviceMetricsOverrideCommand.html)  \n*Response Struct:* [`cdp::proto::page::SetDeviceMetricsOverrideResponse`](struct.SetDeviceMetricsOverrideResponse.html)"]
    pub struct SetDeviceMetricsOverrideCommand {
        #[serde(rename = "width")]
        #[doc = "Overriding width value in pixels \\(minimum 0, maximum 10000000\\). 0 disables the override."]
        pub width: i32,
        #[serde(rename = "height")]
        #[doc = "Overriding height value in pixels \\(minimum 0, maximum 10000000\\). 0 disables the override."]
        pub height: i32,
        #[serde(rename = "deviceScaleFactor")]
        #[doc = "Overriding device scale factor value. 0 disables the override."]
        pub device_scale_factor: f64,
        #[serde(rename = "mobile")]
        #[doc = "Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more."]
        pub mobile: bool,
        #[serde(rename = "scale", skip_serializing_if = "Option::is_none")]
        #[doc = "Scale to apply to resulting view image. Ignored in |fitWindow| mode."]
        pub scale: Option<f64>,
        #[serde(rename = "screenWidth", skip_serializing_if = "Option::is_none")]
        #[doc = "Overriding screen width value in pixels \\(minimum 0, maximum 10000000\\). Only used for |mobile==true|."]
        pub screen_width: Option<i32>,
        #[serde(rename = "screenHeight", skip_serializing_if = "Option::is_none")]
        #[doc = "Overriding screen height value in pixels \\(minimum 0, maximum 10000000\\). Only used for |mobile==true|."]
        pub screen_height: Option<i32>,
        #[serde(rename = "positionX", skip_serializing_if = "Option::is_none")]
        #[doc = "Overriding view X position on screen in pixels \\(minimum 0, maximum 10000000\\). Only used for |mobile==true|."]
        pub position_x: Option<i32>,
        #[serde(rename = "positionY", skip_serializing_if = "Option::is_none")]
        #[doc = "Overriding view Y position on screen in pixels \\(minimum 0, maximum 10000000\\). Only used for |mobile==true|."]
        pub position_y: Option<i32>,
        #[serde(rename = "dontSetVisibleSize", skip_serializing_if = "Option::is_none")]
        #[doc = "Do not set visible view size, rely upon explicit setVisibleSize call."]
        pub dont_set_visible_size: Option<bool>,
        #[serde(rename = "screenOrientation", skip_serializing_if = "Option::is_none")]
        #[doc = "Screen orientation override."]
        pub screen_orientation: Option<::proto::emulation::ScreenOrientation>,
    }
    impl ::traits::SerializeCdpCommand for SetDeviceMetricsOverrideCommand {
        fn command_name(&self) -> &str {
            "Page.setDeviceMetricsOverride"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for SetDeviceMetricsOverrideCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.setDeviceMetricsOverride" {
                Ok ( < SetDeviceMetricsOverrideCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Overrides the values of device screen dimensions \\(window.screen.width, window.screen.height, window.innerWidth, window.innerHeight, and \"device-width\"/\"device-height\"-related CSS media query results\\).\n\n# Command `Page.setDeviceMetricsOverride`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::SetDeviceMetricsOverrideCommand`](struct.SetDeviceMetricsOverrideCommand.html)  \n*Response Struct:* [`cdp::proto::page::SetDeviceMetricsOverrideResponse`](struct.SetDeviceMetricsOverrideResponse.html)"]
    pub struct SetDeviceMetricsOverrideResponse;
    impl ::serde::Serialize for SetDeviceMetricsOverrideResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetDeviceMetricsOverrideResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetDeviceMetricsOverrideResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetDeviceMetricsOverrideCommand {
        type Response = SetDeviceMetricsOverrideResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetDeviceMetricsOverrideResponse {
        type Command = SetDeviceMetricsOverrideCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Clears the overriden device metrics.\n\n# Command `Page.clearDeviceMetricsOverride`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::ClearDeviceMetricsOverrideCommand`](struct.ClearDeviceMetricsOverrideCommand.html)  \n*Response Struct:* [`cdp::proto::page::ClearDeviceMetricsOverrideResponse`](struct.ClearDeviceMetricsOverrideResponse.html)"]
    pub struct ClearDeviceMetricsOverrideCommand;
    impl ::serde::Serialize for ClearDeviceMetricsOverrideCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ClearDeviceMetricsOverrideCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ClearDeviceMetricsOverrideCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for ClearDeviceMetricsOverrideCommand {
        fn command_name(&self) -> &str {
            "Page.clearDeviceMetricsOverride"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for ClearDeviceMetricsOverrideCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.clearDeviceMetricsOverride" {
                Ok ( < ClearDeviceMetricsOverrideCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Clears the overriden device metrics.\n\n# Command `Page.clearDeviceMetricsOverride`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::ClearDeviceMetricsOverrideCommand`](struct.ClearDeviceMetricsOverrideCommand.html)  \n*Response Struct:* [`cdp::proto::page::ClearDeviceMetricsOverrideResponse`](struct.ClearDeviceMetricsOverrideResponse.html)"]
    pub struct ClearDeviceMetricsOverrideResponse;
    impl ::serde::Serialize for ClearDeviceMetricsOverrideResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ClearDeviceMetricsOverrideResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ClearDeviceMetricsOverrideResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for ClearDeviceMetricsOverrideCommand {
        type Response = ClearDeviceMetricsOverrideResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for ClearDeviceMetricsOverrideResponse {
        type Command = ClearDeviceMetricsOverrideCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position unavailable.\n\n# Command `Page.setGeolocationOverride`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::SetGeolocationOverrideCommand`](struct.SetGeolocationOverrideCommand.html)  \n*Response Struct:* [`cdp::proto::page::SetGeolocationOverrideResponse`](struct.SetGeolocationOverrideResponse.html)"]
    pub struct SetGeolocationOverrideCommand {
        #[serde(rename = "latitude", skip_serializing_if = "Option::is_none")]
        #[doc = "Mock latitude"]
        pub latitude: Option<f64>,
        #[serde(rename = "longitude", skip_serializing_if = "Option::is_none")]
        #[doc = "Mock longitude"]
        pub longitude: Option<f64>,
        #[serde(rename = "accuracy", skip_serializing_if = "Option::is_none")]
        #[doc = "Mock accuracy"]
        pub accuracy: Option<f64>,
    }
    impl ::traits::SerializeCdpCommand for SetGeolocationOverrideCommand {
        fn command_name(&self) -> &str {
            "Page.setGeolocationOverride"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for SetGeolocationOverrideCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.setGeolocationOverride" {
                Ok ( < SetGeolocationOverrideCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position unavailable.\n\n# Command `Page.setGeolocationOverride`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::SetGeolocationOverrideCommand`](struct.SetGeolocationOverrideCommand.html)  \n*Response Struct:* [`cdp::proto::page::SetGeolocationOverrideResponse`](struct.SetGeolocationOverrideResponse.html)"]
    pub struct SetGeolocationOverrideResponse;
    impl ::serde::Serialize for SetGeolocationOverrideResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetGeolocationOverrideResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetGeolocationOverrideResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetGeolocationOverrideCommand {
        type Response = SetGeolocationOverrideResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetGeolocationOverrideResponse {
        type Command = SetGeolocationOverrideCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Clears the overriden Geolocation Position and Error.\n\n# Command `Page.clearGeolocationOverride`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::ClearGeolocationOverrideCommand`](struct.ClearGeolocationOverrideCommand.html)  \n*Response Struct:* [`cdp::proto::page::ClearGeolocationOverrideResponse`](struct.ClearGeolocationOverrideResponse.html)"]
    pub struct ClearGeolocationOverrideCommand;
    impl ::serde::Serialize for ClearGeolocationOverrideCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ClearGeolocationOverrideCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ClearGeolocationOverrideCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for ClearGeolocationOverrideCommand {
        fn command_name(&self) -> &str {
            "Page.clearGeolocationOverride"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for ClearGeolocationOverrideCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.clearGeolocationOverride" {
                Ok ( < ClearGeolocationOverrideCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Clears the overriden Geolocation Position and Error.\n\n# Command `Page.clearGeolocationOverride`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::ClearGeolocationOverrideCommand`](struct.ClearGeolocationOverrideCommand.html)  \n*Response Struct:* [`cdp::proto::page::ClearGeolocationOverrideResponse`](struct.ClearGeolocationOverrideResponse.html)"]
    pub struct ClearGeolocationOverrideResponse;
    impl ::serde::Serialize for ClearGeolocationOverrideResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ClearGeolocationOverrideResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ClearGeolocationOverrideResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for ClearGeolocationOverrideCommand {
        type Response = ClearGeolocationOverrideResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for ClearGeolocationOverrideResponse {
        type Command = ClearGeolocationOverrideCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Overrides the Device Orientation.\n\n# Command `Page.setDeviceOrientationOverride`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::SetDeviceOrientationOverrideCommand`](struct.SetDeviceOrientationOverrideCommand.html)  \n*Response Struct:* [`cdp::proto::page::SetDeviceOrientationOverrideResponse`](struct.SetDeviceOrientationOverrideResponse.html)"]
    pub struct SetDeviceOrientationOverrideCommand {
        #[serde(rename = "alpha")]
        #[doc = "Mock alpha"]
        pub alpha: f64,
        #[serde(rename = "beta")]
        #[doc = "Mock beta"]
        pub beta: f64,
        #[serde(rename = "gamma")]
        #[doc = "Mock gamma"]
        pub gamma: f64,
    }
    impl ::traits::SerializeCdpCommand for SetDeviceOrientationOverrideCommand {
        fn command_name(&self) -> &str {
            "Page.setDeviceOrientationOverride"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for SetDeviceOrientationOverrideCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.setDeviceOrientationOverride" {
                Ok ( < SetDeviceOrientationOverrideCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Overrides the Device Orientation.\n\n# Command `Page.setDeviceOrientationOverride`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::SetDeviceOrientationOverrideCommand`](struct.SetDeviceOrientationOverrideCommand.html)  \n*Response Struct:* [`cdp::proto::page::SetDeviceOrientationOverrideResponse`](struct.SetDeviceOrientationOverrideResponse.html)"]
    pub struct SetDeviceOrientationOverrideResponse;
    impl ::serde::Serialize for SetDeviceOrientationOverrideResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetDeviceOrientationOverrideResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetDeviceOrientationOverrideResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetDeviceOrientationOverrideCommand {
        type Response = SetDeviceOrientationOverrideResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetDeviceOrientationOverrideResponse {
        type Command = SetDeviceOrientationOverrideCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Clears the overridden Device Orientation.\n\n# Command `Page.clearDeviceOrientationOverride`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::ClearDeviceOrientationOverrideCommand`](struct.ClearDeviceOrientationOverrideCommand.html)  \n*Response Struct:* [`cdp::proto::page::ClearDeviceOrientationOverrideResponse`](struct.ClearDeviceOrientationOverrideResponse.html)"]
    pub struct ClearDeviceOrientationOverrideCommand;
    impl ::serde::Serialize for ClearDeviceOrientationOverrideCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ClearDeviceOrientationOverrideCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ClearDeviceOrientationOverrideCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for ClearDeviceOrientationOverrideCommand {
        fn command_name(&self) -> &str {
            "Page.clearDeviceOrientationOverride"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for ClearDeviceOrientationOverrideCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.clearDeviceOrientationOverride" {
                Ok ( < ClearDeviceOrientationOverrideCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Clears the overridden Device Orientation.\n\n# Command `Page.clearDeviceOrientationOverride`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::ClearDeviceOrientationOverrideCommand`](struct.ClearDeviceOrientationOverrideCommand.html)  \n*Response Struct:* [`cdp::proto::page::ClearDeviceOrientationOverrideResponse`](struct.ClearDeviceOrientationOverrideResponse.html)"]
    pub struct ClearDeviceOrientationOverrideResponse;
    impl ::serde::Serialize for ClearDeviceOrientationOverrideResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ClearDeviceOrientationOverrideResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ClearDeviceOrientationOverrideResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for ClearDeviceOrientationOverrideCommand {
        type Response = ClearDeviceOrientationOverrideResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for ClearDeviceOrientationOverrideResponse {
        type Command = ClearDeviceOrientationOverrideCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\nUsed in the type of [`cdp::proto::page::SetTouchEmulationEnabledCommand::configuration`](struct.SetTouchEmulationEnabledCommand.html#structfield.configuration)."]
    pub enum SetTouchEmulationEnabledCommandConfiguration {
        #[serde(rename = "mobile")]
        #[doc = "Represented as `\"mobile\"`."]
        Mobile,
        #[serde(rename = "desktop")]
        #[doc = "Represented as `\"desktop\"`."]
        Desktop,
    }
    impl SetTouchEmulationEnabledCommandConfiguration {
        pub const ENUM_VALUES: &'static [SetTouchEmulationEnabledCommandConfiguration] =
            &[
                SetTouchEmulationEnabledCommandConfiguration::Mobile,
                SetTouchEmulationEnabledCommandConfiguration::Desktop,
            ];
        pub const STR_VALUES: &'static [&'static str] = &["mobile", "desktop"];
    }
    impl ::std::str::FromStr for SetTouchEmulationEnabledCommandConfiguration {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "mobile" => Ok(SetTouchEmulationEnabledCommandConfiguration::Mobile),
                "desktop" => Ok(SetTouchEmulationEnabledCommandConfiguration::Desktop),
                _ => Err(::proto::ParseEnumError {
                    expected: SetTouchEmulationEnabledCommandConfiguration::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for SetTouchEmulationEnabledCommandConfiguration {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    SetTouchEmulationEnabledCommandConfiguration::Mobile => "mobile",
                    SetTouchEmulationEnabledCommandConfiguration::Desktop => "desktop",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Toggles mouse event-based touch event emulation.\n\n# Command `Page.setTouchEmulationEnabled`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::SetTouchEmulationEnabledCommand`](struct.SetTouchEmulationEnabledCommand.html)  \n*Response Struct:* [`cdp::proto::page::SetTouchEmulationEnabledResponse`](struct.SetTouchEmulationEnabledResponse.html)"]
    pub struct SetTouchEmulationEnabledCommand {
        #[serde(rename = "enabled")]
        #[doc = "Whether the touch event emulation should be enabled."]
        pub enabled: bool,
        #[serde(rename = "configuration", skip_serializing_if = "Option::is_none")]
        #[doc = "Touch/gesture events configuration. Default: current platform."]
        pub configuration:
            Option<::proto::page::SetTouchEmulationEnabledCommandConfiguration>,
    }
    impl ::traits::SerializeCdpCommand for SetTouchEmulationEnabledCommand {
        fn command_name(&self) -> &str {
            "Page.setTouchEmulationEnabled"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for SetTouchEmulationEnabledCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.setTouchEmulationEnabled" {
                Ok ( < SetTouchEmulationEnabledCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Toggles mouse event-based touch event emulation.\n\n# Command `Page.setTouchEmulationEnabled`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::SetTouchEmulationEnabledCommand`](struct.SetTouchEmulationEnabledCommand.html)  \n*Response Struct:* [`cdp::proto::page::SetTouchEmulationEnabledResponse`](struct.SetTouchEmulationEnabledResponse.html)"]
    pub struct SetTouchEmulationEnabledResponse;
    impl ::serde::Serialize for SetTouchEmulationEnabledResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetTouchEmulationEnabledResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetTouchEmulationEnabledResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetTouchEmulationEnabledCommand {
        type Response = SetTouchEmulationEnabledResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetTouchEmulationEnabledResponse {
        type Command = SetTouchEmulationEnabledCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\nUsed in the type of [`cdp::proto::page::CaptureScreenshotCommand::format`](struct.CaptureScreenshotCommand.html#structfield.format)."]
    pub enum CaptureScreenshotCommandFormat {
        #[serde(rename = "jpeg")]
        #[doc = "Represented as `\"jpeg\"`."]
        Jpeg,
        #[serde(rename = "png")]
        #[doc = "Represented as `\"png\"`."]
        Png,
    }
    impl CaptureScreenshotCommandFormat {
        pub const ENUM_VALUES: &'static [CaptureScreenshotCommandFormat] =
            &[
                CaptureScreenshotCommandFormat::Jpeg,
                CaptureScreenshotCommandFormat::Png,
            ];
        pub const STR_VALUES: &'static [&'static str] = &["jpeg", "png"];
    }
    impl ::std::str::FromStr for CaptureScreenshotCommandFormat {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "jpeg" => Ok(CaptureScreenshotCommandFormat::Jpeg),
                "png" => Ok(CaptureScreenshotCommandFormat::Png),
                _ => Err(::proto::ParseEnumError {
                    expected: CaptureScreenshotCommandFormat::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for CaptureScreenshotCommandFormat {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    CaptureScreenshotCommandFormat::Jpeg => "jpeg",
                    CaptureScreenshotCommandFormat::Png => "png",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Capture page screenshot.\n\n# Command `Page.captureScreenshot`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::CaptureScreenshotCommand`](struct.CaptureScreenshotCommand.html)  \n*Response Struct:* [`cdp::proto::page::CaptureScreenshotResponse`](struct.CaptureScreenshotResponse.html)"]
    pub struct CaptureScreenshotCommand {
        #[serde(rename = "format", skip_serializing_if = "Option::is_none")]
        #[doc = "Image compression format \\(defaults to png\\)."]
        pub format: Option<::proto::page::CaptureScreenshotCommandFormat>,
        #[serde(rename = "quality", skip_serializing_if = "Option::is_none")]
        #[doc = "Compression quality from range \\[0..100\\] \\(jpeg only\\)."]
        pub quality: Option<i32>,
        #[serde(rename = "clip", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Capture the screenshot of a given region only."]
        pub clip: Option<::proto::page::Viewport>,
        #[serde(rename = "fromSurface", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Capture the screenshot from the surface, rather than the view. Defaults to true."]
        pub from_surface: Option<bool>,
    }
    impl ::traits::SerializeCdpCommand for CaptureScreenshotCommand {
        fn command_name(&self) -> &str {
            "Page.captureScreenshot"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for CaptureScreenshotCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.captureScreenshot" {
                Ok ( < CaptureScreenshotCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Capture page screenshot.\n\n# Command `Page.captureScreenshot`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::CaptureScreenshotCommand`](struct.CaptureScreenshotCommand.html)  \n*Response Struct:* [`cdp::proto::page::CaptureScreenshotResponse`](struct.CaptureScreenshotResponse.html)"]
    pub struct CaptureScreenshotResponse<'a> {
        #[serde(rename = "data")]
        #[doc = "Base64-encoded image data."]
        pub data: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for CaptureScreenshotCommand {
        type Response = CaptureScreenshotResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for CaptureScreenshotResponse<'a> {
        type Command = CaptureScreenshotCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Print page as PDF.\n\n# Command `Page.printToPDF`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::PrintToPdfCommand`](struct.PrintToPdfCommand.html)  \n*Response Struct:* [`cdp::proto::page::PrintToPdfResponse`](struct.PrintToPdfResponse.html)"]
    pub struct PrintToPdfCommand<'a> {
        #[serde(rename = "landscape", skip_serializing_if = "Option::is_none")]
        #[doc = "Paper orientation. Defaults to false."]
        pub landscape: Option<bool>,
        #[serde(rename = "displayHeaderFooter", skip_serializing_if = "Option::is_none")]
        #[doc = "Display header and footer. Defaults to false."]
        pub display_header_footer: Option<bool>,
        #[serde(rename = "printBackground", skip_serializing_if = "Option::is_none")]
        #[doc = "Print background graphics. Defaults to false."]
        pub print_background: Option<bool>,
        #[serde(rename = "scale", skip_serializing_if = "Option::is_none")]
        #[doc = "Scale of the webpage rendering. Defaults to 1."]
        pub scale: Option<f64>,
        #[serde(rename = "paperWidth", skip_serializing_if = "Option::is_none")]
        #[doc = "Paper width in inches. Defaults to 8.5 inches."]
        pub paper_width: Option<f64>,
        #[serde(rename = "paperHeight", skip_serializing_if = "Option::is_none")]
        #[doc = "Paper height in inches. Defaults to 11 inches."]
        pub paper_height: Option<f64>,
        #[serde(rename = "marginTop", skip_serializing_if = "Option::is_none")]
        #[doc = "Top margin in inches. Defaults to 1cm \\(~0.4 inches\\)."]
        pub margin_top: Option<f64>,
        #[serde(rename = "marginBottom", skip_serializing_if = "Option::is_none")]
        #[doc = "Bottom margin in inches. Defaults to 1cm \\(~0.4 inches\\)."]
        pub margin_bottom: Option<f64>,
        #[serde(rename = "marginLeft", skip_serializing_if = "Option::is_none")]
        #[doc = "Left margin in inches. Defaults to 1cm \\(~0.4 inches\\)."]
        pub margin_left: Option<f64>,
        #[serde(rename = "marginRight", skip_serializing_if = "Option::is_none")]
        #[doc = "Right margin in inches. Defaults to 1cm \\(~0.4 inches\\)."]
        pub margin_right: Option<f64>,
        #[serde(rename = "pageRanges", skip_serializing_if = "Option::is_none")]
        #[doc = "Paper ranges to print, e.g., '1-5, 8, 11-13'. Defaults to the empty string, which means print all pages."]
        pub page_ranges: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "ignoreInvalidPageRanges", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether to silently ignore invalid but successfully parsed page ranges, such as '3-2'. Defaults to false."]
        pub ignore_invalid_page_ranges: Option<bool>,
    }
    impl<'a> ::traits::SerializeCdpCommand for PrintToPdfCommand<'a> {
        fn command_name(&self) -> &str {
            "Page.printToPDF"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for PrintToPdfCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.printToPDF" {
                Ok(
                    <PrintToPdfCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Print page as PDF.\n\n# Command `Page.printToPDF`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::PrintToPdfCommand`](struct.PrintToPdfCommand.html)  \n*Response Struct:* [`cdp::proto::page::PrintToPdfResponse`](struct.PrintToPdfResponse.html)"]
    pub struct PrintToPdfResponse<'a> {
        #[serde(rename = "data")]
        #[doc = "Base64-encoded pdf data."]
        pub data: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for PrintToPdfCommand<'a> {
        type Response = PrintToPdfResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for PrintToPdfResponse<'a> {
        type Command = PrintToPdfCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\nUsed in the type of [`cdp::proto::page::StartScreencastCommand::format`](struct.StartScreencastCommand.html#structfield.format)."]
    pub enum StartScreencastCommandFormat {
        #[serde(rename = "jpeg")]
        #[doc = "Represented as `\"jpeg\"`."]
        Jpeg,
        #[serde(rename = "png")]
        #[doc = "Represented as `\"png\"`."]
        Png,
    }
    impl StartScreencastCommandFormat {
        pub const ENUM_VALUES: &'static [StartScreencastCommandFormat] =
            &[
                StartScreencastCommandFormat::Jpeg,
                StartScreencastCommandFormat::Png,
            ];
        pub const STR_VALUES: &'static [&'static str] = &["jpeg", "png"];
    }
    impl ::std::str::FromStr for StartScreencastCommandFormat {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "jpeg" => Ok(StartScreencastCommandFormat::Jpeg),
                "png" => Ok(StartScreencastCommandFormat::Png),
                _ => Err(::proto::ParseEnumError {
                    expected: StartScreencastCommandFormat::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for StartScreencastCommandFormat {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    StartScreencastCommandFormat::Jpeg => "jpeg",
                    StartScreencastCommandFormat::Png => "png",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Starts sending each frame using the <code>screencastFrame</code> event.\n\n# Command `Page.startScreencast`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::StartScreencastCommand`](struct.StartScreencastCommand.html)  \n*Response Struct:* [`cdp::proto::page::StartScreencastResponse`](struct.StartScreencastResponse.html)"]
    pub struct StartScreencastCommand {
        #[serde(rename = "format", skip_serializing_if = "Option::is_none")]
        #[doc = "Image compression format."]
        pub format: Option<::proto::page::StartScreencastCommandFormat>,
        #[serde(rename = "quality", skip_serializing_if = "Option::is_none")]
        #[doc = "Compression quality from range \\[0..100\\]."]
        pub quality: Option<i32>,
        #[serde(rename = "maxWidth", skip_serializing_if = "Option::is_none")]
        #[doc = "Maximum screenshot width."]
        pub max_width: Option<i32>,
        #[serde(rename = "maxHeight", skip_serializing_if = "Option::is_none")]
        #[doc = "Maximum screenshot height."]
        pub max_height: Option<i32>,
        #[serde(rename = "everyNthFrame", skip_serializing_if = "Option::is_none")]
        #[doc = "Send every n-th frame."]
        pub every_nth_frame: Option<i32>,
    }
    impl ::traits::SerializeCdpCommand for StartScreencastCommand {
        fn command_name(&self) -> &str {
            "Page.startScreencast"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for StartScreencastCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.startScreencast" {
                Ok(
                    <StartScreencastCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Starts sending each frame using the <code>screencastFrame</code> event.\n\n# Command `Page.startScreencast`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::StartScreencastCommand`](struct.StartScreencastCommand.html)  \n*Response Struct:* [`cdp::proto::page::StartScreencastResponse`](struct.StartScreencastResponse.html)"]
    pub struct StartScreencastResponse;
    impl ::serde::Serialize for StartScreencastResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StartScreencastResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StartScreencastResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for StartScreencastCommand {
        type Response = StartScreencastResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for StartScreencastResponse {
        type Command = StartScreencastCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Stops sending each frame in the <code>screencastFrame</code>.\n\n# Command `Page.stopScreencast`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::StopScreencastCommand`](struct.StopScreencastCommand.html)  \n*Response Struct:* [`cdp::proto::page::StopScreencastResponse`](struct.StopScreencastResponse.html)"]
    pub struct StopScreencastCommand;
    impl ::serde::Serialize for StopScreencastCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StopScreencastCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StopScreencastCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for StopScreencastCommand {
        fn command_name(&self) -> &str {
            "Page.stopScreencast"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for StopScreencastCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.stopScreencast" {
                Ok(
                    <StopScreencastCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Stops sending each frame in the <code>screencastFrame</code>.\n\n# Command `Page.stopScreencast`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::StopScreencastCommand`](struct.StopScreencastCommand.html)  \n*Response Struct:* [`cdp::proto::page::StopScreencastResponse`](struct.StopScreencastResponse.html)"]
    pub struct StopScreencastResponse;
    impl ::serde::Serialize for StopScreencastResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StopScreencastResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StopScreencastResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for StopScreencastCommand {
        type Response = StopScreencastResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for StopScreencastResponse {
        type Command = StopScreencastCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Acknowledges that a screencast frame has been received by the frontend.\n\n# Command `Page.screencastFrameAck`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::ScreencastFrameAckCommand`](struct.ScreencastFrameAckCommand.html)  \n*Response Struct:* [`cdp::proto::page::ScreencastFrameAckResponse`](struct.ScreencastFrameAckResponse.html)"]
    pub struct ScreencastFrameAckCommand {
        #[serde(rename = "sessionId")]
        #[doc = "Frame number."]
        pub session_id: i32,
    }
    impl ::traits::SerializeCdpCommand for ScreencastFrameAckCommand {
        fn command_name(&self) -> &str {
            "Page.screencastFrameAck"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for ScreencastFrameAckCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.screencastFrameAck" {
                Ok ( < ScreencastFrameAckCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Acknowledges that a screencast frame has been received by the frontend.\n\n# Command `Page.screencastFrameAck`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::ScreencastFrameAckCommand`](struct.ScreencastFrameAckCommand.html)  \n*Response Struct:* [`cdp::proto::page::ScreencastFrameAckResponse`](struct.ScreencastFrameAckResponse.html)"]
    pub struct ScreencastFrameAckResponse;
    impl ::serde::Serialize for ScreencastFrameAckResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ScreencastFrameAckResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ScreencastFrameAckResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for ScreencastFrameAckCommand {
        type Response = ScreencastFrameAckResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for ScreencastFrameAckResponse {
        type Command = ScreencastFrameAckCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Accepts or dismisses a JavaScript initiated dialog \\(alert, confirm, prompt, or onbeforeunload\\).\n\n# Command `Page.handleJavaScriptDialog`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::HandleJavaScriptDialogCommand`](struct.HandleJavaScriptDialogCommand.html)  \n*Response Struct:* [`cdp::proto::page::HandleJavaScriptDialogResponse`](struct.HandleJavaScriptDialogResponse.html)"]
    pub struct HandleJavaScriptDialogCommand<'a> {
        #[serde(rename = "accept")]
        #[doc = "Whether to accept or dismiss the dialog."]
        pub accept: bool,
        #[serde(rename = "promptText", skip_serializing_if = "Option::is_none")]
        #[doc = "The text to enter into the dialog prompt before accepting. Used only if this is a prompt dialog."]
        pub prompt_text: Option<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::traits::SerializeCdpCommand for HandleJavaScriptDialogCommand<'a> {
        fn command_name(&self) -> &str {
            "Page.handleJavaScriptDialog"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for HandleJavaScriptDialogCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.handleJavaScriptDialog" {
                Ok ( < HandleJavaScriptDialogCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Accepts or dismisses a JavaScript initiated dialog \\(alert, confirm, prompt, or onbeforeunload\\).\n\n# Command `Page.handleJavaScriptDialog`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::HandleJavaScriptDialogCommand`](struct.HandleJavaScriptDialogCommand.html)  \n*Response Struct:* [`cdp::proto::page::HandleJavaScriptDialogResponse`](struct.HandleJavaScriptDialogResponse.html)"]
    pub struct HandleJavaScriptDialogResponse;
    impl ::serde::Serialize for HandleJavaScriptDialogResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for HandleJavaScriptDialogResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| HandleJavaScriptDialogResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for HandleJavaScriptDialogCommand<'a> {
        type Response = HandleJavaScriptDialogResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for HandleJavaScriptDialogResponse {
        type Command = HandleJavaScriptDialogCommand<'a>;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `Page.getAppManifest`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::GetAppManifestCommand`](struct.GetAppManifestCommand.html)  \n*Response Struct:* [`cdp::proto::page::GetAppManifestResponse`](struct.GetAppManifestResponse.html)"]
    pub struct GetAppManifestCommand;
    impl ::serde::Serialize for GetAppManifestCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetAppManifestCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| GetAppManifestCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for GetAppManifestCommand {
        fn command_name(&self) -> &str {
            "Page.getAppManifest"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for GetAppManifestCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.getAppManifest" {
                Ok(
                    <GetAppManifestCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `Page.getAppManifest`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::GetAppManifestCommand`](struct.GetAppManifestCommand.html)  \n*Response Struct:* [`cdp::proto::page::GetAppManifestResponse`](struct.GetAppManifestResponse.html)"]
    pub struct GetAppManifestResponse<'a> {
        #[serde(rename = "url")]
        #[doc = "Manifest location."]
        pub url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "errors")]
        pub errors: Vec<::proto::page::AppManifestError<'a>>,
        #[serde(rename = "data", skip_serializing_if = "Option::is_none")]
        #[doc = "Manifest content."]
        pub data: Option<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for GetAppManifestCommand {
        type Response = GetAppManifestResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for GetAppManifestResponse<'a> {
        type Command = GetAppManifestCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `Page.requestAppBanner`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::RequestAppBannerCommand`](struct.RequestAppBannerCommand.html)  \n*Response Struct:* [`cdp::proto::page::RequestAppBannerResponse`](struct.RequestAppBannerResponse.html)"]
    pub struct RequestAppBannerCommand;
    impl ::serde::Serialize for RequestAppBannerCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for RequestAppBannerCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| RequestAppBannerCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for RequestAppBannerCommand {
        fn command_name(&self) -> &str {
            "Page.requestAppBanner"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for RequestAppBannerCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.requestAppBanner" {
                Ok ( < RequestAppBannerCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `Page.requestAppBanner`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::RequestAppBannerCommand`](struct.RequestAppBannerCommand.html)  \n*Response Struct:* [`cdp::proto::page::RequestAppBannerResponse`](struct.RequestAppBannerResponse.html)"]
    pub struct RequestAppBannerResponse;
    impl ::serde::Serialize for RequestAppBannerResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for RequestAppBannerResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| RequestAppBannerResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for RequestAppBannerCommand {
        type Response = RequestAppBannerResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for RequestAppBannerResponse {
        type Command = RequestAppBannerCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Toggles navigation throttling which allows programatic control over navigation and redirect response.\n\n# Command `Page.setControlNavigations`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::SetControlNavigationsCommand`](struct.SetControlNavigationsCommand.html)  \n*Response Struct:* [`cdp::proto::page::SetControlNavigationsResponse`](struct.SetControlNavigationsResponse.html)"]
    pub struct SetControlNavigationsCommand {
        #[serde(rename = "enabled")]
        pub enabled: bool,
    }
    impl ::traits::SerializeCdpCommand for SetControlNavigationsCommand {
        fn command_name(&self) -> &str {
            "Page.setControlNavigations"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for SetControlNavigationsCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.setControlNavigations" {
                Ok ( < SetControlNavigationsCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Toggles navigation throttling which allows programatic control over navigation and redirect response.\n\n# Command `Page.setControlNavigations`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::SetControlNavigationsCommand`](struct.SetControlNavigationsCommand.html)  \n*Response Struct:* [`cdp::proto::page::SetControlNavigationsResponse`](struct.SetControlNavigationsResponse.html)"]
    pub struct SetControlNavigationsResponse;
    impl ::serde::Serialize for SetControlNavigationsResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetControlNavigationsResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetControlNavigationsResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetControlNavigationsCommand {
        type Response = SetControlNavigationsResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetControlNavigationsResponse {
        type Command = SetControlNavigationsCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Should be sent in response to a navigationRequested or a redirectRequested event, telling the browser how to handle the navigation.\n\n# Command `Page.processNavigation`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::ProcessNavigationCommand`](struct.ProcessNavigationCommand.html)  \n*Response Struct:* [`cdp::proto::page::ProcessNavigationResponse`](struct.ProcessNavigationResponse.html)"]
    pub struct ProcessNavigationCommand {
        #[serde(rename = "response")]
        pub response: ::proto::page::NavigationResponse,
        #[serde(rename = "navigationId")]
        pub navigation_id: i32,
    }
    impl ::traits::SerializeCdpCommand for ProcessNavigationCommand {
        fn command_name(&self) -> &str {
            "Page.processNavigation"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for ProcessNavigationCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.processNavigation" {
                Ok ( < ProcessNavigationCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Should be sent in response to a navigationRequested or a redirectRequested event, telling the browser how to handle the navigation.\n\n# Command `Page.processNavigation`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::ProcessNavigationCommand`](struct.ProcessNavigationCommand.html)  \n*Response Struct:* [`cdp::proto::page::ProcessNavigationResponse`](struct.ProcessNavigationResponse.html)"]
    pub struct ProcessNavigationResponse;
    impl ::serde::Serialize for ProcessNavigationResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ProcessNavigationResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ProcessNavigationResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for ProcessNavigationCommand {
        type Response = ProcessNavigationResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for ProcessNavigationResponse {
        type Command = ProcessNavigationCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns metrics relating to the layouting of the page, such as viewport bounds/scale.\n\n# Command `Page.getLayoutMetrics`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::GetLayoutMetricsCommand`](struct.GetLayoutMetricsCommand.html)  \n*Response Struct:* [`cdp::proto::page::GetLayoutMetricsResponse`](struct.GetLayoutMetricsResponse.html)"]
    pub struct GetLayoutMetricsCommand;
    impl ::serde::Serialize for GetLayoutMetricsCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetLayoutMetricsCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| GetLayoutMetricsCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for GetLayoutMetricsCommand {
        fn command_name(&self) -> &str {
            "Page.getLayoutMetrics"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for GetLayoutMetricsCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.getLayoutMetrics" {
                Ok ( < GetLayoutMetricsCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns metrics relating to the layouting of the page, such as viewport bounds/scale.\n\n# Command `Page.getLayoutMetrics`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::GetLayoutMetricsCommand`](struct.GetLayoutMetricsCommand.html)  \n*Response Struct:* [`cdp::proto::page::GetLayoutMetricsResponse`](struct.GetLayoutMetricsResponse.html)"]
    pub struct GetLayoutMetricsResponse {
        #[serde(rename = "layoutViewport")]
        #[doc = "Metrics relating to the layout viewport."]
        pub layout_viewport: ::proto::page::LayoutViewport,
        #[serde(rename = "visualViewport")]
        #[doc = "Metrics relating to the visual viewport."]
        pub visual_viewport: ::proto::page::VisualViewport,
        #[serde(rename = "contentSize")]
        #[doc = "Size of scrollable area."]
        pub content_size: ::proto::dom::Rect,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for GetLayoutMetricsCommand {
        type Response = GetLayoutMetricsResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for GetLayoutMetricsResponse {
        type Command = GetLayoutMetricsCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Creates an isolated world for the given frame.\n\n# Command `Page.createIsolatedWorld`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::CreateIsolatedWorldCommand`](struct.CreateIsolatedWorldCommand.html)  \n*Response Struct:* [`cdp::proto::page::CreateIsolatedWorldResponse`](struct.CreateIsolatedWorldResponse.html)"]
    pub struct CreateIsolatedWorldCommand<'a> {
        #[serde(rename = "frameId")]
        #[doc = "Id of the frame in which the isolated world should be created."]
        pub frame_id: ::proto::page::FrameId<'a>,
        #[serde(rename = "worldName", skip_serializing_if = "Option::is_none")]
        #[doc = "An optional name which is reported in the Execution Context."]
        pub world_name: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "grantUniveralAccess", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether or not universal access should be granted to the isolated world. This is a powerful option, use with caution."]
        pub grant_univeral_access: Option<bool>,
    }
    impl<'a> ::traits::SerializeCdpCommand for CreateIsolatedWorldCommand<'a> {
        fn command_name(&self) -> &str {
            "Page.createIsolatedWorld"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for CreateIsolatedWorldCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.createIsolatedWorld" {
                Ok ( < CreateIsolatedWorldCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Creates an isolated world for the given frame.\n\n# Command `Page.createIsolatedWorld`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Command Struct:* [`cdp::proto::page::CreateIsolatedWorldCommand`](struct.CreateIsolatedWorldCommand.html)  \n*Response Struct:* [`cdp::proto::page::CreateIsolatedWorldResponse`](struct.CreateIsolatedWorldResponse.html)"]
    pub struct CreateIsolatedWorldResponse {
        #[serde(rename = "executionContextId")]
        #[doc = "Execution context of the isolated world."]
        pub execution_context_id: ::proto::runtime::ExecutionContextId,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for CreateIsolatedWorldCommand<'a> {
        type Response = CreateIsolatedWorldResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for CreateIsolatedWorldResponse {
        type Command = CreateIsolatedWorldCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "# Event `Page.domContentEventFired`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Event Struct:* [`cdp::proto::page::DomContentEventFiredEvent`](struct.DomContentEventFiredEvent.html)"]
    pub struct DomContentEventFiredEvent {
        #[serde(rename = "timestamp")]
        pub timestamp: ::proto::network::MonotonicTime,
    }
    impl ::traits::SerializeCdpEvent for DomContentEventFiredEvent {
        fn event_name(&self) -> &str {
            "Page.domContentEventFired"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpEvent<'de> for DomContentEventFiredEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.domContentEventFired" {
                Ok ( < DomContentEventFiredEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "# Event `Page.loadEventFired`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Event Struct:* [`cdp::proto::page::LoadEventFiredEvent`](struct.LoadEventFiredEvent.html)"]
    pub struct LoadEventFiredEvent {
        #[serde(rename = "timestamp")]
        pub timestamp: ::proto::network::MonotonicTime,
    }
    impl ::traits::SerializeCdpEvent for LoadEventFiredEvent {
        fn event_name(&self) -> &str {
            "Page.loadEventFired"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpEvent<'de> for LoadEventFiredEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.loadEventFired" {
                Ok(
                    <LoadEventFiredEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Fired when frame has been attached to its parent.\n\n# Event `Page.frameAttached`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Event Struct:* [`cdp::proto::page::FrameAttachedEvent`](struct.FrameAttachedEvent.html)"]
    pub struct FrameAttachedEvent<'a> {
        #[serde(rename = "frameId")]
        #[doc = "Id of the frame that has been attached."]
        pub frame_id: ::proto::page::FrameId<'a>,
        #[serde(rename = "parentFrameId")]
        #[doc = "Parent frame identifier."]
        pub parent_frame_id: ::proto::page::FrameId<'a>,
        #[serde(rename = "stack", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> JavaScript stack trace of when frame was attached, only set if frame initiated from script."]
        pub stack: Option<::proto::runtime::StackTrace<'a>>,
    }
    impl<'a> ::traits::SerializeCdpEvent for FrameAttachedEvent<'a> {
        fn event_name(&self) -> &str {
            "Page.frameAttached"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for FrameAttachedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.frameAttached" {
                Ok(
                    <FrameAttachedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Fired once navigation of the frame has completed. Frame is now associated with the new loader.\n\n# Event `Page.frameNavigated`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Event Struct:* [`cdp::proto::page::FrameNavigatedEvent`](struct.FrameNavigatedEvent.html)"]
    pub struct FrameNavigatedEvent<'a> {
        #[serde(rename = "frame")]
        #[doc = "Frame object."]
        pub frame: ::proto::page::Frame<'a>,
    }
    impl<'a> ::traits::SerializeCdpEvent for FrameNavigatedEvent<'a> {
        fn event_name(&self) -> &str {
            "Page.frameNavigated"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for FrameNavigatedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.frameNavigated" {
                Ok(
                    <FrameNavigatedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Fired when frame has been detached from its parent.\n\n# Event `Page.frameDetached`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Event Struct:* [`cdp::proto::page::FrameDetachedEvent`](struct.FrameDetachedEvent.html)"]
    pub struct FrameDetachedEvent<'a> {
        #[serde(rename = "frameId")]
        #[doc = "Id of the frame that has been detached."]
        pub frame_id: ::proto::page::FrameId<'a>,
    }
    impl<'a> ::traits::SerializeCdpEvent for FrameDetachedEvent<'a> {
        fn event_name(&self) -> &str {
            "Page.frameDetached"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for FrameDetachedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.frameDetached" {
                Ok(
                    <FrameDetachedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Fired when frame has started loading.\n\n# Event `Page.frameStartedLoading`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Event Struct:* [`cdp::proto::page::FrameStartedLoadingEvent`](struct.FrameStartedLoadingEvent.html)"]
    pub struct FrameStartedLoadingEvent<'a> {
        #[serde(rename = "frameId")]
        #[doc = "Id of the frame that has started loading."]
        pub frame_id: ::proto::page::FrameId<'a>,
    }
    impl<'a> ::traits::SerializeCdpEvent for FrameStartedLoadingEvent<'a> {
        fn event_name(&self) -> &str {
            "Page.frameStartedLoading"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for FrameStartedLoadingEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.frameStartedLoading" {
                Ok ( < FrameStartedLoadingEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Fired when frame has stopped loading.\n\n# Event `Page.frameStoppedLoading`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Event Struct:* [`cdp::proto::page::FrameStoppedLoadingEvent`](struct.FrameStoppedLoadingEvent.html)"]
    pub struct FrameStoppedLoadingEvent<'a> {
        #[serde(rename = "frameId")]
        #[doc = "Id of the frame that has stopped loading."]
        pub frame_id: ::proto::page::FrameId<'a>,
    }
    impl<'a> ::traits::SerializeCdpEvent for FrameStoppedLoadingEvent<'a> {
        fn event_name(&self) -> &str {
            "Page.frameStoppedLoading"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for FrameStoppedLoadingEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.frameStoppedLoading" {
                Ok ( < FrameStoppedLoadingEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Fired when frame schedules a potential navigation.\n\n# Event `Page.frameScheduledNavigation`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Event Struct:* [`cdp::proto::page::FrameScheduledNavigationEvent`](struct.FrameScheduledNavigationEvent.html)"]
    pub struct FrameScheduledNavigationEvent<'a> {
        #[serde(rename = "frameId")]
        #[doc = "Id of the frame that has scheduled a navigation."]
        pub frame_id: ::proto::page::FrameId<'a>,
        #[serde(rename = "delay")]
        #[doc = "Delay \\(in seconds\\) until the navigation is scheduled to begin. The navigation is not guaranteed to start."]
        pub delay: f64,
    }
    impl<'a> ::traits::SerializeCdpEvent for FrameScheduledNavigationEvent<'a> {
        fn event_name(&self) -> &str {
            "Page.frameScheduledNavigation"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for FrameScheduledNavigationEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.frameScheduledNavigation" {
                Ok ( < FrameScheduledNavigationEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Fired when frame no longer has a scheduled navigation.\n\n# Event `Page.frameClearedScheduledNavigation`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Event Struct:* [`cdp::proto::page::FrameClearedScheduledNavigationEvent`](struct.FrameClearedScheduledNavigationEvent.html)"]
    pub struct FrameClearedScheduledNavigationEvent<'a> {
        #[serde(rename = "frameId")]
        #[doc = "Id of the frame that has cleared its scheduled navigation."]
        pub frame_id: ::proto::page::FrameId<'a>,
    }
    impl<'a> ::traits::SerializeCdpEvent for FrameClearedScheduledNavigationEvent<'a> {
        fn event_name(&self) -> &str {
            "Page.frameClearedScheduledNavigation"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for FrameClearedScheduledNavigationEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.frameClearedScheduledNavigation" {
                Ok ( < FrameClearedScheduledNavigationEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Event `Page.frameResized`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Event Struct:* [`cdp::proto::page::FrameResizedEvent`](struct.FrameResizedEvent.html)"]
    pub struct FrameResizedEvent;
    impl ::serde::Serialize for FrameResizedEvent {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for FrameResizedEvent {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| FrameResizedEvent)
        }
    }
    impl ::traits::SerializeCdpEvent for FrameResizedEvent {
        fn event_name(&self) -> &str {
            "Page.frameResized"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpEvent<'de> for FrameResizedEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.frameResized" {
                Ok(
                    <FrameResizedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Fired when a JavaScript initiated dialog \\(alert, confirm, prompt, or onbeforeunload\\) is about to open.\n\n# Event `Page.javascriptDialogOpening`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Event Struct:* [`cdp::proto::page::JavascriptDialogOpeningEvent`](struct.JavascriptDialogOpeningEvent.html)"]
    pub struct JavascriptDialogOpeningEvent<'a> {
        #[serde(rename = "message")]
        #[doc = "Message that will be displayed by the dialog."]
        pub message: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "type")]
        #[doc = "Dialog type."]
        pub ty: ::proto::page::DialogType,
    }
    impl<'a> ::traits::SerializeCdpEvent for JavascriptDialogOpeningEvent<'a> {
        fn event_name(&self) -> &str {
            "Page.javascriptDialogOpening"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for JavascriptDialogOpeningEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.javascriptDialogOpening" {
                Ok ( < JavascriptDialogOpeningEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Fired when a JavaScript initiated dialog \\(alert, confirm, prompt, or onbeforeunload\\) has been closed.\n\n# Event `Page.javascriptDialogClosed`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Event Struct:* [`cdp::proto::page::JavascriptDialogClosedEvent`](struct.JavascriptDialogClosedEvent.html)"]
    pub struct JavascriptDialogClosedEvent {
        #[serde(rename = "result")]
        #[doc = "Whether dialog was confirmed."]
        pub result: bool,
    }
    impl ::traits::SerializeCdpEvent for JavascriptDialogClosedEvent {
        fn event_name(&self) -> &str {
            "Page.javascriptDialogClosed"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpEvent<'de> for JavascriptDialogClosedEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.javascriptDialogClosed" {
                Ok ( < JavascriptDialogClosedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Compressed image data requested by the <code>startScreencast</code>.\n\n# Event `Page.screencastFrame`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Event Struct:* [`cdp::proto::page::ScreencastFrameEvent`](struct.ScreencastFrameEvent.html)"]
    pub struct ScreencastFrameEvent<'a> {
        #[serde(rename = "data")]
        #[doc = "Base64-encoded compressed image."]
        pub data: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "metadata")]
        #[doc = "Screencast frame metadata."]
        pub metadata: ::proto::page::ScreencastFrameMetadata,
        #[serde(rename = "sessionId")]
        #[doc = "Frame number."]
        pub session_id: i32,
    }
    impl<'a> ::traits::SerializeCdpEvent for ScreencastFrameEvent<'a> {
        fn event_name(&self) -> &str {
            "Page.screencastFrame"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for ScreencastFrameEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.screencastFrame" {
                Ok(
                    <ScreencastFrameEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Fired when the page with currently enabled screencast was shown or hidden </code>.\n\n# Event `Page.screencastVisibilityChanged`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Event Struct:* [`cdp::proto::page::ScreencastVisibilityChangedEvent`](struct.ScreencastVisibilityChangedEvent.html)"]
    pub struct ScreencastVisibilityChangedEvent {
        #[serde(rename = "visible")]
        #[doc = "True if the page is visible."]
        pub visible: bool,
    }
    impl ::traits::SerializeCdpEvent for ScreencastVisibilityChangedEvent {
        fn event_name(&self) -> &str {
            "Page.screencastVisibilityChanged"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpEvent<'de> for ScreencastVisibilityChangedEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.screencastVisibilityChanged" {
                Ok ( < ScreencastVisibilityChangedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Fired when interstitial page was shown\n\n# Event `Page.interstitialShown`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Event Struct:* [`cdp::proto::page::InterstitialShownEvent`](struct.InterstitialShownEvent.html)"]
    pub struct InterstitialShownEvent;
    impl ::serde::Serialize for InterstitialShownEvent {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for InterstitialShownEvent {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| InterstitialShownEvent)
        }
    }
    impl ::traits::SerializeCdpEvent for InterstitialShownEvent {
        fn event_name(&self) -> &str {
            "Page.interstitialShown"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpEvent<'de> for InterstitialShownEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.interstitialShown" {
                Ok(
                    <InterstitialShownEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Fired when interstitial page was hidden\n\n# Event `Page.interstitialHidden`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Event Struct:* [`cdp::proto::page::InterstitialHiddenEvent`](struct.InterstitialHiddenEvent.html)"]
    pub struct InterstitialHiddenEvent;
    impl ::serde::Serialize for InterstitialHiddenEvent {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for InterstitialHiddenEvent {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| InterstitialHiddenEvent)
        }
    }
    impl ::traits::SerializeCdpEvent for InterstitialHiddenEvent {
        fn event_name(&self) -> &str {
            "Page.interstitialHidden"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpEvent<'de> for InterstitialHiddenEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.interstitialHidden" {
                Ok ( < InterstitialHiddenEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Fired when a navigation is started if navigation throttles are enabled.  The navigation will be deferred until processNavigation is called.\n\n# Event `Page.navigationRequested`\n\n*Domain Module:* [`cdp::proto::page`](index.html)  \n*Event Struct:* [`cdp::proto::page::NavigationRequestedEvent`](struct.NavigationRequestedEvent.html)"]
    pub struct NavigationRequestedEvent<'a> {
        #[serde(rename = "isInMainFrame")]
        #[doc = "Whether the navigation is taking place in the main frame or in a subframe."]
        pub is_in_main_frame: bool,
        #[serde(rename = "isRedirect")]
        #[doc = "Whether the navigation has encountered a server redirect or not."]
        pub is_redirect: bool,
        #[serde(rename = "navigationId")]
        pub navigation_id: i32,
        #[serde(rename = "url")]
        #[doc = "URL of requested navigation."]
        pub url: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpEvent for NavigationRequestedEvent<'a> {
        fn event_name(&self) -> &str {
            "Page.navigationRequested"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for NavigationRequestedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.navigationRequested" {
                Ok ( < NavigationRequestedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "Resource type as it was perceived by the rendering engine."]
    pub enum ResourceType {
        #[serde(rename = "Document")]
        #[doc = "Represented as `\"Document\"`."]
        Document,
        #[serde(rename = "Stylesheet")]
        #[doc = "Represented as `\"Stylesheet\"`."]
        Stylesheet,
        #[serde(rename = "Image")]
        #[doc = "Represented as `\"Image\"`."]
        Image,
        #[serde(rename = "Media")]
        #[doc = "Represented as `\"Media\"`."]
        Media,
        #[serde(rename = "Font")]
        #[doc = "Represented as `\"Font\"`."]
        Font,
        #[serde(rename = "Script")]
        #[doc = "Represented as `\"Script\"`."]
        Script,
        #[serde(rename = "TextTrack")]
        #[doc = "Represented as `\"TextTrack\"`."]
        TextTrack,
        #[serde(rename = "XHR")]
        #[doc = "Represented as `\"XHR\"`."]
        Xhr,
        #[serde(rename = "Fetch")]
        #[doc = "Represented as `\"Fetch\"`."]
        Fetch,
        #[serde(rename = "EventSource")]
        #[doc = "Represented as `\"EventSource\"`."]
        EventSource,
        #[serde(rename = "WebSocket")]
        #[doc = "Represented as `\"WebSocket\"`."]
        WebSocket,
        #[serde(rename = "Manifest")]
        #[doc = "Represented as `\"Manifest\"`."]
        Manifest,
        #[serde(rename = "Other")]
        #[doc = "Represented as `\"Other\"`."]
        Other,
    }
    impl ResourceType {
        pub const ENUM_VALUES: &'static [ResourceType] = &[
            ResourceType::Document,
            ResourceType::Stylesheet,
            ResourceType::Image,
            ResourceType::Media,
            ResourceType::Font,
            ResourceType::Script,
            ResourceType::TextTrack,
            ResourceType::Xhr,
            ResourceType::Fetch,
            ResourceType::EventSource,
            ResourceType::WebSocket,
            ResourceType::Manifest,
            ResourceType::Other,
        ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "Document",
            "Stylesheet",
            "Image",
            "Media",
            "Font",
            "Script",
            "TextTrack",
            "XHR",
            "Fetch",
            "EventSource",
            "WebSocket",
            "Manifest",
            "Other",
        ];
    }
    impl ::std::str::FromStr for ResourceType {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "Document" => Ok(ResourceType::Document),
                "Stylesheet" => Ok(ResourceType::Stylesheet),
                "Image" => Ok(ResourceType::Image),
                "Media" => Ok(ResourceType::Media),
                "Font" => Ok(ResourceType::Font),
                "Script" => Ok(ResourceType::Script),
                "TextTrack" => Ok(ResourceType::TextTrack),
                "XHR" => Ok(ResourceType::Xhr),
                "Fetch" => Ok(ResourceType::Fetch),
                "EventSource" => Ok(ResourceType::EventSource),
                "WebSocket" => Ok(ResourceType::WebSocket),
                "Manifest" => Ok(ResourceType::Manifest),
                "Other" => Ok(ResourceType::Other),
                _ => Err(::proto::ParseEnumError {
                    expected: ResourceType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for ResourceType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    ResourceType::Document => "Document",
                    ResourceType::Stylesheet => "Stylesheet",
                    ResourceType::Image => "Image",
                    ResourceType::Media => "Media",
                    ResourceType::Font => "Font",
                    ResourceType::Script => "Script",
                    ResourceType::TextTrack => "TextTrack",
                    ResourceType::Xhr => "XHR",
                    ResourceType::Fetch => "Fetch",
                    ResourceType::EventSource => "EventSource",
                    ResourceType::WebSocket => "WebSocket",
                    ResourceType::Manifest => "Manifest",
                    ResourceType::Other => "Other",
                }
            )
        }
    }
    #[doc = "Unique frame identifier."]
    pub type FrameId<'a> = ::std::borrow::Cow<'a, str>;
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Information about the Frame on the page."]
    pub struct Frame<'a> {
        #[serde(rename = "id")]
        #[doc = "Frame unique identifier."]
        pub id: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "parentId", skip_serializing_if = "Option::is_none")]
        #[doc = "Parent frame identifier."]
        pub parent_id: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "loaderId")]
        #[doc = "Identifier of the loader associated with this frame."]
        pub loader_id: ::proto::network::LoaderId<'a>,
        #[serde(rename = "name", skip_serializing_if = "Option::is_none")]
        #[doc = "Frame's name as specified in the tag."]
        pub name: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "url")]
        #[doc = "Frame document's URL."]
        pub url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "securityOrigin")]
        #[doc = "Frame document's security origin."]
        pub security_origin: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "mimeType")]
        #[doc = "Frame document's mimeType as determined by the browser."]
        pub mime_type: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "unreachableUrl", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> If the frame failed to load, this contains the URL that could not be loaded."]
        pub unreachable_url: Option<::std::borrow::Cow<'a, str>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Information about the Resource on the page."]
    pub struct FrameResource<'a> {
        #[serde(rename = "url")]
        #[doc = "Resource URL."]
        pub url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "type")]
        #[doc = "Type of this resource."]
        pub ty: ::proto::page::ResourceType,
        #[serde(rename = "mimeType")]
        #[doc = "Resource mimeType as determined by the browser."]
        pub mime_type: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "lastModified", skip_serializing_if = "Option::is_none")]
        #[doc = "last-modified timestamp as reported by server."]
        pub last_modified: Option<::proto::network::TimeSinceEpoch>,
        #[serde(rename = "contentSize", skip_serializing_if = "Option::is_none")]
        #[doc = "Resource content size."]
        pub content_size: Option<f64>,
        #[serde(rename = "failed", skip_serializing_if = "Option::is_none")]
        #[doc = "True if the resource failed to load."]
        pub failed: Option<bool>,
        #[serde(rename = "canceled", skip_serializing_if = "Option::is_none")]
        #[doc = "True if the resource was canceled during loading."]
        pub canceled: Option<bool>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Information about the Frame hierarchy along with their cached resources."]
    pub struct FrameResourceTree<'a> {
        #[serde(rename = "frame")]
        #[doc = "Frame information for this tree item."]
        pub frame: ::proto::page::Frame<'a>,
        #[serde(rename = "childFrames", skip_serializing_if = "Option::is_none")]
        #[doc = "Child frames."]
        pub child_frames: Option<Vec<Box<::proto::page::FrameResourceTree<'a>>>>,
        #[serde(rename = "resources")]
        #[doc = "Information about frame resources."]
        pub resources: Vec<::proto::page::FrameResource<'a>>,
    }
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Unique script identifier."]
    pub type ScriptIdentifier<'a> = ::std::borrow::Cow<'a, str>;
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Transition type."]
    pub enum TransitionType {
        #[serde(rename = "link")]
        #[doc = "Represented as `\"link\"`."]
        Link,
        #[serde(rename = "typed")]
        #[doc = "Represented as `\"typed\"`."]
        Typed,
        #[serde(rename = "auto_bookmark")]
        #[doc = "Represented as `\"auto_bookmark\"`."]
        AutoBookmark,
        #[serde(rename = "auto_subframe")]
        #[doc = "Represented as `\"auto_subframe\"`."]
        AutoSubframe,
        #[serde(rename = "manual_subframe")]
        #[doc = "Represented as `\"manual_subframe\"`."]
        ManualSubframe,
        #[serde(rename = "generated")]
        #[doc = "Represented as `\"generated\"`."]
        Generated,
        #[serde(rename = "auto_toplevel")]
        #[doc = "Represented as `\"auto_toplevel\"`."]
        AutoToplevel,
        #[serde(rename = "form_submit")]
        #[doc = "Represented as `\"form_submit\"`."]
        FormSubmit,
        #[serde(rename = "reload")]
        #[doc = "Represented as `\"reload\"`."]
        Reload,
        #[serde(rename = "keyword")]
        #[doc = "Represented as `\"keyword\"`."]
        Keyword,
        #[serde(rename = "keyword_generated")]
        #[doc = "Represented as `\"keyword_generated\"`."]
        KeywordGenerated,
        #[serde(rename = "other")]
        #[doc = "Represented as `\"other\"`."]
        Other,
    }
    impl TransitionType {
        pub const ENUM_VALUES: &'static [TransitionType] = &[
            TransitionType::Link,
            TransitionType::Typed,
            TransitionType::AutoBookmark,
            TransitionType::AutoSubframe,
            TransitionType::ManualSubframe,
            TransitionType::Generated,
            TransitionType::AutoToplevel,
            TransitionType::FormSubmit,
            TransitionType::Reload,
            TransitionType::Keyword,
            TransitionType::KeywordGenerated,
            TransitionType::Other,
        ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "link",
            "typed",
            "auto_bookmark",
            "auto_subframe",
            "manual_subframe",
            "generated",
            "auto_toplevel",
            "form_submit",
            "reload",
            "keyword",
            "keyword_generated",
            "other",
        ];
    }
    impl ::std::str::FromStr for TransitionType {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "link" => Ok(TransitionType::Link),
                "typed" => Ok(TransitionType::Typed),
                "auto_bookmark" => Ok(TransitionType::AutoBookmark),
                "auto_subframe" => Ok(TransitionType::AutoSubframe),
                "manual_subframe" => Ok(TransitionType::ManualSubframe),
                "generated" => Ok(TransitionType::Generated),
                "auto_toplevel" => Ok(TransitionType::AutoToplevel),
                "form_submit" => Ok(TransitionType::FormSubmit),
                "reload" => Ok(TransitionType::Reload),
                "keyword" => Ok(TransitionType::Keyword),
                "keyword_generated" => Ok(TransitionType::KeywordGenerated),
                "other" => Ok(TransitionType::Other),
                _ => Err(::proto::ParseEnumError {
                    expected: TransitionType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for TransitionType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    TransitionType::Link => "link",
                    TransitionType::Typed => "typed",
                    TransitionType::AutoBookmark => "auto_bookmark",
                    TransitionType::AutoSubframe => "auto_subframe",
                    TransitionType::ManualSubframe => "manual_subframe",
                    TransitionType::Generated => "generated",
                    TransitionType::AutoToplevel => "auto_toplevel",
                    TransitionType::FormSubmit => "form_submit",
                    TransitionType::Reload => "reload",
                    TransitionType::Keyword => "keyword",
                    TransitionType::KeywordGenerated => "keyword_generated",
                    TransitionType::Other => "other",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Navigation history entry."]
    pub struct NavigationEntry<'a> {
        #[serde(rename = "id")]
        #[doc = "Unique id of the navigation history entry."]
        pub id: i32,
        #[serde(rename = "url")]
        #[doc = "URL of the navigation history entry."]
        pub url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "userTypedURL")]
        #[doc = "URL that the user typed in the url bar."]
        pub user_typed_url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "title")]
        #[doc = "Title of the navigation history entry."]
        pub title: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "transitionType")]
        #[doc = "Transition type."]
        pub transition_type: ::proto::page::TransitionType,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Screencast frame metadata."]
    pub struct ScreencastFrameMetadata {
        #[serde(rename = "offsetTop")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Top offset in DIP."]
        pub offset_top: f64,
        #[serde(rename = "pageScaleFactor")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Page scale factor."]
        pub page_scale_factor: f64,
        #[serde(rename = "deviceWidth")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Device screen width in DIP."]
        pub device_width: f64,
        #[serde(rename = "deviceHeight")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Device screen height in DIP."]
        pub device_height: f64,
        #[serde(rename = "scrollOffsetX")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Position of horizontal scroll in CSS pixels."]
        pub scroll_offset_x: f64,
        #[serde(rename = "scrollOffsetY")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Position of vertical scroll in CSS pixels."]
        pub scroll_offset_y: f64,
        #[serde(rename = "timestamp", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Frame swap timestamp."]
        pub timestamp: Option<::proto::network::TimeSinceEpoch>,
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Javascript dialog type."]
    pub enum DialogType {
        #[serde(rename = "alert")]
        #[doc = "Represented as `\"alert\"`."]
        Alert,
        #[serde(rename = "confirm")]
        #[doc = "Represented as `\"confirm\"`."]
        Confirm,
        #[serde(rename = "prompt")]
        #[doc = "Represented as `\"prompt\"`."]
        Prompt,
        #[serde(rename = "beforeunload")]
        #[doc = "Represented as `\"beforeunload\"`."]
        Beforeunload,
    }
    impl DialogType {
        pub const ENUM_VALUES: &'static [DialogType] = &[
            DialogType::Alert,
            DialogType::Confirm,
            DialogType::Prompt,
            DialogType::Beforeunload,
        ];
        pub const STR_VALUES: &'static [&'static str] =
            &["alert", "confirm", "prompt", "beforeunload"];
    }
    impl ::std::str::FromStr for DialogType {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "alert" => Ok(DialogType::Alert),
                "confirm" => Ok(DialogType::Confirm),
                "prompt" => Ok(DialogType::Prompt),
                "beforeunload" => Ok(DialogType::Beforeunload),
                _ => Err(::proto::ParseEnumError {
                    expected: DialogType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for DialogType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    DialogType::Alert => "alert",
                    DialogType::Confirm => "confirm",
                    DialogType::Prompt => "prompt",
                    DialogType::Beforeunload => "beforeunload",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Error while paring app manifest."]
    pub struct AppManifestError<'a> {
        #[serde(rename = "message")]
        #[doc = "Error message."]
        pub message: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "critical")]
        #[doc = "If criticial, this is a non-recoverable parse error."]
        pub critical: i32,
        #[serde(rename = "line")]
        #[doc = "Error line."]
        pub line: i32,
        #[serde(rename = "column")]
        #[doc = "Error column."]
        pub column: i32,
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Proceed: allow the navigation; Cancel: cancel the navigation; CancelAndIgnore: cancels the navigation and makes the requester of the navigation acts like the request was never made."]
    pub enum NavigationResponse {
        #[serde(rename = "Proceed")]
        #[doc = "Represented as `\"Proceed\"`."]
        Proceed,
        #[serde(rename = "Cancel")]
        #[doc = "Represented as `\"Cancel\"`."]
        Cancel,
        #[serde(rename = "CancelAndIgnore")]
        #[doc = "Represented as `\"CancelAndIgnore\"`."]
        CancelAndIgnore,
    }
    impl NavigationResponse {
        pub const ENUM_VALUES: &'static [NavigationResponse] = &[
            NavigationResponse::Proceed,
            NavigationResponse::Cancel,
            NavigationResponse::CancelAndIgnore,
        ];
        pub const STR_VALUES: &'static [&'static str] = &["Proceed", "Cancel", "CancelAndIgnore"];
    }
    impl ::std::str::FromStr for NavigationResponse {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "Proceed" => Ok(NavigationResponse::Proceed),
                "Cancel" => Ok(NavigationResponse::Cancel),
                "CancelAndIgnore" => Ok(NavigationResponse::CancelAndIgnore),
                _ => Err(::proto::ParseEnumError {
                    expected: NavigationResponse::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for NavigationResponse {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    NavigationResponse::Proceed => "Proceed",
                    NavigationResponse::Cancel => "Cancel",
                    NavigationResponse::CancelAndIgnore => "CancelAndIgnore",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Layout viewport position and dimensions."]
    pub struct LayoutViewport {
        #[serde(rename = "pageX")]
        #[doc = "Horizontal offset relative to the document \\(CSS pixels\\)."]
        pub page_x: i32,
        #[serde(rename = "pageY")]
        #[doc = "Vertical offset relative to the document \\(CSS pixels\\)."]
        pub page_y: i32,
        #[serde(rename = "clientWidth")]
        #[doc = "Width \\(CSS pixels\\), excludes scrollbar if present."]
        pub client_width: i32,
        #[serde(rename = "clientHeight")]
        #[doc = "Height \\(CSS pixels\\), excludes scrollbar if present."]
        pub client_height: i32,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Visual viewport position, dimensions, and scale."]
    pub struct VisualViewport {
        #[serde(rename = "offsetX")]
        #[doc = "Horizontal offset relative to the layout viewport \\(CSS pixels\\)."]
        pub offset_x: f64,
        #[serde(rename = "offsetY")]
        #[doc = "Vertical offset relative to the layout viewport \\(CSS pixels\\)."]
        pub offset_y: f64,
        #[serde(rename = "pageX")]
        #[doc = "Horizontal offset relative to the document \\(CSS pixels\\)."]
        pub page_x: f64,
        #[serde(rename = "pageY")]
        #[doc = "Vertical offset relative to the document \\(CSS pixels\\)."]
        pub page_y: f64,
        #[serde(rename = "clientWidth")]
        #[doc = "Width \\(CSS pixels\\), excludes scrollbar if present."]
        pub client_width: f64,
        #[serde(rename = "clientHeight")]
        #[doc = "Height \\(CSS pixels\\), excludes scrollbar if present."]
        pub client_height: f64,
        #[serde(rename = "scale")]
        #[doc = "Scale relative to the ideal viewport \\(size at width=device-width\\)."]
        pub scale: f64,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Viewport for capturing screenshot."]
    pub struct Viewport {
        #[serde(rename = "x")]
        #[doc = "X offset in CSS pixels."]
        pub x: f64,
        #[serde(rename = "y")]
        #[doc = "Y offset in CSS pixels"]
        pub y: f64,
        #[serde(rename = "width")]
        #[doc = "Rectangle width in CSS pixels"]
        pub width: f64,
        #[serde(rename = "height")]
        #[doc = "Rectangle height in CSS pixels"]
        pub height: f64,
        #[serde(rename = "scale")]
        #[doc = "Page scale factor."]
        pub scale: f64,
    }
}
#[doc = "<span class=\"stab unstable\">[Experimental]</span> This domain provides various functionality related to drawing atop the inspected page.\n\n# Overlay\n\n## Commands\n\n- [`Overlay.enable`](struct.EnableCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Enables domain notifications.\n- [`Overlay.disable`](struct.DisableCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Disables domain notifications.\n- [`Overlay.setShowPaintRects`](struct.SetShowPaintRectsCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Requests that backend shows paint rectangles\n- [`Overlay.setShowDebugBorders`](struct.SetShowDebugBordersCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Requests that backend shows debug borders on layers\n- [`Overlay.setShowFPSCounter`](struct.SetShowFpsCounterCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Requests that backend shows the FPS counter\n- [`Overlay.setShowScrollBottleneckRects`](struct.SetShowScrollBottleneckRectsCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Requests that backend shows scroll bottleneck rects\n- [`Overlay.setShowViewportSizeOnResize`](struct.SetShowViewportSizeOnResizeCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Paints viewport size upon main frame resize.\n- [`Overlay.setPausedInDebuggerMessage`](struct.SetPausedInDebuggerMessageCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`Overlay.setSuspended`](struct.SetSuspendedCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`Overlay.setInspectMode`](struct.SetInspectModeCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Enters the 'inspect' mode. In this mode, elements that user is hovering over are highlighted. Backend then generates 'inspectNodeRequested' event upon element selection.\n- [`Overlay.highlightRect`](struct.HighlightRectCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Highlights given rectangle. Coordinates are absolute with respect to the main frame viewport.\n- [`Overlay.highlightQuad`](struct.HighlightQuadCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Highlights given quad. Coordinates are absolute with respect to the main frame viewport.\n- [`Overlay.highlightNode`](struct.HighlightNodeCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Highlights DOM node with given id or with the given JavaScript object wrapper. Either nodeId or objectId must be specified.\n- [`Overlay.highlightFrame`](struct.HighlightFrameCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Highlights owner element of the frame with given id.\n- [`Overlay.hideHighlight`](struct.HideHighlightCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Hides any highlight.\n- [`Overlay.getHighlightObjectForTest`](struct.GetHighlightObjectForTestCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  For testing.\n\n## Events\n\n- [`Overlay.nodeHighlightRequested`](struct.NodeHighlightRequestedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Fired when the node should be highlighted. This happens after call to <code>setInspectMode</code>.\n- [`Overlay.inspectNodeRequested`](struct.InspectNodeRequestedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Fired when the node should be inspected. This happens after call to <code>setInspectMode</code> or when user manually inspects an element.\n\n##Types\n\n- [`HighlightConfig`](struct.HighlightConfig.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Configuration data for the highlighting of page elements.\n- [`InspectMode`](enum.InspectMode.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n"]
pub mod overlay {
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables domain notifications.\n\n# Command `Overlay.enable`\n\n*Domain Module:* [`cdp::proto::overlay`](index.html)  \n*Command Struct:* [`cdp::proto::overlay::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::proto::overlay::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableCommand;
    impl ::serde::Serialize for EnableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for EnableCommand {
        fn command_name(&self) -> &str {
            "Overlay.enable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for EnableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Overlay.enable" {
                Ok(
                    <EnableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables domain notifications.\n\n# Command `Overlay.enable`\n\n*Domain Module:* [`cdp::proto::overlay`](index.html)  \n*Command Struct:* [`cdp::proto::overlay::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::proto::overlay::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableResponse;
    impl ::serde::Serialize for EnableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for EnableCommand {
        type Response = EnableResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for EnableResponse {
        type Command = EnableCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Disables domain notifications.\n\n# Command `Overlay.disable`\n\n*Domain Module:* [`cdp::proto::overlay`](index.html)  \n*Command Struct:* [`cdp::proto::overlay::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::proto::overlay::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableCommand;
    impl ::serde::Serialize for DisableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for DisableCommand {
        fn command_name(&self) -> &str {
            "Overlay.disable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for DisableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Overlay.disable" {
                Ok(
                    <DisableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Disables domain notifications.\n\n# Command `Overlay.disable`\n\n*Domain Module:* [`cdp::proto::overlay`](index.html)  \n*Command Struct:* [`cdp::proto::overlay::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::proto::overlay::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableResponse;
    impl ::serde::Serialize for DisableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for DisableCommand {
        type Response = DisableResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for DisableResponse {
        type Command = DisableCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Requests that backend shows paint rectangles\n\n# Command `Overlay.setShowPaintRects`\n\n*Domain Module:* [`cdp::proto::overlay`](index.html)  \n*Command Struct:* [`cdp::proto::overlay::SetShowPaintRectsCommand`](struct.SetShowPaintRectsCommand.html)  \n*Response Struct:* [`cdp::proto::overlay::SetShowPaintRectsResponse`](struct.SetShowPaintRectsResponse.html)"]
    pub struct SetShowPaintRectsCommand {
        #[serde(rename = "result")]
        #[doc = "True for showing paint rectangles"]
        pub result: bool,
    }
    impl ::traits::SerializeCdpCommand for SetShowPaintRectsCommand {
        fn command_name(&self) -> &str {
            "Overlay.setShowPaintRects"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for SetShowPaintRectsCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Overlay.setShowPaintRects" {
                Ok ( < SetShowPaintRectsCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Requests that backend shows paint rectangles\n\n# Command `Overlay.setShowPaintRects`\n\n*Domain Module:* [`cdp::proto::overlay`](index.html)  \n*Command Struct:* [`cdp::proto::overlay::SetShowPaintRectsCommand`](struct.SetShowPaintRectsCommand.html)  \n*Response Struct:* [`cdp::proto::overlay::SetShowPaintRectsResponse`](struct.SetShowPaintRectsResponse.html)"]
    pub struct SetShowPaintRectsResponse;
    impl ::serde::Serialize for SetShowPaintRectsResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetShowPaintRectsResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetShowPaintRectsResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetShowPaintRectsCommand {
        type Response = SetShowPaintRectsResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetShowPaintRectsResponse {
        type Command = SetShowPaintRectsCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Requests that backend shows debug borders on layers\n\n# Command `Overlay.setShowDebugBorders`\n\n*Domain Module:* [`cdp::proto::overlay`](index.html)  \n*Command Struct:* [`cdp::proto::overlay::SetShowDebugBordersCommand`](struct.SetShowDebugBordersCommand.html)  \n*Response Struct:* [`cdp::proto::overlay::SetShowDebugBordersResponse`](struct.SetShowDebugBordersResponse.html)"]
    pub struct SetShowDebugBordersCommand {
        #[serde(rename = "show")]
        #[doc = "True for showing debug borders"]
        pub show: bool,
    }
    impl ::traits::SerializeCdpCommand for SetShowDebugBordersCommand {
        fn command_name(&self) -> &str {
            "Overlay.setShowDebugBorders"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for SetShowDebugBordersCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Overlay.setShowDebugBorders" {
                Ok ( < SetShowDebugBordersCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Requests that backend shows debug borders on layers\n\n# Command `Overlay.setShowDebugBorders`\n\n*Domain Module:* [`cdp::proto::overlay`](index.html)  \n*Command Struct:* [`cdp::proto::overlay::SetShowDebugBordersCommand`](struct.SetShowDebugBordersCommand.html)  \n*Response Struct:* [`cdp::proto::overlay::SetShowDebugBordersResponse`](struct.SetShowDebugBordersResponse.html)"]
    pub struct SetShowDebugBordersResponse;
    impl ::serde::Serialize for SetShowDebugBordersResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetShowDebugBordersResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetShowDebugBordersResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetShowDebugBordersCommand {
        type Response = SetShowDebugBordersResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetShowDebugBordersResponse {
        type Command = SetShowDebugBordersCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Requests that backend shows the FPS counter\n\n# Command `Overlay.setShowFPSCounter`\n\n*Domain Module:* [`cdp::proto::overlay`](index.html)  \n*Command Struct:* [`cdp::proto::overlay::SetShowFpsCounterCommand`](struct.SetShowFpsCounterCommand.html)  \n*Response Struct:* [`cdp::proto::overlay::SetShowFpsCounterResponse`](struct.SetShowFpsCounterResponse.html)"]
    pub struct SetShowFpsCounterCommand {
        #[serde(rename = "show")]
        #[doc = "True for showing the FPS counter"]
        pub show: bool,
    }
    impl ::traits::SerializeCdpCommand for SetShowFpsCounterCommand {
        fn command_name(&self) -> &str {
            "Overlay.setShowFPSCounter"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for SetShowFpsCounterCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Overlay.setShowFPSCounter" {
                Ok ( < SetShowFpsCounterCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Requests that backend shows the FPS counter\n\n# Command `Overlay.setShowFPSCounter`\n\n*Domain Module:* [`cdp::proto::overlay`](index.html)  \n*Command Struct:* [`cdp::proto::overlay::SetShowFpsCounterCommand`](struct.SetShowFpsCounterCommand.html)  \n*Response Struct:* [`cdp::proto::overlay::SetShowFpsCounterResponse`](struct.SetShowFpsCounterResponse.html)"]
    pub struct SetShowFpsCounterResponse;
    impl ::serde::Serialize for SetShowFpsCounterResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetShowFpsCounterResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetShowFpsCounterResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetShowFpsCounterCommand {
        type Response = SetShowFpsCounterResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetShowFpsCounterResponse {
        type Command = SetShowFpsCounterCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Requests that backend shows scroll bottleneck rects\n\n# Command `Overlay.setShowScrollBottleneckRects`\n\n*Domain Module:* [`cdp::proto::overlay`](index.html)  \n*Command Struct:* [`cdp::proto::overlay::SetShowScrollBottleneckRectsCommand`](struct.SetShowScrollBottleneckRectsCommand.html)  \n*Response Struct:* [`cdp::proto::overlay::SetShowScrollBottleneckRectsResponse`](struct.SetShowScrollBottleneckRectsResponse.html)"]
    pub struct SetShowScrollBottleneckRectsCommand {
        #[serde(rename = "show")]
        #[doc = "True for showing scroll bottleneck rects"]
        pub show: bool,
    }
    impl ::traits::SerializeCdpCommand for SetShowScrollBottleneckRectsCommand {
        fn command_name(&self) -> &str {
            "Overlay.setShowScrollBottleneckRects"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for SetShowScrollBottleneckRectsCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Overlay.setShowScrollBottleneckRects" {
                Ok ( < SetShowScrollBottleneckRectsCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Requests that backend shows scroll bottleneck rects\n\n# Command `Overlay.setShowScrollBottleneckRects`\n\n*Domain Module:* [`cdp::proto::overlay`](index.html)  \n*Command Struct:* [`cdp::proto::overlay::SetShowScrollBottleneckRectsCommand`](struct.SetShowScrollBottleneckRectsCommand.html)  \n*Response Struct:* [`cdp::proto::overlay::SetShowScrollBottleneckRectsResponse`](struct.SetShowScrollBottleneckRectsResponse.html)"]
    pub struct SetShowScrollBottleneckRectsResponse;
    impl ::serde::Serialize for SetShowScrollBottleneckRectsResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetShowScrollBottleneckRectsResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetShowScrollBottleneckRectsResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetShowScrollBottleneckRectsCommand {
        type Response = SetShowScrollBottleneckRectsResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetShowScrollBottleneckRectsResponse {
        type Command = SetShowScrollBottleneckRectsCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Paints viewport size upon main frame resize.\n\n# Command `Overlay.setShowViewportSizeOnResize`\n\n*Domain Module:* [`cdp::proto::overlay`](index.html)  \n*Command Struct:* [`cdp::proto::overlay::SetShowViewportSizeOnResizeCommand`](struct.SetShowViewportSizeOnResizeCommand.html)  \n*Response Struct:* [`cdp::proto::overlay::SetShowViewportSizeOnResizeResponse`](struct.SetShowViewportSizeOnResizeResponse.html)"]
    pub struct SetShowViewportSizeOnResizeCommand {
        #[serde(rename = "show")]
        #[doc = "Whether to paint size or not."]
        pub show: bool,
    }
    impl ::traits::SerializeCdpCommand for SetShowViewportSizeOnResizeCommand {
        fn command_name(&self) -> &str {
            "Overlay.setShowViewportSizeOnResize"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for SetShowViewportSizeOnResizeCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Overlay.setShowViewportSizeOnResize" {
                Ok ( < SetShowViewportSizeOnResizeCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Paints viewport size upon main frame resize.\n\n# Command `Overlay.setShowViewportSizeOnResize`\n\n*Domain Module:* [`cdp::proto::overlay`](index.html)  \n*Command Struct:* [`cdp::proto::overlay::SetShowViewportSizeOnResizeCommand`](struct.SetShowViewportSizeOnResizeCommand.html)  \n*Response Struct:* [`cdp::proto::overlay::SetShowViewportSizeOnResizeResponse`](struct.SetShowViewportSizeOnResizeResponse.html)"]
    pub struct SetShowViewportSizeOnResizeResponse;
    impl ::serde::Serialize for SetShowViewportSizeOnResizeResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetShowViewportSizeOnResizeResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetShowViewportSizeOnResizeResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetShowViewportSizeOnResizeCommand {
        type Response = SetShowViewportSizeOnResizeResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetShowViewportSizeOnResizeResponse {
        type Command = SetShowViewportSizeOnResizeCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `Overlay.setPausedInDebuggerMessage`\n\n*Domain Module:* [`cdp::proto::overlay`](index.html)  \n*Command Struct:* [`cdp::proto::overlay::SetPausedInDebuggerMessageCommand`](struct.SetPausedInDebuggerMessageCommand.html)  \n*Response Struct:* [`cdp::proto::overlay::SetPausedInDebuggerMessageResponse`](struct.SetPausedInDebuggerMessageResponse.html)"]
    pub struct SetPausedInDebuggerMessageCommand<'a> {
        #[serde(rename = "message", skip_serializing_if = "Option::is_none")]
        #[doc = "The message to display, also triggers resume and step over controls."]
        pub message: Option<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::traits::SerializeCdpCommand for SetPausedInDebuggerMessageCommand<'a> {
        fn command_name(&self) -> &str {
            "Overlay.setPausedInDebuggerMessage"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for SetPausedInDebuggerMessageCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Overlay.setPausedInDebuggerMessage" {
                Ok ( < SetPausedInDebuggerMessageCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `Overlay.setPausedInDebuggerMessage`\n\n*Domain Module:* [`cdp::proto::overlay`](index.html)  \n*Command Struct:* [`cdp::proto::overlay::SetPausedInDebuggerMessageCommand`](struct.SetPausedInDebuggerMessageCommand.html)  \n*Response Struct:* [`cdp::proto::overlay::SetPausedInDebuggerMessageResponse`](struct.SetPausedInDebuggerMessageResponse.html)"]
    pub struct SetPausedInDebuggerMessageResponse;
    impl ::serde::Serialize for SetPausedInDebuggerMessageResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetPausedInDebuggerMessageResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetPausedInDebuggerMessageResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetPausedInDebuggerMessageCommand<'a> {
        type Response = SetPausedInDebuggerMessageResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetPausedInDebuggerMessageResponse {
        type Command = SetPausedInDebuggerMessageCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `Overlay.setSuspended`\n\n*Domain Module:* [`cdp::proto::overlay`](index.html)  \n*Command Struct:* [`cdp::proto::overlay::SetSuspendedCommand`](struct.SetSuspendedCommand.html)  \n*Response Struct:* [`cdp::proto::overlay::SetSuspendedResponse`](struct.SetSuspendedResponse.html)"]
    pub struct SetSuspendedCommand {
        #[serde(rename = "suspended")]
        #[doc = "Whether overlay should be suspended and not consume any resources until resumed."]
        pub suspended: bool,
    }
    impl ::traits::SerializeCdpCommand for SetSuspendedCommand {
        fn command_name(&self) -> &str {
            "Overlay.setSuspended"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for SetSuspendedCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Overlay.setSuspended" {
                Ok(
                    <SetSuspendedCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `Overlay.setSuspended`\n\n*Domain Module:* [`cdp::proto::overlay`](index.html)  \n*Command Struct:* [`cdp::proto::overlay::SetSuspendedCommand`](struct.SetSuspendedCommand.html)  \n*Response Struct:* [`cdp::proto::overlay::SetSuspendedResponse`](struct.SetSuspendedResponse.html)"]
    pub struct SetSuspendedResponse;
    impl ::serde::Serialize for SetSuspendedResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetSuspendedResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetSuspendedResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetSuspendedCommand {
        type Response = SetSuspendedResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetSuspendedResponse {
        type Command = SetSuspendedCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enters the 'inspect' mode. In this mode, elements that user is hovering over are highlighted. Backend then generates 'inspectNodeRequested' event upon element selection.\n\n# Command `Overlay.setInspectMode`\n\n*Domain Module:* [`cdp::proto::overlay`](index.html)  \n*Command Struct:* [`cdp::proto::overlay::SetInspectModeCommand`](struct.SetInspectModeCommand.html)  \n*Response Struct:* [`cdp::proto::overlay::SetInspectModeResponse`](struct.SetInspectModeResponse.html)"]
    pub struct SetInspectModeCommand<'a> {
        #[serde(rename = "mode")]
        #[doc = "Set an inspection mode."]
        pub mode: ::proto::overlay::InspectMode,
        #[serde(rename = "highlightConfig", skip_serializing_if = "Option::is_none")]
        #[doc = "A descriptor for the highlight appearance of hovered-over nodes. May be omitted if <code>enabled == false</code>."]
        pub highlight_config: Option<::proto::overlay::HighlightConfig<'a>>,
    }
    impl<'a> ::traits::SerializeCdpCommand for SetInspectModeCommand<'a> {
        fn command_name(&self) -> &str {
            "Overlay.setInspectMode"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for SetInspectModeCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Overlay.setInspectMode" {
                Ok(
                    <SetInspectModeCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enters the 'inspect' mode. In this mode, elements that user is hovering over are highlighted. Backend then generates 'inspectNodeRequested' event upon element selection.\n\n# Command `Overlay.setInspectMode`\n\n*Domain Module:* [`cdp::proto::overlay`](index.html)  \n*Command Struct:* [`cdp::proto::overlay::SetInspectModeCommand`](struct.SetInspectModeCommand.html)  \n*Response Struct:* [`cdp::proto::overlay::SetInspectModeResponse`](struct.SetInspectModeResponse.html)"]
    pub struct SetInspectModeResponse;
    impl ::serde::Serialize for SetInspectModeResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetInspectModeResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetInspectModeResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetInspectModeCommand<'a> {
        type Response = SetInspectModeResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetInspectModeResponse {
        type Command = SetInspectModeCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Highlights given rectangle. Coordinates are absolute with respect to the main frame viewport.\n\n# Command `Overlay.highlightRect`\n\n*Domain Module:* [`cdp::proto::overlay`](index.html)  \n*Command Struct:* [`cdp::proto::overlay::HighlightRectCommand`](struct.HighlightRectCommand.html)  \n*Response Struct:* [`cdp::proto::overlay::HighlightRectResponse`](struct.HighlightRectResponse.html)"]
    pub struct HighlightRectCommand {
        #[serde(rename = "x")]
        #[doc = "X coordinate"]
        pub x: i32,
        #[serde(rename = "y")]
        #[doc = "Y coordinate"]
        pub y: i32,
        #[serde(rename = "width")]
        #[doc = "Rectangle width"]
        pub width: i32,
        #[serde(rename = "height")]
        #[doc = "Rectangle height"]
        pub height: i32,
        #[serde(rename = "color", skip_serializing_if = "Option::is_none")]
        #[doc = "The highlight fill color \\(default: transparent\\)."]
        pub color: Option<::proto::dom::Rgba>,
        #[serde(rename = "outlineColor", skip_serializing_if = "Option::is_none")]
        #[doc = "The highlight outline color \\(default: transparent\\)."]
        pub outline_color: Option<::proto::dom::Rgba>,
    }
    impl ::traits::SerializeCdpCommand for HighlightRectCommand {
        fn command_name(&self) -> &str {
            "Overlay.highlightRect"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for HighlightRectCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Overlay.highlightRect" {
                Ok(
                    <HighlightRectCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Highlights given rectangle. Coordinates are absolute with respect to the main frame viewport.\n\n# Command `Overlay.highlightRect`\n\n*Domain Module:* [`cdp::proto::overlay`](index.html)  \n*Command Struct:* [`cdp::proto::overlay::HighlightRectCommand`](struct.HighlightRectCommand.html)  \n*Response Struct:* [`cdp::proto::overlay::HighlightRectResponse`](struct.HighlightRectResponse.html)"]
    pub struct HighlightRectResponse;
    impl ::serde::Serialize for HighlightRectResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for HighlightRectResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| HighlightRectResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for HighlightRectCommand {
        type Response = HighlightRectResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for HighlightRectResponse {
        type Command = HighlightRectCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Highlights given quad. Coordinates are absolute with respect to the main frame viewport.\n\n# Command `Overlay.highlightQuad`\n\n*Domain Module:* [`cdp::proto::overlay`](index.html)  \n*Command Struct:* [`cdp::proto::overlay::HighlightQuadCommand`](struct.HighlightQuadCommand.html)  \n*Response Struct:* [`cdp::proto::overlay::HighlightQuadResponse`](struct.HighlightQuadResponse.html)"]
    pub struct HighlightQuadCommand {
        #[serde(rename = "quad")]
        #[doc = "Quad to highlight"]
        pub quad: ::proto::dom::Quad,
        #[serde(rename = "color", skip_serializing_if = "Option::is_none")]
        #[doc = "The highlight fill color \\(default: transparent\\)."]
        pub color: Option<::proto::dom::Rgba>,
        #[serde(rename = "outlineColor", skip_serializing_if = "Option::is_none")]
        #[doc = "The highlight outline color \\(default: transparent\\)."]
        pub outline_color: Option<::proto::dom::Rgba>,
    }
    impl ::traits::SerializeCdpCommand for HighlightQuadCommand {
        fn command_name(&self) -> &str {
            "Overlay.highlightQuad"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for HighlightQuadCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Overlay.highlightQuad" {
                Ok(
                    <HighlightQuadCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Highlights given quad. Coordinates are absolute with respect to the main frame viewport.\n\n# Command `Overlay.highlightQuad`\n\n*Domain Module:* [`cdp::proto::overlay`](index.html)  \n*Command Struct:* [`cdp::proto::overlay::HighlightQuadCommand`](struct.HighlightQuadCommand.html)  \n*Response Struct:* [`cdp::proto::overlay::HighlightQuadResponse`](struct.HighlightQuadResponse.html)"]
    pub struct HighlightQuadResponse;
    impl ::serde::Serialize for HighlightQuadResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for HighlightQuadResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| HighlightQuadResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for HighlightQuadCommand {
        type Response = HighlightQuadResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for HighlightQuadResponse {
        type Command = HighlightQuadCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Highlights DOM node with given id or with the given JavaScript object wrapper. Either nodeId or objectId must be specified.\n\n# Command `Overlay.highlightNode`\n\n*Domain Module:* [`cdp::proto::overlay`](index.html)  \n*Command Struct:* [`cdp::proto::overlay::HighlightNodeCommand`](struct.HighlightNodeCommand.html)  \n*Response Struct:* [`cdp::proto::overlay::HighlightNodeResponse`](struct.HighlightNodeResponse.html)"]
    pub struct HighlightNodeCommand<'a> {
        #[serde(rename = "highlightConfig")]
        #[doc = "A descriptor for the highlight appearance."]
        pub highlight_config: ::proto::overlay::HighlightConfig<'a>,
        #[serde(rename = "nodeId", skip_serializing_if = "Option::is_none")]
        #[doc = "Identifier of the node to highlight."]
        pub node_id: Option<::proto::dom::NodeId>,
        #[serde(rename = "backendNodeId", skip_serializing_if = "Option::is_none")]
        #[doc = "Identifier of the backend node to highlight."]
        pub backend_node_id: Option<::proto::dom::BackendNodeId>,
        #[serde(rename = "objectId", skip_serializing_if = "Option::is_none")]
        #[doc = "JavaScript object id of the node to be highlighted."]
        pub object_id: Option<::proto::runtime::RemoteObjectId<'a>>,
    }
    impl<'a> ::traits::SerializeCdpCommand for HighlightNodeCommand<'a> {
        fn command_name(&self) -> &str {
            "Overlay.highlightNode"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for HighlightNodeCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Overlay.highlightNode" {
                Ok(
                    <HighlightNodeCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Highlights DOM node with given id or with the given JavaScript object wrapper. Either nodeId or objectId must be specified.\n\n# Command `Overlay.highlightNode`\n\n*Domain Module:* [`cdp::proto::overlay`](index.html)  \n*Command Struct:* [`cdp::proto::overlay::HighlightNodeCommand`](struct.HighlightNodeCommand.html)  \n*Response Struct:* [`cdp::proto::overlay::HighlightNodeResponse`](struct.HighlightNodeResponse.html)"]
    pub struct HighlightNodeResponse;
    impl ::serde::Serialize for HighlightNodeResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for HighlightNodeResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| HighlightNodeResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for HighlightNodeCommand<'a> {
        type Response = HighlightNodeResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for HighlightNodeResponse {
        type Command = HighlightNodeCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Highlights owner element of the frame with given id.\n\n# Command `Overlay.highlightFrame`\n\n*Domain Module:* [`cdp::proto::overlay`](index.html)  \n*Command Struct:* [`cdp::proto::overlay::HighlightFrameCommand`](struct.HighlightFrameCommand.html)  \n*Response Struct:* [`cdp::proto::overlay::HighlightFrameResponse`](struct.HighlightFrameResponse.html)"]
    pub struct HighlightFrameCommand<'a> {
        #[serde(rename = "frameId")]
        #[doc = "Identifier of the frame to highlight."]
        pub frame_id: ::proto::page::FrameId<'a>,
        #[serde(rename = "contentColor", skip_serializing_if = "Option::is_none")]
        #[doc = "The content box highlight fill color \\(default: transparent\\)."]
        pub content_color: Option<::proto::dom::Rgba>,
        #[serde(rename = "contentOutlineColor", skip_serializing_if = "Option::is_none")]
        #[doc = "The content box highlight outline color \\(default: transparent\\)."]
        pub content_outline_color: Option<::proto::dom::Rgba>,
    }
    impl<'a> ::traits::SerializeCdpCommand for HighlightFrameCommand<'a> {
        fn command_name(&self) -> &str {
            "Overlay.highlightFrame"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for HighlightFrameCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Overlay.highlightFrame" {
                Ok(
                    <HighlightFrameCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Highlights owner element of the frame with given id.\n\n# Command `Overlay.highlightFrame`\n\n*Domain Module:* [`cdp::proto::overlay`](index.html)  \n*Command Struct:* [`cdp::proto::overlay::HighlightFrameCommand`](struct.HighlightFrameCommand.html)  \n*Response Struct:* [`cdp::proto::overlay::HighlightFrameResponse`](struct.HighlightFrameResponse.html)"]
    pub struct HighlightFrameResponse;
    impl ::serde::Serialize for HighlightFrameResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for HighlightFrameResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| HighlightFrameResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for HighlightFrameCommand<'a> {
        type Response = HighlightFrameResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for HighlightFrameResponse {
        type Command = HighlightFrameCommand<'a>;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Hides any highlight.\n\n# Command `Overlay.hideHighlight`\n\n*Domain Module:* [`cdp::proto::overlay`](index.html)  \n*Command Struct:* [`cdp::proto::overlay::HideHighlightCommand`](struct.HideHighlightCommand.html)  \n*Response Struct:* [`cdp::proto::overlay::HideHighlightResponse`](struct.HideHighlightResponse.html)"]
    pub struct HideHighlightCommand;
    impl ::serde::Serialize for HideHighlightCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for HideHighlightCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| HideHighlightCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for HideHighlightCommand {
        fn command_name(&self) -> &str {
            "Overlay.hideHighlight"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for HideHighlightCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Overlay.hideHighlight" {
                Ok(
                    <HideHighlightCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Hides any highlight.\n\n# Command `Overlay.hideHighlight`\n\n*Domain Module:* [`cdp::proto::overlay`](index.html)  \n*Command Struct:* [`cdp::proto::overlay::HideHighlightCommand`](struct.HideHighlightCommand.html)  \n*Response Struct:* [`cdp::proto::overlay::HideHighlightResponse`](struct.HideHighlightResponse.html)"]
    pub struct HideHighlightResponse;
    impl ::serde::Serialize for HideHighlightResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for HideHighlightResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| HideHighlightResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for HideHighlightCommand {
        type Response = HideHighlightResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for HideHighlightResponse {
        type Command = HideHighlightCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> For testing.\n\n# Command `Overlay.getHighlightObjectForTest`\n\n*Domain Module:* [`cdp::proto::overlay`](index.html)  \n*Command Struct:* [`cdp::proto::overlay::GetHighlightObjectForTestCommand`](struct.GetHighlightObjectForTestCommand.html)  \n*Response Struct:* [`cdp::proto::overlay::GetHighlightObjectForTestResponse`](struct.GetHighlightObjectForTestResponse.html)"]
    pub struct GetHighlightObjectForTestCommand {
        #[serde(rename = "nodeId")]
        #[doc = "Id of the node to get highlight object for."]
        pub node_id: ::proto::dom::NodeId,
    }
    impl ::traits::SerializeCdpCommand for GetHighlightObjectForTestCommand {
        fn command_name(&self) -> &str {
            "Overlay.getHighlightObjectForTest"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for GetHighlightObjectForTestCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Overlay.getHighlightObjectForTest" {
                Ok ( < GetHighlightObjectForTestCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> For testing.\n\n# Command `Overlay.getHighlightObjectForTest`\n\n*Domain Module:* [`cdp::proto::overlay`](index.html)  \n*Command Struct:* [`cdp::proto::overlay::GetHighlightObjectForTestCommand`](struct.GetHighlightObjectForTestCommand.html)  \n*Response Struct:* [`cdp::proto::overlay::GetHighlightObjectForTestResponse`](struct.GetHighlightObjectForTestResponse.html)"]
    pub struct GetHighlightObjectForTestResponse {
        #[serde(rename = "highlight")]
        #[doc = "Highlight data for the node."]
        pub highlight: ::proto::Empty,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for GetHighlightObjectForTestCommand {
        type Response = GetHighlightObjectForTestResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for GetHighlightObjectForTestResponse {
        type Command = GetHighlightObjectForTestCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Fired when the node should be highlighted. This happens after call to <code>setInspectMode</code>.\n\n# Event `Overlay.nodeHighlightRequested`\n\n*Domain Module:* [`cdp::proto::overlay`](index.html)  \n*Event Struct:* [`cdp::proto::overlay::NodeHighlightRequestedEvent`](struct.NodeHighlightRequestedEvent.html)"]
    pub struct NodeHighlightRequestedEvent {
        #[serde(rename = "nodeId")]
        pub node_id: ::proto::dom::NodeId,
    }
    impl ::traits::SerializeCdpEvent for NodeHighlightRequestedEvent {
        fn event_name(&self) -> &str {
            "Overlay.nodeHighlightRequested"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpEvent<'de> for NodeHighlightRequestedEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Overlay.nodeHighlightRequested" {
                Ok ( < NodeHighlightRequestedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Fired when the node should be inspected. This happens after call to <code>setInspectMode</code> or when user manually inspects an element.\n\n# Event `Overlay.inspectNodeRequested`\n\n*Domain Module:* [`cdp::proto::overlay`](index.html)  \n*Event Struct:* [`cdp::proto::overlay::InspectNodeRequestedEvent`](struct.InspectNodeRequestedEvent.html)"]
    pub struct InspectNodeRequestedEvent {
        #[serde(rename = "backendNodeId")]
        #[doc = "Id of the node to inspect."]
        pub backend_node_id: ::proto::dom::BackendNodeId,
    }
    impl ::traits::SerializeCdpEvent for InspectNodeRequestedEvent {
        fn event_name(&self) -> &str {
            "Overlay.inspectNodeRequested"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpEvent<'de> for InspectNodeRequestedEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Overlay.inspectNodeRequested" {
                Ok ( < InspectNodeRequestedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Configuration data for the highlighting of page elements."]
    pub struct HighlightConfig<'a> {
        #[serde(rename = "showInfo", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether the node info tooltip should be shown \\(default: false\\)."]
        pub show_info: Option<bool>,
        #[serde(rename = "showRulers", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether the rulers should be shown \\(default: false\\)."]
        pub show_rulers: Option<bool>,
        #[serde(rename = "showExtensionLines", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether the extension lines from node to the rulers should be shown \\(default: false\\)."]
        pub show_extension_lines: Option<bool>,
        #[serde(rename = "displayAsMaterial", skip_serializing_if = "Option::is_none")]
        pub display_as_material: Option<bool>,
        #[serde(rename = "contentColor", skip_serializing_if = "Option::is_none")]
        #[doc = "The content box highlight fill color \\(default: transparent\\)."]
        pub content_color: Option<::proto::dom::Rgba>,
        #[serde(rename = "paddingColor", skip_serializing_if = "Option::is_none")]
        #[doc = "The padding highlight fill color \\(default: transparent\\)."]
        pub padding_color: Option<::proto::dom::Rgba>,
        #[serde(rename = "borderColor", skip_serializing_if = "Option::is_none")]
        #[doc = "The border highlight fill color \\(default: transparent\\)."]
        pub border_color: Option<::proto::dom::Rgba>,
        #[serde(rename = "marginColor", skip_serializing_if = "Option::is_none")]
        #[doc = "The margin highlight fill color \\(default: transparent\\)."]
        pub margin_color: Option<::proto::dom::Rgba>,
        #[serde(rename = "eventTargetColor", skip_serializing_if = "Option::is_none")]
        #[doc = "The event target element highlight fill color \\(default: transparent\\)."]
        pub event_target_color: Option<::proto::dom::Rgba>,
        #[serde(rename = "shapeColor", skip_serializing_if = "Option::is_none")]
        #[doc = "The shape outside fill color \\(default: transparent\\)."]
        pub shape_color: Option<::proto::dom::Rgba>,
        #[serde(rename = "shapeMarginColor", skip_serializing_if = "Option::is_none")]
        #[doc = "The shape margin fill color \\(default: transparent\\)."]
        pub shape_margin_color: Option<::proto::dom::Rgba>,
        #[serde(rename = "selectorList", skip_serializing_if = "Option::is_none")]
        #[doc = "Selectors to highlight relevant nodes."]
        pub selector_list: Option<::std::borrow::Cow<'a, str>>,
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>"]
    pub enum InspectMode {
        #[serde(rename = "searchForNode")]
        #[doc = "Represented as `\"searchForNode\"`."]
        SearchForNode,
        #[serde(rename = "searchForUAShadowDOM")]
        #[doc = "Represented as `\"searchForUAShadowDOM\"`."]
        SearchForUaShadowDom,
        #[serde(rename = "none")]
        #[doc = "Represented as `\"none\"`."]
        None,
    }
    impl InspectMode {
        pub const ENUM_VALUES: &'static [InspectMode] = &[
            InspectMode::SearchForNode,
            InspectMode::SearchForUaShadowDom,
            InspectMode::None,
        ];
        pub const STR_VALUES: &'static [&'static str] =
            &["searchForNode", "searchForUAShadowDOM", "none"];
    }
    impl ::std::str::FromStr for InspectMode {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "searchForNode" => Ok(InspectMode::SearchForNode),
                "searchForUAShadowDOM" => Ok(InspectMode::SearchForUaShadowDom),
                "none" => Ok(InspectMode::None),
                _ => Err(::proto::ParseEnumError {
                    expected: InspectMode::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for InspectMode {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    InspectMode::SearchForNode => "searchForNode",
                    InspectMode::SearchForUaShadowDom => "searchForUAShadowDOM",
                    InspectMode::None => "none",
                }
            )
        }
    }
}
#[doc = "This domain emulates different environments for the page.\n\n# Emulation\n\n## Commands\n\n- [`Emulation.setDeviceMetricsOverride`](struct.SetDeviceMetricsOverrideCommand.html)\n\n  Overrides the values of device screen dimensions \\(window.screen.width, window.screen.height, window.innerWidth, window.innerHeight, and \"device-width\"/\"device-height\"-related CSS media query results\\).\n- [`Emulation.clearDeviceMetricsOverride`](struct.ClearDeviceMetricsOverrideCommand.html)\n\n  Clears the overriden device metrics.\n- [`Emulation.resetPageScaleFactor`](struct.ResetPageScaleFactorCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Requests that page scale factor is reset to initial values.\n- [`Emulation.setPageScaleFactor`](struct.SetPageScaleFactorCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Sets a specified page scale factor.\n- [`Emulation.setVisibleSize`](struct.SetVisibleSizeCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span> <span class=\"stab deprecated\" style=\"display: inline-block\">[Deprecated]</span>\n\n  Resizes the frame/viewport of the page. Note that this does not affect the frame's container \\(e.g. browser window\\). Can be used to produce screenshots of the specified size. Not supported on Android.\n- [`Emulation.setScriptExecutionDisabled`](struct.SetScriptExecutionDisabledCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Switches script execution in the page.\n- [`Emulation.setGeolocationOverride`](struct.SetGeolocationOverrideCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position unavailable.\n- [`Emulation.clearGeolocationOverride`](struct.ClearGeolocationOverrideCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Clears the overriden Geolocation Position and Error.\n- [`Emulation.setTouchEmulationEnabled`](struct.SetTouchEmulationEnabledCommand.html)\n\n  Toggles mouse event-based touch event emulation.\n- [`Emulation.setEmulatedMedia`](struct.SetEmulatedMediaCommand.html)\n\n  Emulates the given media for CSS media queries.\n- [`Emulation.setCPUThrottlingRate`](struct.SetCpuThrottlingRateCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Enables CPU throttling to emulate slow CPUs.\n- [`Emulation.canEmulate`](struct.CanEmulateCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Tells whether emulation is supported.\n- [`Emulation.setVirtualTimePolicy`](struct.SetVirtualTimePolicyCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Turns on virtual time for all frames \\(replacing real-time with a synthetic time source\\) and sets the current virtual time policy.  Note this supersedes any previous time budget.\n- [`Emulation.setDefaultBackgroundColorOverride`](struct.SetDefaultBackgroundColorOverrideCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Sets or clears an override of the default background color of the frame. This override is used if the content does not specify one.\n\n## Events\n\n- [`Emulation.virtualTimeBudgetExpired`](struct.VirtualTimeBudgetExpiredEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Notification sent after the virual time budget for the current VirtualTimePolicy has run out.\n\n##Types\n\n- [`ScreenOrientation`](struct.ScreenOrientation.html)\n\n  Screen orientation.\n- [`VirtualTimePolicy`](enum.VirtualTimePolicy.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  advance: If the scheduler runs out of immediate work, the virtual time base may fast forward to allow the next delayed task \\(if any\\) to run; pause: The virtual time base may not advance; pauseIfNetworkFetchesPending: The virtual time base may not advance if there are any pending resource fetches.\n"]
pub mod emulation {
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Overrides the values of device screen dimensions \\(window.screen.width, window.screen.height, window.innerWidth, window.innerHeight, and \"device-width\"/\"device-height\"-related CSS media query results\\).\n\n# Command `Emulation.setDeviceMetricsOverride`\n\n*Domain Module:* [`cdp::proto::emulation`](index.html)  \n*Command Struct:* [`cdp::proto::emulation::SetDeviceMetricsOverrideCommand`](struct.SetDeviceMetricsOverrideCommand.html)  \n*Response Struct:* [`cdp::proto::emulation::SetDeviceMetricsOverrideResponse`](struct.SetDeviceMetricsOverrideResponse.html)"]
    pub struct SetDeviceMetricsOverrideCommand {
        #[serde(rename = "width")]
        #[doc = "Overriding width value in pixels \\(minimum 0, maximum 10000000\\). 0 disables the override."]
        pub width: i32,
        #[serde(rename = "height")]
        #[doc = "Overriding height value in pixels \\(minimum 0, maximum 10000000\\). 0 disables the override."]
        pub height: i32,
        #[serde(rename = "deviceScaleFactor")]
        #[doc = "Overriding device scale factor value. 0 disables the override."]
        pub device_scale_factor: f64,
        #[serde(rename = "mobile")]
        #[doc = "Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more."]
        pub mobile: bool,
        #[serde(rename = "scale", skip_serializing_if = "Option::is_none")]
        #[doc = "Scale to apply to resulting view image. Ignored in |fitWindow| mode."]
        pub scale: Option<f64>,
        #[serde(rename = "screenWidth", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Overriding screen width value in pixels \\(minimum 0, maximum 10000000\\). Only used for |mobile==true|."]
        pub screen_width: Option<i32>,
        #[serde(rename = "screenHeight", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Overriding screen height value in pixels \\(minimum 0, maximum 10000000\\). Only used for |mobile==true|."]
        pub screen_height: Option<i32>,
        #[serde(rename = "positionX", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Overriding view X position on screen in pixels \\(minimum 0, maximum 10000000\\). Only used for |mobile==true|."]
        pub position_x: Option<i32>,
        #[serde(rename = "positionY", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Overriding view Y position on screen in pixels \\(minimum 0, maximum 10000000\\). Only used for |mobile==true|."]
        pub position_y: Option<i32>,
        #[serde(rename = "dontSetVisibleSize", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Do not set visible view size, rely upon explicit setVisibleSize call."]
        pub dont_set_visible_size: Option<bool>,
        #[serde(rename = "screenOrientation", skip_serializing_if = "Option::is_none")]
        #[doc = "Screen orientation override."]
        pub screen_orientation: Option<::proto::emulation::ScreenOrientation>,
    }
    impl ::traits::SerializeCdpCommand for SetDeviceMetricsOverrideCommand {
        fn command_name(&self) -> &str {
            "Emulation.setDeviceMetricsOverride"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for SetDeviceMetricsOverrideCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Emulation.setDeviceMetricsOverride" {
                Ok ( < SetDeviceMetricsOverrideCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Overrides the values of device screen dimensions \\(window.screen.width, window.screen.height, window.innerWidth, window.innerHeight, and \"device-width\"/\"device-height\"-related CSS media query results\\).\n\n# Command `Emulation.setDeviceMetricsOverride`\n\n*Domain Module:* [`cdp::proto::emulation`](index.html)  \n*Command Struct:* [`cdp::proto::emulation::SetDeviceMetricsOverrideCommand`](struct.SetDeviceMetricsOverrideCommand.html)  \n*Response Struct:* [`cdp::proto::emulation::SetDeviceMetricsOverrideResponse`](struct.SetDeviceMetricsOverrideResponse.html)"]
    pub struct SetDeviceMetricsOverrideResponse;
    impl ::serde::Serialize for SetDeviceMetricsOverrideResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetDeviceMetricsOverrideResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetDeviceMetricsOverrideResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetDeviceMetricsOverrideCommand {
        type Response = SetDeviceMetricsOverrideResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetDeviceMetricsOverrideResponse {
        type Command = SetDeviceMetricsOverrideCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Clears the overriden device metrics.\n\n# Command `Emulation.clearDeviceMetricsOverride`\n\n*Domain Module:* [`cdp::proto::emulation`](index.html)  \n*Command Struct:* [`cdp::proto::emulation::ClearDeviceMetricsOverrideCommand`](struct.ClearDeviceMetricsOverrideCommand.html)  \n*Response Struct:* [`cdp::proto::emulation::ClearDeviceMetricsOverrideResponse`](struct.ClearDeviceMetricsOverrideResponse.html)"]
    pub struct ClearDeviceMetricsOverrideCommand;
    impl ::serde::Serialize for ClearDeviceMetricsOverrideCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ClearDeviceMetricsOverrideCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ClearDeviceMetricsOverrideCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for ClearDeviceMetricsOverrideCommand {
        fn command_name(&self) -> &str {
            "Emulation.clearDeviceMetricsOverride"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for ClearDeviceMetricsOverrideCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Emulation.clearDeviceMetricsOverride" {
                Ok ( < ClearDeviceMetricsOverrideCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Clears the overriden device metrics.\n\n# Command `Emulation.clearDeviceMetricsOverride`\n\n*Domain Module:* [`cdp::proto::emulation`](index.html)  \n*Command Struct:* [`cdp::proto::emulation::ClearDeviceMetricsOverrideCommand`](struct.ClearDeviceMetricsOverrideCommand.html)  \n*Response Struct:* [`cdp::proto::emulation::ClearDeviceMetricsOverrideResponse`](struct.ClearDeviceMetricsOverrideResponse.html)"]
    pub struct ClearDeviceMetricsOverrideResponse;
    impl ::serde::Serialize for ClearDeviceMetricsOverrideResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ClearDeviceMetricsOverrideResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ClearDeviceMetricsOverrideResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for ClearDeviceMetricsOverrideCommand {
        type Response = ClearDeviceMetricsOverrideResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for ClearDeviceMetricsOverrideResponse {
        type Command = ClearDeviceMetricsOverrideCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Requests that page scale factor is reset to initial values.\n\n# Command `Emulation.resetPageScaleFactor`\n\n*Domain Module:* [`cdp::proto::emulation`](index.html)  \n*Command Struct:* [`cdp::proto::emulation::ResetPageScaleFactorCommand`](struct.ResetPageScaleFactorCommand.html)  \n*Response Struct:* [`cdp::proto::emulation::ResetPageScaleFactorResponse`](struct.ResetPageScaleFactorResponse.html)"]
    pub struct ResetPageScaleFactorCommand;
    impl ::serde::Serialize for ResetPageScaleFactorCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ResetPageScaleFactorCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ResetPageScaleFactorCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for ResetPageScaleFactorCommand {
        fn command_name(&self) -> &str {
            "Emulation.resetPageScaleFactor"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for ResetPageScaleFactorCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Emulation.resetPageScaleFactor" {
                Ok ( < ResetPageScaleFactorCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Requests that page scale factor is reset to initial values.\n\n# Command `Emulation.resetPageScaleFactor`\n\n*Domain Module:* [`cdp::proto::emulation`](index.html)  \n*Command Struct:* [`cdp::proto::emulation::ResetPageScaleFactorCommand`](struct.ResetPageScaleFactorCommand.html)  \n*Response Struct:* [`cdp::proto::emulation::ResetPageScaleFactorResponse`](struct.ResetPageScaleFactorResponse.html)"]
    pub struct ResetPageScaleFactorResponse;
    impl ::serde::Serialize for ResetPageScaleFactorResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ResetPageScaleFactorResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ResetPageScaleFactorResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for ResetPageScaleFactorCommand {
        type Response = ResetPageScaleFactorResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for ResetPageScaleFactorResponse {
        type Command = ResetPageScaleFactorCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Sets a specified page scale factor.\n\n# Command `Emulation.setPageScaleFactor`\n\n*Domain Module:* [`cdp::proto::emulation`](index.html)  \n*Command Struct:* [`cdp::proto::emulation::SetPageScaleFactorCommand`](struct.SetPageScaleFactorCommand.html)  \n*Response Struct:* [`cdp::proto::emulation::SetPageScaleFactorResponse`](struct.SetPageScaleFactorResponse.html)"]
    pub struct SetPageScaleFactorCommand {
        #[serde(rename = "pageScaleFactor")]
        #[doc = "Page scale factor."]
        pub page_scale_factor: f64,
    }
    impl ::traits::SerializeCdpCommand for SetPageScaleFactorCommand {
        fn command_name(&self) -> &str {
            "Emulation.setPageScaleFactor"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for SetPageScaleFactorCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Emulation.setPageScaleFactor" {
                Ok ( < SetPageScaleFactorCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Sets a specified page scale factor.\n\n# Command `Emulation.setPageScaleFactor`\n\n*Domain Module:* [`cdp::proto::emulation`](index.html)  \n*Command Struct:* [`cdp::proto::emulation::SetPageScaleFactorCommand`](struct.SetPageScaleFactorCommand.html)  \n*Response Struct:* [`cdp::proto::emulation::SetPageScaleFactorResponse`](struct.SetPageScaleFactorResponse.html)"]
    pub struct SetPageScaleFactorResponse;
    impl ::serde::Serialize for SetPageScaleFactorResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetPageScaleFactorResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetPageScaleFactorResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetPageScaleFactorCommand {
        type Response = SetPageScaleFactorResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetPageScaleFactorResponse {
        type Command = SetPageScaleFactorCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Resizes the frame/viewport of the page. Note that this does not affect the frame's container \\(e.g. browser window\\). Can be used to produce screenshots of the specified size. Not supported on Android.\n\n# Command `Emulation.setVisibleSize`\n\n*Domain Module:* [`cdp::proto::emulation`](index.html)  \n*Command Struct:* [`cdp::proto::emulation::SetVisibleSizeCommand`](struct.SetVisibleSizeCommand.html)  \n*Response Struct:* [`cdp::proto::emulation::SetVisibleSizeResponse`](struct.SetVisibleSizeResponse.html)"]
    #[deprecated]
    pub struct SetVisibleSizeCommand {
        #[serde(rename = "width")]
        #[doc = "Frame width \\(DIP\\)."]
        pub width: i32,
        #[serde(rename = "height")]
        #[doc = "Frame height \\(DIP\\)."]
        pub height: i32,
    }
    impl ::traits::SerializeCdpCommand for SetVisibleSizeCommand {
        fn command_name(&self) -> &str {
            "Emulation.setVisibleSize"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for SetVisibleSizeCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Emulation.setVisibleSize" {
                Ok(
                    <SetVisibleSizeCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Resizes the frame/viewport of the page. Note that this does not affect the frame's container \\(e.g. browser window\\). Can be used to produce screenshots of the specified size. Not supported on Android.\n\n# Command `Emulation.setVisibleSize`\n\n*Domain Module:* [`cdp::proto::emulation`](index.html)  \n*Command Struct:* [`cdp::proto::emulation::SetVisibleSizeCommand`](struct.SetVisibleSizeCommand.html)  \n*Response Struct:* [`cdp::proto::emulation::SetVisibleSizeResponse`](struct.SetVisibleSizeResponse.html)"]
    #[deprecated]
    pub struct SetVisibleSizeResponse;
    impl ::serde::Serialize for SetVisibleSizeResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetVisibleSizeResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetVisibleSizeResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetVisibleSizeCommand {
        type Response = SetVisibleSizeResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetVisibleSizeResponse {
        type Command = SetVisibleSizeCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Switches script execution in the page.\n\n# Command `Emulation.setScriptExecutionDisabled`\n\n*Domain Module:* [`cdp::proto::emulation`](index.html)  \n*Command Struct:* [`cdp::proto::emulation::SetScriptExecutionDisabledCommand`](struct.SetScriptExecutionDisabledCommand.html)  \n*Response Struct:* [`cdp::proto::emulation::SetScriptExecutionDisabledResponse`](struct.SetScriptExecutionDisabledResponse.html)"]
    pub struct SetScriptExecutionDisabledCommand {
        #[serde(rename = "value")]
        #[doc = "Whether script execution should be disabled in the page."]
        pub value: bool,
    }
    impl ::traits::SerializeCdpCommand for SetScriptExecutionDisabledCommand {
        fn command_name(&self) -> &str {
            "Emulation.setScriptExecutionDisabled"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for SetScriptExecutionDisabledCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Emulation.setScriptExecutionDisabled" {
                Ok ( < SetScriptExecutionDisabledCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Switches script execution in the page.\n\n# Command `Emulation.setScriptExecutionDisabled`\n\n*Domain Module:* [`cdp::proto::emulation`](index.html)  \n*Command Struct:* [`cdp::proto::emulation::SetScriptExecutionDisabledCommand`](struct.SetScriptExecutionDisabledCommand.html)  \n*Response Struct:* [`cdp::proto::emulation::SetScriptExecutionDisabledResponse`](struct.SetScriptExecutionDisabledResponse.html)"]
    pub struct SetScriptExecutionDisabledResponse;
    impl ::serde::Serialize for SetScriptExecutionDisabledResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetScriptExecutionDisabledResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetScriptExecutionDisabledResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetScriptExecutionDisabledCommand {
        type Response = SetScriptExecutionDisabledResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetScriptExecutionDisabledResponse {
        type Command = SetScriptExecutionDisabledCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position unavailable.\n\n# Command `Emulation.setGeolocationOverride`\n\n*Domain Module:* [`cdp::proto::emulation`](index.html)  \n*Command Struct:* [`cdp::proto::emulation::SetGeolocationOverrideCommand`](struct.SetGeolocationOverrideCommand.html)  \n*Response Struct:* [`cdp::proto::emulation::SetGeolocationOverrideResponse`](struct.SetGeolocationOverrideResponse.html)"]
    pub struct SetGeolocationOverrideCommand {
        #[serde(rename = "latitude", skip_serializing_if = "Option::is_none")]
        #[doc = "Mock latitude"]
        pub latitude: Option<f64>,
        #[serde(rename = "longitude", skip_serializing_if = "Option::is_none")]
        #[doc = "Mock longitude"]
        pub longitude: Option<f64>,
        #[serde(rename = "accuracy", skip_serializing_if = "Option::is_none")]
        #[doc = "Mock accuracy"]
        pub accuracy: Option<f64>,
    }
    impl ::traits::SerializeCdpCommand for SetGeolocationOverrideCommand {
        fn command_name(&self) -> &str {
            "Emulation.setGeolocationOverride"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for SetGeolocationOverrideCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Emulation.setGeolocationOverride" {
                Ok ( < SetGeolocationOverrideCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position unavailable.\n\n# Command `Emulation.setGeolocationOverride`\n\n*Domain Module:* [`cdp::proto::emulation`](index.html)  \n*Command Struct:* [`cdp::proto::emulation::SetGeolocationOverrideCommand`](struct.SetGeolocationOverrideCommand.html)  \n*Response Struct:* [`cdp::proto::emulation::SetGeolocationOverrideResponse`](struct.SetGeolocationOverrideResponse.html)"]
    pub struct SetGeolocationOverrideResponse;
    impl ::serde::Serialize for SetGeolocationOverrideResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetGeolocationOverrideResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetGeolocationOverrideResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetGeolocationOverrideCommand {
        type Response = SetGeolocationOverrideResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetGeolocationOverrideResponse {
        type Command = SetGeolocationOverrideCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Clears the overriden Geolocation Position and Error.\n\n# Command `Emulation.clearGeolocationOverride`\n\n*Domain Module:* [`cdp::proto::emulation`](index.html)  \n*Command Struct:* [`cdp::proto::emulation::ClearGeolocationOverrideCommand`](struct.ClearGeolocationOverrideCommand.html)  \n*Response Struct:* [`cdp::proto::emulation::ClearGeolocationOverrideResponse`](struct.ClearGeolocationOverrideResponse.html)"]
    pub struct ClearGeolocationOverrideCommand;
    impl ::serde::Serialize for ClearGeolocationOverrideCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ClearGeolocationOverrideCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ClearGeolocationOverrideCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for ClearGeolocationOverrideCommand {
        fn command_name(&self) -> &str {
            "Emulation.clearGeolocationOverride"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for ClearGeolocationOverrideCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Emulation.clearGeolocationOverride" {
                Ok ( < ClearGeolocationOverrideCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Clears the overriden Geolocation Position and Error.\n\n# Command `Emulation.clearGeolocationOverride`\n\n*Domain Module:* [`cdp::proto::emulation`](index.html)  \n*Command Struct:* [`cdp::proto::emulation::ClearGeolocationOverrideCommand`](struct.ClearGeolocationOverrideCommand.html)  \n*Response Struct:* [`cdp::proto::emulation::ClearGeolocationOverrideResponse`](struct.ClearGeolocationOverrideResponse.html)"]
    pub struct ClearGeolocationOverrideResponse;
    impl ::serde::Serialize for ClearGeolocationOverrideResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ClearGeolocationOverrideResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ClearGeolocationOverrideResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for ClearGeolocationOverrideCommand {
        type Response = ClearGeolocationOverrideResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for ClearGeolocationOverrideResponse {
        type Command = ClearGeolocationOverrideCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "Used in the type of [`cdp::proto::emulation::SetTouchEmulationEnabledCommand::configuration`](struct.SetTouchEmulationEnabledCommand.html#structfield.configuration)."]
    pub enum SetTouchEmulationEnabledCommandConfiguration {
        #[serde(rename = "mobile")]
        #[doc = "Represented as `\"mobile\"`."]
        Mobile,
        #[serde(rename = "desktop")]
        #[doc = "Represented as `\"desktop\"`."]
        Desktop,
    }
    impl SetTouchEmulationEnabledCommandConfiguration {
        pub const ENUM_VALUES: &'static [SetTouchEmulationEnabledCommandConfiguration] =
            &[
                SetTouchEmulationEnabledCommandConfiguration::Mobile,
                SetTouchEmulationEnabledCommandConfiguration::Desktop,
            ];
        pub const STR_VALUES: &'static [&'static str] = &["mobile", "desktop"];
    }
    impl ::std::str::FromStr for SetTouchEmulationEnabledCommandConfiguration {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "mobile" => Ok(SetTouchEmulationEnabledCommandConfiguration::Mobile),
                "desktop" => Ok(SetTouchEmulationEnabledCommandConfiguration::Desktop),
                _ => Err(::proto::ParseEnumError {
                    expected: SetTouchEmulationEnabledCommandConfiguration::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for SetTouchEmulationEnabledCommandConfiguration {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    SetTouchEmulationEnabledCommandConfiguration::Mobile => "mobile",
                    SetTouchEmulationEnabledCommandConfiguration::Desktop => "desktop",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Toggles mouse event-based touch event emulation.\n\n# Command `Emulation.setTouchEmulationEnabled`\n\n*Domain Module:* [`cdp::proto::emulation`](index.html)  \n*Command Struct:* [`cdp::proto::emulation::SetTouchEmulationEnabledCommand`](struct.SetTouchEmulationEnabledCommand.html)  \n*Response Struct:* [`cdp::proto::emulation::SetTouchEmulationEnabledResponse`](struct.SetTouchEmulationEnabledResponse.html)"]
    pub struct SetTouchEmulationEnabledCommand {
        #[serde(rename = "enabled")]
        #[doc = "Whether the touch event emulation should be enabled."]
        pub enabled: bool,
        #[serde(rename = "configuration", skip_serializing_if = "Option::is_none")]
        #[doc = "Touch/gesture events configuration. Default: current platform."]
        pub configuration:
            Option<::proto::emulation::SetTouchEmulationEnabledCommandConfiguration>,
    }
    impl ::traits::SerializeCdpCommand for SetTouchEmulationEnabledCommand {
        fn command_name(&self) -> &str {
            "Emulation.setTouchEmulationEnabled"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for SetTouchEmulationEnabledCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Emulation.setTouchEmulationEnabled" {
                Ok ( < SetTouchEmulationEnabledCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Toggles mouse event-based touch event emulation.\n\n# Command `Emulation.setTouchEmulationEnabled`\n\n*Domain Module:* [`cdp::proto::emulation`](index.html)  \n*Command Struct:* [`cdp::proto::emulation::SetTouchEmulationEnabledCommand`](struct.SetTouchEmulationEnabledCommand.html)  \n*Response Struct:* [`cdp::proto::emulation::SetTouchEmulationEnabledResponse`](struct.SetTouchEmulationEnabledResponse.html)"]
    pub struct SetTouchEmulationEnabledResponse;
    impl ::serde::Serialize for SetTouchEmulationEnabledResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetTouchEmulationEnabledResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetTouchEmulationEnabledResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetTouchEmulationEnabledCommand {
        type Response = SetTouchEmulationEnabledResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetTouchEmulationEnabledResponse {
        type Command = SetTouchEmulationEnabledCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Emulates the given media for CSS media queries.\n\n# Command `Emulation.setEmulatedMedia`\n\n*Domain Module:* [`cdp::proto::emulation`](index.html)  \n*Command Struct:* [`cdp::proto::emulation::SetEmulatedMediaCommand`](struct.SetEmulatedMediaCommand.html)  \n*Response Struct:* [`cdp::proto::emulation::SetEmulatedMediaResponse`](struct.SetEmulatedMediaResponse.html)"]
    pub struct SetEmulatedMediaCommand<'a> {
        #[serde(rename = "media")]
        #[doc = "Media type to emulate. Empty string disables the override."]
        pub media: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpCommand for SetEmulatedMediaCommand<'a> {
        fn command_name(&self) -> &str {
            "Emulation.setEmulatedMedia"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for SetEmulatedMediaCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Emulation.setEmulatedMedia" {
                Ok ( < SetEmulatedMediaCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Emulates the given media for CSS media queries.\n\n# Command `Emulation.setEmulatedMedia`\n\n*Domain Module:* [`cdp::proto::emulation`](index.html)  \n*Command Struct:* [`cdp::proto::emulation::SetEmulatedMediaCommand`](struct.SetEmulatedMediaCommand.html)  \n*Response Struct:* [`cdp::proto::emulation::SetEmulatedMediaResponse`](struct.SetEmulatedMediaResponse.html)"]
    pub struct SetEmulatedMediaResponse;
    impl ::serde::Serialize for SetEmulatedMediaResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetEmulatedMediaResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetEmulatedMediaResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetEmulatedMediaCommand<'a> {
        type Response = SetEmulatedMediaResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetEmulatedMediaResponse {
        type Command = SetEmulatedMediaCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables CPU throttling to emulate slow CPUs.\n\n# Command `Emulation.setCPUThrottlingRate`\n\n*Domain Module:* [`cdp::proto::emulation`](index.html)  \n*Command Struct:* [`cdp::proto::emulation::SetCpuThrottlingRateCommand`](struct.SetCpuThrottlingRateCommand.html)  \n*Response Struct:* [`cdp::proto::emulation::SetCpuThrottlingRateResponse`](struct.SetCpuThrottlingRateResponse.html)"]
    pub struct SetCpuThrottlingRateCommand {
        #[serde(rename = "rate")]
        #[doc = "Throttling rate as a slowdown factor \\(1 is no throttle, 2 is 2x slowdown, etc\\)."]
        pub rate: f64,
    }
    impl ::traits::SerializeCdpCommand for SetCpuThrottlingRateCommand {
        fn command_name(&self) -> &str {
            "Emulation.setCPUThrottlingRate"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for SetCpuThrottlingRateCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Emulation.setCPUThrottlingRate" {
                Ok ( < SetCpuThrottlingRateCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables CPU throttling to emulate slow CPUs.\n\n# Command `Emulation.setCPUThrottlingRate`\n\n*Domain Module:* [`cdp::proto::emulation`](index.html)  \n*Command Struct:* [`cdp::proto::emulation::SetCpuThrottlingRateCommand`](struct.SetCpuThrottlingRateCommand.html)  \n*Response Struct:* [`cdp::proto::emulation::SetCpuThrottlingRateResponse`](struct.SetCpuThrottlingRateResponse.html)"]
    pub struct SetCpuThrottlingRateResponse;
    impl ::serde::Serialize for SetCpuThrottlingRateResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetCpuThrottlingRateResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetCpuThrottlingRateResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetCpuThrottlingRateCommand {
        type Response = SetCpuThrottlingRateResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetCpuThrottlingRateResponse {
        type Command = SetCpuThrottlingRateCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Tells whether emulation is supported.\n\n# Command `Emulation.canEmulate`\n\n*Domain Module:* [`cdp::proto::emulation`](index.html)  \n*Command Struct:* [`cdp::proto::emulation::CanEmulateCommand`](struct.CanEmulateCommand.html)  \n*Response Struct:* [`cdp::proto::emulation::CanEmulateResponse`](struct.CanEmulateResponse.html)"]
    pub struct CanEmulateCommand;
    impl ::serde::Serialize for CanEmulateCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CanEmulateCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| CanEmulateCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for CanEmulateCommand {
        fn command_name(&self) -> &str {
            "Emulation.canEmulate"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for CanEmulateCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Emulation.canEmulate" {
                Ok(
                    <CanEmulateCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Tells whether emulation is supported.\n\n# Command `Emulation.canEmulate`\n\n*Domain Module:* [`cdp::proto::emulation`](index.html)  \n*Command Struct:* [`cdp::proto::emulation::CanEmulateCommand`](struct.CanEmulateCommand.html)  \n*Response Struct:* [`cdp::proto::emulation::CanEmulateResponse`](struct.CanEmulateResponse.html)"]
    pub struct CanEmulateResponse {
        #[serde(rename = "result")]
        #[doc = "True if emulation is supported."]
        pub result: bool,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for CanEmulateCommand {
        type Response = CanEmulateResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for CanEmulateResponse {
        type Command = CanEmulateCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Turns on virtual time for all frames \\(replacing real-time with a synthetic time source\\) and sets the current virtual time policy.  Note this supersedes any previous time budget.\n\n# Command `Emulation.setVirtualTimePolicy`\n\n*Domain Module:* [`cdp::proto::emulation`](index.html)  \n*Command Struct:* [`cdp::proto::emulation::SetVirtualTimePolicyCommand`](struct.SetVirtualTimePolicyCommand.html)  \n*Response Struct:* [`cdp::proto::emulation::SetVirtualTimePolicyResponse`](struct.SetVirtualTimePolicyResponse.html)"]
    pub struct SetVirtualTimePolicyCommand {
        #[serde(rename = "policy")]
        pub policy: ::proto::emulation::VirtualTimePolicy,
        #[serde(rename = "budget", skip_serializing_if = "Option::is_none")]
        #[doc = "If set, after this many virtual milliseconds have elapsed virtual time will be paused and a virtualTimeBudgetExpired event is sent."]
        pub budget: Option<i32>,
    }
    impl ::traits::SerializeCdpCommand for SetVirtualTimePolicyCommand {
        fn command_name(&self) -> &str {
            "Emulation.setVirtualTimePolicy"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for SetVirtualTimePolicyCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Emulation.setVirtualTimePolicy" {
                Ok ( < SetVirtualTimePolicyCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Turns on virtual time for all frames \\(replacing real-time with a synthetic time source\\) and sets the current virtual time policy.  Note this supersedes any previous time budget.\n\n# Command `Emulation.setVirtualTimePolicy`\n\n*Domain Module:* [`cdp::proto::emulation`](index.html)  \n*Command Struct:* [`cdp::proto::emulation::SetVirtualTimePolicyCommand`](struct.SetVirtualTimePolicyCommand.html)  \n*Response Struct:* [`cdp::proto::emulation::SetVirtualTimePolicyResponse`](struct.SetVirtualTimePolicyResponse.html)"]
    pub struct SetVirtualTimePolicyResponse;
    impl ::serde::Serialize for SetVirtualTimePolicyResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetVirtualTimePolicyResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetVirtualTimePolicyResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetVirtualTimePolicyCommand {
        type Response = SetVirtualTimePolicyResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetVirtualTimePolicyResponse {
        type Command = SetVirtualTimePolicyCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Sets or clears an override of the default background color of the frame. This override is used if the content does not specify one.\n\n# Command `Emulation.setDefaultBackgroundColorOverride`\n\n*Domain Module:* [`cdp::proto::emulation`](index.html)  \n*Command Struct:* [`cdp::proto::emulation::SetDefaultBackgroundColorOverrideCommand`](struct.SetDefaultBackgroundColorOverrideCommand.html)  \n*Response Struct:* [`cdp::proto::emulation::SetDefaultBackgroundColorOverrideResponse`](struct.SetDefaultBackgroundColorOverrideResponse.html)"]
    pub struct SetDefaultBackgroundColorOverrideCommand {
        #[serde(rename = "color", skip_serializing_if = "Option::is_none")]
        #[doc = "RGBA of the default background color. If not specified, any existing override will be cleared."]
        pub color: Option<::proto::dom::Rgba>,
    }
    impl ::traits::SerializeCdpCommand for SetDefaultBackgroundColorOverrideCommand {
        fn command_name(&self) -> &str {
            "Emulation.setDefaultBackgroundColorOverride"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for SetDefaultBackgroundColorOverrideCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Emulation.setDefaultBackgroundColorOverride" {
                Ok ( < SetDefaultBackgroundColorOverrideCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Sets or clears an override of the default background color of the frame. This override is used if the content does not specify one.\n\n# Command `Emulation.setDefaultBackgroundColorOverride`\n\n*Domain Module:* [`cdp::proto::emulation`](index.html)  \n*Command Struct:* [`cdp::proto::emulation::SetDefaultBackgroundColorOverrideCommand`](struct.SetDefaultBackgroundColorOverrideCommand.html)  \n*Response Struct:* [`cdp::proto::emulation::SetDefaultBackgroundColorOverrideResponse`](struct.SetDefaultBackgroundColorOverrideResponse.html)"]
    pub struct SetDefaultBackgroundColorOverrideResponse;
    impl ::serde::Serialize for SetDefaultBackgroundColorOverrideResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetDefaultBackgroundColorOverrideResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetDefaultBackgroundColorOverrideResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetDefaultBackgroundColorOverrideCommand {
        type Response = SetDefaultBackgroundColorOverrideResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetDefaultBackgroundColorOverrideResponse {
        type Command = SetDefaultBackgroundColorOverrideCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Notification sent after the virual time budget for the current VirtualTimePolicy has run out.\n\n# Event `Emulation.virtualTimeBudgetExpired`\n\n*Domain Module:* [`cdp::proto::emulation`](index.html)  \n*Event Struct:* [`cdp::proto::emulation::VirtualTimeBudgetExpiredEvent`](struct.VirtualTimeBudgetExpiredEvent.html)"]
    pub struct VirtualTimeBudgetExpiredEvent;
    impl ::serde::Serialize for VirtualTimeBudgetExpiredEvent {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for VirtualTimeBudgetExpiredEvent {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| VirtualTimeBudgetExpiredEvent)
        }
    }
    impl ::traits::SerializeCdpEvent for VirtualTimeBudgetExpiredEvent {
        fn event_name(&self) -> &str {
            "Emulation.virtualTimeBudgetExpired"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpEvent<'de> for VirtualTimeBudgetExpiredEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Emulation.virtualTimeBudgetExpired" {
                Ok ( < VirtualTimeBudgetExpiredEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "Used in the type of [`cdp::proto::emulation::ScreenOrientation::ty`](struct.ScreenOrientation.html#structfield.ty)."]
    pub enum ScreenOrientationType {
        #[serde(rename = "portraitPrimary")]
        #[doc = "Represented as `\"portraitPrimary\"`."]
        PortraitPrimary,
        #[serde(rename = "portraitSecondary")]
        #[doc = "Represented as `\"portraitSecondary\"`."]
        PortraitSecondary,
        #[serde(rename = "landscapePrimary")]
        #[doc = "Represented as `\"landscapePrimary\"`."]
        LandscapePrimary,
        #[serde(rename = "landscapeSecondary")]
        #[doc = "Represented as `\"landscapeSecondary\"`."]
        LandscapeSecondary,
    }
    impl ScreenOrientationType {
        pub const ENUM_VALUES: &'static [ScreenOrientationType] =
            &[
                ScreenOrientationType::PortraitPrimary,
                ScreenOrientationType::PortraitSecondary,
                ScreenOrientationType::LandscapePrimary,
                ScreenOrientationType::LandscapeSecondary,
            ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "portraitPrimary",
            "portraitSecondary",
            "landscapePrimary",
            "landscapeSecondary",
        ];
    }
    impl ::std::str::FromStr for ScreenOrientationType {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "portraitPrimary" => Ok(ScreenOrientationType::PortraitPrimary),
                "portraitSecondary" => Ok(ScreenOrientationType::PortraitSecondary),
                "landscapePrimary" => Ok(ScreenOrientationType::LandscapePrimary),
                "landscapeSecondary" => Ok(ScreenOrientationType::LandscapeSecondary),
                _ => Err(::proto::ParseEnumError {
                    expected: ScreenOrientationType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for ScreenOrientationType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    ScreenOrientationType::PortraitPrimary => "portraitPrimary",
                    ScreenOrientationType::PortraitSecondary => "portraitSecondary",
                    ScreenOrientationType::LandscapePrimary => "landscapePrimary",
                    ScreenOrientationType::LandscapeSecondary => "landscapeSecondary",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Screen orientation."]
    pub struct ScreenOrientation {
        #[serde(rename = "type")]
        #[doc = "Orientation type."]
        pub ty: ::proto::emulation::ScreenOrientationType,
        #[serde(rename = "angle")]
        #[doc = "Orientation angle."]
        pub angle: i32,
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> advance: If the scheduler runs out of immediate work, the virtual time base may fast forward to allow the next delayed task \\(if any\\) to run; pause: The virtual time base may not advance; pauseIfNetworkFetchesPending: The virtual time base may not advance if there are any pending resource fetches."]
    pub enum VirtualTimePolicy {
        #[serde(rename = "advance")]
        #[doc = "Represented as `\"advance\"`."]
        Advance,
        #[serde(rename = "pause")]
        #[doc = "Represented as `\"pause\"`."]
        Pause,
        #[serde(rename = "pauseIfNetworkFetchesPending")]
        #[doc = "Represented as `\"pauseIfNetworkFetchesPending\"`."]
        PauseIfNetworkFetchesPending,
    }
    impl VirtualTimePolicy {
        pub const ENUM_VALUES: &'static [VirtualTimePolicy] =
            &[
                VirtualTimePolicy::Advance,
                VirtualTimePolicy::Pause,
                VirtualTimePolicy::PauseIfNetworkFetchesPending,
            ];
        pub const STR_VALUES: &'static [&'static str] =
            &["advance", "pause", "pauseIfNetworkFetchesPending"];
    }
    impl ::std::str::FromStr for VirtualTimePolicy {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "advance" => Ok(VirtualTimePolicy::Advance),
                "pause" => Ok(VirtualTimePolicy::Pause),
                "pauseIfNetworkFetchesPending" => {
                    Ok(VirtualTimePolicy::PauseIfNetworkFetchesPending)
                }
                _ => Err(::proto::ParseEnumError {
                    expected: VirtualTimePolicy::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for VirtualTimePolicy {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    VirtualTimePolicy::Advance => "advance",
                    VirtualTimePolicy::Pause => "pause",
                    VirtualTimePolicy::PauseIfNetworkFetchesPending => {
                        "pauseIfNetworkFetchesPending"
                    }
                }
            )
        }
    }
}
#[doc = "<span class=\"stab unstable\">[Experimental]</span> Security\n\n# Security\n\n## Commands\n\n- [`Security.enable`](struct.EnableCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Enables tracking security state changes.\n- [`Security.disable`](struct.DisableCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Disables tracking security state changes.\n- [`Security.showCertificateViewer`](struct.ShowCertificateViewerCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Displays native dialog with the certificate details.\n- [`Security.handleCertificateError`](struct.HandleCertificateErrorCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Handles a certificate error that fired a certificateError event.\n- [`Security.setOverrideCertificateErrors`](struct.SetOverrideCertificateErrorsCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Enable/disable overriding certificate errors. If enabled, all certificate error events need to be handled by the DevTools client and should be answered with handleCertificateError commands.\n\n## Events\n\n- [`Security.securityStateChanged`](struct.SecurityStateChangedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  The security state of the page changed.\n- [`Security.certificateError`](struct.CertificateErrorEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  There is a certificate error. If overriding certificate errors is enabled, then it should be handled with the handleCertificateError command. Note: this event does not fire if the certificate error has been allowed internally.\n\n##Types\n\n- [`CertificateId`](type.CertificateId.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  An internal certificate ID value.\n- [`MixedContentType`](enum.MixedContentType.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  A description of mixed content \\(HTTP resources on HTTPS pages\\), as defined by https://www.w3.org/TR/mixed-content/#categories\n- [`SecurityState`](enum.SecurityState.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  The security level of a page or resource.\n- [`SecurityStateExplanation`](struct.SecurityStateExplanation.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  An explanation of an factor contributing to the security state.\n- [`InsecureContentStatus`](struct.InsecureContentStatus.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Information about insecure content on the page.\n- [`CertificateErrorAction`](enum.CertificateErrorAction.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  The action to take when a certificate error occurs. continue will continue processing the request and cancel will cancel the request.\n"]
pub mod security {
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables tracking security state changes.\n\n# Command `Security.enable`\n\n*Domain Module:* [`cdp::proto::security`](index.html)  \n*Command Struct:* [`cdp::proto::security::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::proto::security::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableCommand;
    impl ::serde::Serialize for EnableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for EnableCommand {
        fn command_name(&self) -> &str {
            "Security.enable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for EnableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Security.enable" {
                Ok(
                    <EnableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables tracking security state changes.\n\n# Command `Security.enable`\n\n*Domain Module:* [`cdp::proto::security`](index.html)  \n*Command Struct:* [`cdp::proto::security::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::proto::security::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableResponse;
    impl ::serde::Serialize for EnableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for EnableCommand {
        type Response = EnableResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for EnableResponse {
        type Command = EnableCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Disables tracking security state changes.\n\n# Command `Security.disable`\n\n*Domain Module:* [`cdp::proto::security`](index.html)  \n*Command Struct:* [`cdp::proto::security::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::proto::security::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableCommand;
    impl ::serde::Serialize for DisableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for DisableCommand {
        fn command_name(&self) -> &str {
            "Security.disable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for DisableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Security.disable" {
                Ok(
                    <DisableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Disables tracking security state changes.\n\n# Command `Security.disable`\n\n*Domain Module:* [`cdp::proto::security`](index.html)  \n*Command Struct:* [`cdp::proto::security::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::proto::security::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableResponse;
    impl ::serde::Serialize for DisableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for DisableCommand {
        type Response = DisableResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for DisableResponse {
        type Command = DisableCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Displays native dialog with the certificate details.\n\n# Command `Security.showCertificateViewer`\n\n*Domain Module:* [`cdp::proto::security`](index.html)  \n*Command Struct:* [`cdp::proto::security::ShowCertificateViewerCommand`](struct.ShowCertificateViewerCommand.html)  \n*Response Struct:* [`cdp::proto::security::ShowCertificateViewerResponse`](struct.ShowCertificateViewerResponse.html)"]
    pub struct ShowCertificateViewerCommand;
    impl ::serde::Serialize for ShowCertificateViewerCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ShowCertificateViewerCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ShowCertificateViewerCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for ShowCertificateViewerCommand {
        fn command_name(&self) -> &str {
            "Security.showCertificateViewer"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for ShowCertificateViewerCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Security.showCertificateViewer" {
                Ok ( < ShowCertificateViewerCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Displays native dialog with the certificate details.\n\n# Command `Security.showCertificateViewer`\n\n*Domain Module:* [`cdp::proto::security`](index.html)  \n*Command Struct:* [`cdp::proto::security::ShowCertificateViewerCommand`](struct.ShowCertificateViewerCommand.html)  \n*Response Struct:* [`cdp::proto::security::ShowCertificateViewerResponse`](struct.ShowCertificateViewerResponse.html)"]
    pub struct ShowCertificateViewerResponse;
    impl ::serde::Serialize for ShowCertificateViewerResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ShowCertificateViewerResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ShowCertificateViewerResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for ShowCertificateViewerCommand {
        type Response = ShowCertificateViewerResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for ShowCertificateViewerResponse {
        type Command = ShowCertificateViewerCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Handles a certificate error that fired a certificateError event.\n\n# Command `Security.handleCertificateError`\n\n*Domain Module:* [`cdp::proto::security`](index.html)  \n*Command Struct:* [`cdp::proto::security::HandleCertificateErrorCommand`](struct.HandleCertificateErrorCommand.html)  \n*Response Struct:* [`cdp::proto::security::HandleCertificateErrorResponse`](struct.HandleCertificateErrorResponse.html)"]
    pub struct HandleCertificateErrorCommand {
        #[serde(rename = "eventId")]
        #[doc = "The ID of the event."]
        pub event_id: i32,
        #[serde(rename = "action")]
        #[doc = "The action to take on the certificate error."]
        pub action: ::proto::security::CertificateErrorAction,
    }
    impl ::traits::SerializeCdpCommand for HandleCertificateErrorCommand {
        fn command_name(&self) -> &str {
            "Security.handleCertificateError"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for HandleCertificateErrorCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Security.handleCertificateError" {
                Ok ( < HandleCertificateErrorCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Handles a certificate error that fired a certificateError event.\n\n# Command `Security.handleCertificateError`\n\n*Domain Module:* [`cdp::proto::security`](index.html)  \n*Command Struct:* [`cdp::proto::security::HandleCertificateErrorCommand`](struct.HandleCertificateErrorCommand.html)  \n*Response Struct:* [`cdp::proto::security::HandleCertificateErrorResponse`](struct.HandleCertificateErrorResponse.html)"]
    pub struct HandleCertificateErrorResponse;
    impl ::serde::Serialize for HandleCertificateErrorResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for HandleCertificateErrorResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| HandleCertificateErrorResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for HandleCertificateErrorCommand {
        type Response = HandleCertificateErrorResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for HandleCertificateErrorResponse {
        type Command = HandleCertificateErrorCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enable/disable overriding certificate errors. If enabled, all certificate error events need to be handled by the DevTools client and should be answered with handleCertificateError commands.\n\n# Command `Security.setOverrideCertificateErrors`\n\n*Domain Module:* [`cdp::proto::security`](index.html)  \n*Command Struct:* [`cdp::proto::security::SetOverrideCertificateErrorsCommand`](struct.SetOverrideCertificateErrorsCommand.html)  \n*Response Struct:* [`cdp::proto::security::SetOverrideCertificateErrorsResponse`](struct.SetOverrideCertificateErrorsResponse.html)"]
    pub struct SetOverrideCertificateErrorsCommand {
        #[serde(rename = "override")]
        #[doc = "If true, certificate errors will be overridden."]
        pub overridden: bool,
    }
    impl ::traits::SerializeCdpCommand for SetOverrideCertificateErrorsCommand {
        fn command_name(&self) -> &str {
            "Security.setOverrideCertificateErrors"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for SetOverrideCertificateErrorsCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Security.setOverrideCertificateErrors" {
                Ok ( < SetOverrideCertificateErrorsCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enable/disable overriding certificate errors. If enabled, all certificate error events need to be handled by the DevTools client and should be answered with handleCertificateError commands.\n\n# Command `Security.setOverrideCertificateErrors`\n\n*Domain Module:* [`cdp::proto::security`](index.html)  \n*Command Struct:* [`cdp::proto::security::SetOverrideCertificateErrorsCommand`](struct.SetOverrideCertificateErrorsCommand.html)  \n*Response Struct:* [`cdp::proto::security::SetOverrideCertificateErrorsResponse`](struct.SetOverrideCertificateErrorsResponse.html)"]
    pub struct SetOverrideCertificateErrorsResponse;
    impl ::serde::Serialize for SetOverrideCertificateErrorsResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetOverrideCertificateErrorsResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetOverrideCertificateErrorsResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetOverrideCertificateErrorsCommand {
        type Response = SetOverrideCertificateErrorsResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetOverrideCertificateErrorsResponse {
        type Command = SetOverrideCertificateErrorsCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> The security state of the page changed.\n\n# Event `Security.securityStateChanged`\n\n*Domain Module:* [`cdp::proto::security`](index.html)  \n*Event Struct:* [`cdp::proto::security::SecurityStateChangedEvent`](struct.SecurityStateChangedEvent.html)"]
    pub struct SecurityStateChangedEvent<'a> {
        #[serde(rename = "securityState")]
        #[doc = "Security state."]
        pub security_state: ::proto::security::SecurityState,
        #[serde(rename = "schemeIsCryptographic")]
        #[doc = "True if the page was loaded over cryptographic transport such as HTTPS."]
        pub scheme_is_cryptographic: bool,
        #[serde(rename = "explanations")]
        #[doc = "List of explanations for the security state. If the overall security state is `insecure` or `warning`, at least one corresponding explanation should be included."]
        pub explanations: Vec<::proto::security::SecurityStateExplanation<'a>>,
        #[serde(rename = "insecureContentStatus")]
        #[doc = "Information about insecure content on the page."]
        pub insecure_content_status: ::proto::security::InsecureContentStatus,
        #[serde(rename = "summary", skip_serializing_if = "Option::is_none")]
        #[doc = "Overrides user-visible description of the state."]
        pub summary: Option<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::traits::SerializeCdpEvent for SecurityStateChangedEvent<'a> {
        fn event_name(&self) -> &str {
            "Security.securityStateChanged"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for SecurityStateChangedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Security.securityStateChanged" {
                Ok ( < SecurityStateChangedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> There is a certificate error. If overriding certificate errors is enabled, then it should be handled with the handleCertificateError command. Note: this event does not fire if the certificate error has been allowed internally.\n\n# Event `Security.certificateError`\n\n*Domain Module:* [`cdp::proto::security`](index.html)  \n*Event Struct:* [`cdp::proto::security::CertificateErrorEvent`](struct.CertificateErrorEvent.html)"]
    pub struct CertificateErrorEvent<'a> {
        #[serde(rename = "eventId")]
        #[doc = "The ID of the event."]
        pub event_id: i32,
        #[serde(rename = "errorType")]
        #[doc = "The type of the error."]
        pub error_type: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "requestURL")]
        #[doc = "The url that was requested."]
        pub request_url: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpEvent for CertificateErrorEvent<'a> {
        fn event_name(&self) -> &str {
            "Security.certificateError"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for CertificateErrorEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Security.certificateError" {
                Ok(
                    <CertificateErrorEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> An internal certificate ID value."]
    pub type CertificateId = i32;
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> A description of mixed content \\(HTTP resources on HTTPS pages\\), as defined by https://www.w3.org/TR/mixed-content/#categories"]
    pub enum MixedContentType {
        #[serde(rename = "blockable")]
        #[doc = "Represented as `\"blockable\"`."]
        Blockable,
        #[serde(rename = "optionally-blockable")]
        #[doc = "Represented as `\"optionally-blockable\"`."]
        OptionallyBlockable,
        #[serde(rename = "none")]
        #[doc = "Represented as `\"none\"`."]
        None,
    }
    impl MixedContentType {
        pub const ENUM_VALUES: &'static [MixedContentType] = &[
            MixedContentType::Blockable,
            MixedContentType::OptionallyBlockable,
            MixedContentType::None,
        ];
        pub const STR_VALUES: &'static [&'static str] =
            &["blockable", "optionally-blockable", "none"];
    }
    impl ::std::str::FromStr for MixedContentType {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "blockable" => Ok(MixedContentType::Blockable),
                "optionally-blockable" => Ok(MixedContentType::OptionallyBlockable),
                "none" => Ok(MixedContentType::None),
                _ => Err(::proto::ParseEnumError {
                    expected: MixedContentType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for MixedContentType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    MixedContentType::Blockable => "blockable",
                    MixedContentType::OptionallyBlockable => "optionally-blockable",
                    MixedContentType::None => "none",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> The security level of a page or resource."]
    pub enum SecurityState {
        #[serde(rename = "unknown")]
        #[doc = "Represented as `\"unknown\"`."]
        Unknown,
        #[serde(rename = "neutral")]
        #[doc = "Represented as `\"neutral\"`."]
        Neutral,
        #[serde(rename = "insecure")]
        #[doc = "Represented as `\"insecure\"`."]
        Insecure,
        #[serde(rename = "warning")]
        #[doc = "Represented as `\"warning\"`."]
        Warning,
        #[serde(rename = "secure")]
        #[doc = "Represented as `\"secure\"`."]
        Secure,
        #[serde(rename = "info")]
        #[doc = "Represented as `\"info\"`."]
        Info,
    }
    impl SecurityState {
        pub const ENUM_VALUES: &'static [SecurityState] = &[
            SecurityState::Unknown,
            SecurityState::Neutral,
            SecurityState::Insecure,
            SecurityState::Warning,
            SecurityState::Secure,
            SecurityState::Info,
        ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "unknown",
            "neutral",
            "insecure",
            "warning",
            "secure",
            "info",
        ];
    }
    impl ::std::str::FromStr for SecurityState {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "unknown" => Ok(SecurityState::Unknown),
                "neutral" => Ok(SecurityState::Neutral),
                "insecure" => Ok(SecurityState::Insecure),
                "warning" => Ok(SecurityState::Warning),
                "secure" => Ok(SecurityState::Secure),
                "info" => Ok(SecurityState::Info),
                _ => Err(::proto::ParseEnumError {
                    expected: SecurityState::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for SecurityState {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    SecurityState::Unknown => "unknown",
                    SecurityState::Neutral => "neutral",
                    SecurityState::Insecure => "insecure",
                    SecurityState::Warning => "warning",
                    SecurityState::Secure => "secure",
                    SecurityState::Info => "info",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> An explanation of an factor contributing to the security state."]
    pub struct SecurityStateExplanation<'a> {
        #[serde(rename = "securityState")]
        #[doc = "Security state representing the severity of the factor being explained."]
        pub security_state: ::proto::security::SecurityState,
        #[serde(rename = "summary")]
        #[doc = "Short phrase describing the type of factor."]
        pub summary: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "description")]
        #[doc = "Full text explanation of the factor."]
        pub description: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "hasCertificate")]
        #[doc = "True if the page has a certificate."]
        pub has_certificate: bool,
        #[serde(rename = "mixedContentType")]
        #[doc = "The type of mixed content described by the explanation."]
        pub mixed_content_type: ::proto::security::MixedContentType,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Information about insecure content on the page."]
    pub struct InsecureContentStatus {
        #[serde(rename = "ranMixedContent")]
        #[doc = "True if the page was loaded over HTTPS and ran mixed \\(HTTP\\) content such as scripts."]
        pub ran_mixed_content: bool,
        #[serde(rename = "displayedMixedContent")]
        #[doc = "True if the page was loaded over HTTPS and displayed mixed \\(HTTP\\) content such as images."]
        pub displayed_mixed_content: bool,
        #[serde(rename = "containedMixedForm")]
        #[doc = "True if the page was loaded over HTTPS and contained a form targeting an insecure url."]
        pub contained_mixed_form: bool,
        #[serde(rename = "ranContentWithCertErrors")]
        #[doc = "True if the page was loaded over HTTPS without certificate errors, and ran content such as scripts that were loaded with certificate errors."]
        pub ran_content_with_cert_errors: bool,
        #[serde(rename = "displayedContentWithCertErrors")]
        #[doc = "True if the page was loaded over HTTPS without certificate errors, and displayed content such as images that were loaded with certificate errors."]
        pub displayed_content_with_cert_errors: bool,
        #[serde(rename = "ranInsecureContentStyle")]
        #[doc = "Security state representing a page that ran insecure content."]
        pub ran_insecure_content_style: ::proto::security::SecurityState,
        #[serde(rename = "displayedInsecureContentStyle")]
        #[doc = "Security state representing a page that displayed insecure content."]
        pub displayed_insecure_content_style: ::proto::security::SecurityState,
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> The action to take when a certificate error occurs. continue will continue processing the request and cancel will cancel the request."]
    pub enum CertificateErrorAction {
        #[serde(rename = "continue")]
        #[doc = "Represented as `\"continue\"`."]
        Continue,
        #[serde(rename = "cancel")]
        #[doc = "Represented as `\"cancel\"`."]
        Cancel,
    }
    impl CertificateErrorAction {
        pub const ENUM_VALUES: &'static [CertificateErrorAction] =
            &[
                CertificateErrorAction::Continue,
                CertificateErrorAction::Cancel,
            ];
        pub const STR_VALUES: &'static [&'static str] = &["continue", "cancel"];
    }
    impl ::std::str::FromStr for CertificateErrorAction {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "continue" => Ok(CertificateErrorAction::Continue),
                "cancel" => Ok(CertificateErrorAction::Cancel),
                _ => Err(::proto::ParseEnumError {
                    expected: CertificateErrorAction::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for CertificateErrorAction {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    CertificateErrorAction::Continue => "continue",
                    CertificateErrorAction::Cancel => "cancel",
                }
            )
        }
    }
}
#[doc = "Network domain allows tracking network activities of the page. It exposes information about http, file, data and other requests and responses, their headers, bodies, timing, etc.\n\n# Network\n\n## Commands\n\n- [`Network.enable`](struct.EnableCommand.html)\n\n  Enables network tracking, network events will now be delivered to the client.\n- [`Network.disable`](struct.DisableCommand.html)\n\n  Disables network tracking, prevents network events from being sent to the client.\n- [`Network.setUserAgentOverride`](struct.SetUserAgentOverrideCommand.html)\n\n  Allows overriding user agent with the given string.\n- [`Network.setExtraHTTPHeaders`](struct.SetExtraHttpHeadersCommand.html)\n\n  Specifies whether to always send extra HTTP headers with the requests from this page.\n- [`Network.getResponseBody`](struct.GetResponseBodyCommand.html)\n\n  Returns content served for the given request.\n- [`Network.setBlockedURLs`](struct.SetBlockedUrLsCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Blocks URLs from loading.\n- [`Network.replayXHR`](struct.ReplayXhrCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  This method sends a new XMLHttpRequest which is identical to the original one. The following parameters should be identical: method, url, async, request body, extra headers, withCredentials attribute, user, password.\n- [`Network.canClearBrowserCache`](struct.CanClearBrowserCacheCommand.html)\n\n  Tells whether clearing browser cache is supported.\n- [`Network.clearBrowserCache`](struct.ClearBrowserCacheCommand.html)\n\n  Clears browser cache.\n- [`Network.canClearBrowserCookies`](struct.CanClearBrowserCookiesCommand.html)\n\n  Tells whether clearing browser cookies is supported.\n- [`Network.clearBrowserCookies`](struct.ClearBrowserCookiesCommand.html)\n\n  Clears browser cookies.\n- [`Network.getCookies`](struct.GetCookiesCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns all browser cookies for the current URL. Depending on the backend support, will return detailed cookie information in the <code>cookies</code> field.\n- [`Network.getAllCookies`](struct.GetAllCookiesCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns all browser cookies. Depending on the backend support, will return detailed cookie information in the <code>cookies</code> field.\n- [`Network.deleteCookie`](struct.DeleteCookieCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Deletes browser cookie with given name, domain and path.\n- [`Network.setCookie`](struct.SetCookieCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Sets a cookie with the given cookie data; may overwrite equivalent cookies if they exist.\n- [`Network.canEmulateNetworkConditions`](struct.CanEmulateNetworkConditionsCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Tells whether emulation of network conditions is supported.\n- [`Network.emulateNetworkConditions`](struct.EmulateNetworkConditionsCommand.html)\n\n  Activates emulation of network conditions.\n- [`Network.setCacheDisabled`](struct.SetCacheDisabledCommand.html)\n\n  Toggles ignoring cache for each request. If <code>true</code>, cache will not be used.\n- [`Network.setBypassServiceWorker`](struct.SetBypassServiceWorkerCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Toggles ignoring of service worker for each request.\n- [`Network.setDataSizeLimitsForTest`](struct.SetDataSizeLimitsForTestCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  For testing.\n- [`Network.getCertificate`](struct.GetCertificateCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns the DER-encoded certificate.\n- [`Network.setRequestInterceptionEnabled`](struct.SetRequestInterceptionEnabledCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`Network.continueInterceptedRequest`](struct.ContinueInterceptedRequestCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Response to Network.requestIntercepted which either modifies the request to continue with any modifications, or blocks it, or completes it with the provided response bytes. If a network fetch occurs as a result which encounters a redirect an additional Network.requestIntercepted event will be sent with the same InterceptionId.\n\n## Events\n\n- [`Network.resourceChangedPriority`](struct.ResourceChangedPriorityEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Fired when resource loading priority is changed\n- [`Network.requestWillBeSent`](struct.RequestWillBeSentEvent.html)\n\n  Fired when page is about to send HTTP request.\n- [`Network.requestServedFromCache`](struct.RequestServedFromCacheEvent.html)\n\n  Fired if request ended up loading from cache.\n- [`Network.responseReceived`](struct.ResponseReceivedEvent.html)\n\n  Fired when HTTP response is available.\n- [`Network.dataReceived`](struct.DataReceivedEvent.html)\n\n  Fired when data chunk was received over the network.\n- [`Network.loadingFinished`](struct.LoadingFinishedEvent.html)\n\n  Fired when HTTP request has finished loading.\n- [`Network.loadingFailed`](struct.LoadingFailedEvent.html)\n\n  Fired when HTTP request has failed to load.\n- [`Network.webSocketWillSendHandshakeRequest`](struct.WebSocketWillSendHandshakeRequestEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Fired when WebSocket is about to initiate handshake.\n- [`Network.webSocketHandshakeResponseReceived`](struct.WebSocketHandshakeResponseReceivedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Fired when WebSocket handshake response becomes available.\n- [`Network.webSocketCreated`](struct.WebSocketCreatedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Fired upon WebSocket creation.\n- [`Network.webSocketClosed`](struct.WebSocketClosedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Fired when WebSocket is closed.\n- [`Network.webSocketFrameReceived`](struct.WebSocketFrameReceivedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Fired when WebSocket frame is received.\n- [`Network.webSocketFrameError`](struct.WebSocketFrameErrorEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Fired when WebSocket frame error occurs.\n- [`Network.webSocketFrameSent`](struct.WebSocketFrameSentEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Fired when WebSocket frame is sent.\n- [`Network.eventSourceMessageReceived`](struct.EventSourceMessageReceivedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Fired when EventSource message is received.\n- [`Network.requestIntercepted`](struct.RequestInterceptedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Details of an intercepted HTTP request, which must be either allowed, blocked, modified or mocked.\n\n##Types\n\n- [`LoaderId`](type.LoaderId.html)\n\n  Unique loader identifier.\n- [`RequestId`](type.RequestId.html)\n\n  Unique request identifier.\n- [`InterceptionId`](type.InterceptionId.html)\n\n  Unique intercepted request identifier.\n- [`ErrorReason`](enum.ErrorReason.html)\n\n  Network level fetch failure reason.\n- [`TimeSinceEpoch`](type.TimeSinceEpoch.html)\n\n  UTC time in seconds, counted from January 1, 1970.\n- [`MonotonicTime`](type.MonotonicTime.html)\n\n  Monotonically increasing time in seconds since an arbitrary point in the past.\n- [`Headers`](struct.Headers.html)\n\n  Request / response headers as keys / values of JSON object.\n- [`ConnectionType`](enum.ConnectionType.html)\n\n  Loading priority of a resource request.\n- [`CookieSameSite`](enum.CookieSameSite.html)\n\n  Represents the cookie's 'SameSite' status: https://tools.ietf.org/html/draft-west-first-party-cookies\n- [`ResourceTiming`](struct.ResourceTiming.html)\n\n  Timing information for the request.\n- [`ResourcePriority`](enum.ResourcePriority.html)\n\n  Loading priority of a resource request.\n- [`Request`](struct.Request.html)\n\n  HTTP request data.\n- [`SignedCertificateTimestamp`](struct.SignedCertificateTimestamp.html)\n\n  Details of a signed certificate timestamp \\(SCT\\).\n- [`SecurityDetails`](struct.SecurityDetails.html)\n\n  Security details about a request.\n- [`BlockedReason`](enum.BlockedReason.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  The reason why request was blocked.\n- [`Response`](struct.Response.html)\n\n  HTTP response data.\n- [`WebSocketRequest`](struct.WebSocketRequest.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  WebSocket request data.\n- [`WebSocketResponse`](struct.WebSocketResponse.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  WebSocket response data.\n- [`WebSocketFrame`](struct.WebSocketFrame.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  WebSocket frame data.\n- [`CachedResource`](struct.CachedResource.html)\n\n  Information about the cached resource.\n- [`Initiator`](struct.Initiator.html)\n\n  Information about the request initiator.\n- [`Cookie`](struct.Cookie.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Cookie object\n- [`AuthChallenge`](struct.AuthChallenge.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Authorization challenge for HTTP status code 401 or 407.\n- [`AuthChallengeResponse`](struct.AuthChallengeResponse.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Response to an AuthChallenge.\n"]
pub mod network {
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Enables network tracking, network events will now be delivered to the client.\n\n# Command `Network.enable`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Command Struct:* [`cdp::proto::network::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::proto::network::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableCommand {
        #[serde(rename = "maxTotalBufferSize", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Buffer size in bytes to use when preserving network payloads \\(XHRs, etc\\)."]
        pub max_total_buffer_size: Option<i32>,
        #[serde(rename = "maxResourceBufferSize", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Per-resource buffer size in bytes to use when preserving network payloads \\(XHRs, etc\\)."]
        pub max_resource_buffer_size: Option<i32>,
    }
    impl ::traits::SerializeCdpCommand for EnableCommand {
        fn command_name(&self) -> &str {
            "Network.enable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for EnableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.enable" {
                Ok(
                    <EnableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Enables network tracking, network events will now be delivered to the client.\n\n# Command `Network.enable`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Command Struct:* [`cdp::proto::network::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::proto::network::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableResponse;
    impl ::serde::Serialize for EnableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for EnableCommand {
        type Response = EnableResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for EnableResponse {
        type Command = EnableCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Disables network tracking, prevents network events from being sent to the client.\n\n# Command `Network.disable`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Command Struct:* [`cdp::proto::network::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::proto::network::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableCommand;
    impl ::serde::Serialize for DisableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for DisableCommand {
        fn command_name(&self) -> &str {
            "Network.disable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for DisableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.disable" {
                Ok(
                    <DisableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Disables network tracking, prevents network events from being sent to the client.\n\n# Command `Network.disable`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Command Struct:* [`cdp::proto::network::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::proto::network::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableResponse;
    impl ::serde::Serialize for DisableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for DisableCommand {
        type Response = DisableResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for DisableResponse {
        type Command = DisableCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Allows overriding user agent with the given string.\n\n# Command `Network.setUserAgentOverride`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Command Struct:* [`cdp::proto::network::SetUserAgentOverrideCommand`](struct.SetUserAgentOverrideCommand.html)  \n*Response Struct:* [`cdp::proto::network::SetUserAgentOverrideResponse`](struct.SetUserAgentOverrideResponse.html)"]
    pub struct SetUserAgentOverrideCommand<'a> {
        #[serde(rename = "userAgent")]
        #[doc = "User agent to use."]
        pub user_agent: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpCommand for SetUserAgentOverrideCommand<'a> {
        fn command_name(&self) -> &str {
            "Network.setUserAgentOverride"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for SetUserAgentOverrideCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.setUserAgentOverride" {
                Ok ( < SetUserAgentOverrideCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Allows overriding user agent with the given string.\n\n# Command `Network.setUserAgentOverride`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Command Struct:* [`cdp::proto::network::SetUserAgentOverrideCommand`](struct.SetUserAgentOverrideCommand.html)  \n*Response Struct:* [`cdp::proto::network::SetUserAgentOverrideResponse`](struct.SetUserAgentOverrideResponse.html)"]
    pub struct SetUserAgentOverrideResponse;
    impl ::serde::Serialize for SetUserAgentOverrideResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetUserAgentOverrideResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetUserAgentOverrideResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetUserAgentOverrideCommand<'a> {
        type Response = SetUserAgentOverrideResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetUserAgentOverrideResponse {
        type Command = SetUserAgentOverrideCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Specifies whether to always send extra HTTP headers with the requests from this page.\n\n# Command `Network.setExtraHTTPHeaders`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Command Struct:* [`cdp::proto::network::SetExtraHttpHeadersCommand`](struct.SetExtraHttpHeadersCommand.html)  \n*Response Struct:* [`cdp::proto::network::SetExtraHttpHeadersResponse`](struct.SetExtraHttpHeadersResponse.html)"]
    pub struct SetExtraHttpHeadersCommand {
        #[serde(rename = "headers")]
        #[doc = "Map with extra HTTP headers."]
        pub headers: ::proto::network::Headers,
    }
    impl ::traits::SerializeCdpCommand for SetExtraHttpHeadersCommand {
        fn command_name(&self) -> &str {
            "Network.setExtraHTTPHeaders"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for SetExtraHttpHeadersCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.setExtraHTTPHeaders" {
                Ok ( < SetExtraHttpHeadersCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Specifies whether to always send extra HTTP headers with the requests from this page.\n\n# Command `Network.setExtraHTTPHeaders`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Command Struct:* [`cdp::proto::network::SetExtraHttpHeadersCommand`](struct.SetExtraHttpHeadersCommand.html)  \n*Response Struct:* [`cdp::proto::network::SetExtraHttpHeadersResponse`](struct.SetExtraHttpHeadersResponse.html)"]
    pub struct SetExtraHttpHeadersResponse;
    impl ::serde::Serialize for SetExtraHttpHeadersResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetExtraHttpHeadersResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetExtraHttpHeadersResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetExtraHttpHeadersCommand {
        type Response = SetExtraHttpHeadersResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetExtraHttpHeadersResponse {
        type Command = SetExtraHttpHeadersCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Returns content served for the given request.\n\n# Command `Network.getResponseBody`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Command Struct:* [`cdp::proto::network::GetResponseBodyCommand`](struct.GetResponseBodyCommand.html)  \n*Response Struct:* [`cdp::proto::network::GetResponseBodyResponse`](struct.GetResponseBodyResponse.html)"]
    pub struct GetResponseBodyCommand<'a> {
        #[serde(rename = "requestId")]
        #[doc = "Identifier of the network request to get content for."]
        pub request_id: ::proto::network::RequestId<'a>,
    }
    impl<'a> ::traits::SerializeCdpCommand for GetResponseBodyCommand<'a> {
        fn command_name(&self) -> &str {
            "Network.getResponseBody"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for GetResponseBodyCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.getResponseBody" {
                Ok(
                    <GetResponseBodyCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Returns content served for the given request.\n\n# Command `Network.getResponseBody`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Command Struct:* [`cdp::proto::network::GetResponseBodyCommand`](struct.GetResponseBodyCommand.html)  \n*Response Struct:* [`cdp::proto::network::GetResponseBodyResponse`](struct.GetResponseBodyResponse.html)"]
    pub struct GetResponseBodyResponse<'a> {
        #[serde(rename = "body")]
        #[doc = "Response body."]
        pub body: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "base64Encoded")]
        #[doc = "True, if content was sent as base64."]
        pub base_64_encoded: bool,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for GetResponseBodyCommand<'a> {
        type Response = GetResponseBodyResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for GetResponseBodyResponse<'a> {
        type Command = GetResponseBodyCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Blocks URLs from loading.\n\n# Command `Network.setBlockedURLs`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Command Struct:* [`cdp::proto::network::SetBlockedUrLsCommand`](struct.SetBlockedUrLsCommand.html)  \n*Response Struct:* [`cdp::proto::network::SetBlockedUrLsResponse`](struct.SetBlockedUrLsResponse.html)"]
    pub struct SetBlockedUrLsCommand<'a> {
        #[serde(rename = "urls")]
        #[doc = "URL patterns to block. Wildcards \\('\\*'\\) are allowed."]
        pub urls: Vec<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::traits::SerializeCdpCommand for SetBlockedUrLsCommand<'a> {
        fn command_name(&self) -> &str {
            "Network.setBlockedURLs"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for SetBlockedUrLsCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.setBlockedURLs" {
                Ok(
                    <SetBlockedUrLsCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Blocks URLs from loading.\n\n# Command `Network.setBlockedURLs`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Command Struct:* [`cdp::proto::network::SetBlockedUrLsCommand`](struct.SetBlockedUrLsCommand.html)  \n*Response Struct:* [`cdp::proto::network::SetBlockedUrLsResponse`](struct.SetBlockedUrLsResponse.html)"]
    pub struct SetBlockedUrLsResponse;
    impl ::serde::Serialize for SetBlockedUrLsResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetBlockedUrLsResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetBlockedUrLsResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetBlockedUrLsCommand<'a> {
        type Response = SetBlockedUrLsResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetBlockedUrLsResponse {
        type Command = SetBlockedUrLsCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> This method sends a new XMLHttpRequest which is identical to the original one. The following parameters should be identical: method, url, async, request body, extra headers, withCredentials attribute, user, password.\n\n# Command `Network.replayXHR`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Command Struct:* [`cdp::proto::network::ReplayXhrCommand`](struct.ReplayXhrCommand.html)  \n*Response Struct:* [`cdp::proto::network::ReplayXhrResponse`](struct.ReplayXhrResponse.html)"]
    pub struct ReplayXhrCommand<'a> {
        #[serde(rename = "requestId")]
        #[doc = "Identifier of XHR to replay."]
        pub request_id: ::proto::network::RequestId<'a>,
    }
    impl<'a> ::traits::SerializeCdpCommand for ReplayXhrCommand<'a> {
        fn command_name(&self) -> &str {
            "Network.replayXHR"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for ReplayXhrCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.replayXHR" {
                Ok(
                    <ReplayXhrCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> This method sends a new XMLHttpRequest which is identical to the original one. The following parameters should be identical: method, url, async, request body, extra headers, withCredentials attribute, user, password.\n\n# Command `Network.replayXHR`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Command Struct:* [`cdp::proto::network::ReplayXhrCommand`](struct.ReplayXhrCommand.html)  \n*Response Struct:* [`cdp::proto::network::ReplayXhrResponse`](struct.ReplayXhrResponse.html)"]
    pub struct ReplayXhrResponse;
    impl ::serde::Serialize for ReplayXhrResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ReplayXhrResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ReplayXhrResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for ReplayXhrCommand<'a> {
        type Response = ReplayXhrResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for ReplayXhrResponse {
        type Command = ReplayXhrCommand<'a>;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Tells whether clearing browser cache is supported.\n\n# Command `Network.canClearBrowserCache`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Command Struct:* [`cdp::proto::network::CanClearBrowserCacheCommand`](struct.CanClearBrowserCacheCommand.html)  \n*Response Struct:* [`cdp::proto::network::CanClearBrowserCacheResponse`](struct.CanClearBrowserCacheResponse.html)"]
    pub struct CanClearBrowserCacheCommand;
    impl ::serde::Serialize for CanClearBrowserCacheCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CanClearBrowserCacheCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| CanClearBrowserCacheCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for CanClearBrowserCacheCommand {
        fn command_name(&self) -> &str {
            "Network.canClearBrowserCache"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for CanClearBrowserCacheCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.canClearBrowserCache" {
                Ok ( < CanClearBrowserCacheCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Tells whether clearing browser cache is supported.\n\n# Command `Network.canClearBrowserCache`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Command Struct:* [`cdp::proto::network::CanClearBrowserCacheCommand`](struct.CanClearBrowserCacheCommand.html)  \n*Response Struct:* [`cdp::proto::network::CanClearBrowserCacheResponse`](struct.CanClearBrowserCacheResponse.html)"]
    pub struct CanClearBrowserCacheResponse {
        #[serde(rename = "result")]
        #[doc = "True if browser cache can be cleared."]
        pub result: bool,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for CanClearBrowserCacheCommand {
        type Response = CanClearBrowserCacheResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for CanClearBrowserCacheResponse {
        type Command = CanClearBrowserCacheCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Clears browser cache.\n\n# Command `Network.clearBrowserCache`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Command Struct:* [`cdp::proto::network::ClearBrowserCacheCommand`](struct.ClearBrowserCacheCommand.html)  \n*Response Struct:* [`cdp::proto::network::ClearBrowserCacheResponse`](struct.ClearBrowserCacheResponse.html)"]
    pub struct ClearBrowserCacheCommand;
    impl ::serde::Serialize for ClearBrowserCacheCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ClearBrowserCacheCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ClearBrowserCacheCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for ClearBrowserCacheCommand {
        fn command_name(&self) -> &str {
            "Network.clearBrowserCache"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for ClearBrowserCacheCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.clearBrowserCache" {
                Ok ( < ClearBrowserCacheCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Clears browser cache.\n\n# Command `Network.clearBrowserCache`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Command Struct:* [`cdp::proto::network::ClearBrowserCacheCommand`](struct.ClearBrowserCacheCommand.html)  \n*Response Struct:* [`cdp::proto::network::ClearBrowserCacheResponse`](struct.ClearBrowserCacheResponse.html)"]
    pub struct ClearBrowserCacheResponse;
    impl ::serde::Serialize for ClearBrowserCacheResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ClearBrowserCacheResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ClearBrowserCacheResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for ClearBrowserCacheCommand {
        type Response = ClearBrowserCacheResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for ClearBrowserCacheResponse {
        type Command = ClearBrowserCacheCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Tells whether clearing browser cookies is supported.\n\n# Command `Network.canClearBrowserCookies`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Command Struct:* [`cdp::proto::network::CanClearBrowserCookiesCommand`](struct.CanClearBrowserCookiesCommand.html)  \n*Response Struct:* [`cdp::proto::network::CanClearBrowserCookiesResponse`](struct.CanClearBrowserCookiesResponse.html)"]
    pub struct CanClearBrowserCookiesCommand;
    impl ::serde::Serialize for CanClearBrowserCookiesCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CanClearBrowserCookiesCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| CanClearBrowserCookiesCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for CanClearBrowserCookiesCommand {
        fn command_name(&self) -> &str {
            "Network.canClearBrowserCookies"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for CanClearBrowserCookiesCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.canClearBrowserCookies" {
                Ok ( < CanClearBrowserCookiesCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Tells whether clearing browser cookies is supported.\n\n# Command `Network.canClearBrowserCookies`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Command Struct:* [`cdp::proto::network::CanClearBrowserCookiesCommand`](struct.CanClearBrowserCookiesCommand.html)  \n*Response Struct:* [`cdp::proto::network::CanClearBrowserCookiesResponse`](struct.CanClearBrowserCookiesResponse.html)"]
    pub struct CanClearBrowserCookiesResponse {
        #[serde(rename = "result")]
        #[doc = "True if browser cookies can be cleared."]
        pub result: bool,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for CanClearBrowserCookiesCommand {
        type Response = CanClearBrowserCookiesResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for CanClearBrowserCookiesResponse {
        type Command = CanClearBrowserCookiesCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Clears browser cookies.\n\n# Command `Network.clearBrowserCookies`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Command Struct:* [`cdp::proto::network::ClearBrowserCookiesCommand`](struct.ClearBrowserCookiesCommand.html)  \n*Response Struct:* [`cdp::proto::network::ClearBrowserCookiesResponse`](struct.ClearBrowserCookiesResponse.html)"]
    pub struct ClearBrowserCookiesCommand;
    impl ::serde::Serialize for ClearBrowserCookiesCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ClearBrowserCookiesCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ClearBrowserCookiesCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for ClearBrowserCookiesCommand {
        fn command_name(&self) -> &str {
            "Network.clearBrowserCookies"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for ClearBrowserCookiesCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.clearBrowserCookies" {
                Ok ( < ClearBrowserCookiesCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Clears browser cookies.\n\n# Command `Network.clearBrowserCookies`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Command Struct:* [`cdp::proto::network::ClearBrowserCookiesCommand`](struct.ClearBrowserCookiesCommand.html)  \n*Response Struct:* [`cdp::proto::network::ClearBrowserCookiesResponse`](struct.ClearBrowserCookiesResponse.html)"]
    pub struct ClearBrowserCookiesResponse;
    impl ::serde::Serialize for ClearBrowserCookiesResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ClearBrowserCookiesResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ClearBrowserCookiesResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for ClearBrowserCookiesCommand {
        type Response = ClearBrowserCookiesResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for ClearBrowserCookiesResponse {
        type Command = ClearBrowserCookiesCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns all browser cookies for the current URL. Depending on the backend support, will return detailed cookie information in the <code>cookies</code> field.\n\n# Command `Network.getCookies`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Command Struct:* [`cdp::proto::network::GetCookiesCommand`](struct.GetCookiesCommand.html)  \n*Response Struct:* [`cdp::proto::network::GetCookiesResponse`](struct.GetCookiesResponse.html)"]
    pub struct GetCookiesCommand<'a> {
        #[serde(rename = "urls", skip_serializing_if = "Option::is_none")]
        #[doc = "The list of URLs for which applicable cookies will be fetched"]
        pub urls: Option<Vec<::std::borrow::Cow<'a, str>>>,
    }
    impl<'a> ::traits::SerializeCdpCommand for GetCookiesCommand<'a> {
        fn command_name(&self) -> &str {
            "Network.getCookies"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for GetCookiesCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.getCookies" {
                Ok(
                    <GetCookiesCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns all browser cookies for the current URL. Depending on the backend support, will return detailed cookie information in the <code>cookies</code> field.\n\n# Command `Network.getCookies`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Command Struct:* [`cdp::proto::network::GetCookiesCommand`](struct.GetCookiesCommand.html)  \n*Response Struct:* [`cdp::proto::network::GetCookiesResponse`](struct.GetCookiesResponse.html)"]
    pub struct GetCookiesResponse<'a> {
        #[serde(rename = "cookies")]
        #[doc = "Array of cookie objects."]
        pub cookies: Vec<::proto::network::Cookie<'a>>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for GetCookiesCommand<'a> {
        type Response = GetCookiesResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for GetCookiesResponse<'a> {
        type Command = GetCookiesCommand<'a>;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns all browser cookies. Depending on the backend support, will return detailed cookie information in the <code>cookies</code> field.\n\n# Command `Network.getAllCookies`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Command Struct:* [`cdp::proto::network::GetAllCookiesCommand`](struct.GetAllCookiesCommand.html)  \n*Response Struct:* [`cdp::proto::network::GetAllCookiesResponse`](struct.GetAllCookiesResponse.html)"]
    pub struct GetAllCookiesCommand;
    impl ::serde::Serialize for GetAllCookiesCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetAllCookiesCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| GetAllCookiesCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for GetAllCookiesCommand {
        fn command_name(&self) -> &str {
            "Network.getAllCookies"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for GetAllCookiesCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.getAllCookies" {
                Ok(
                    <GetAllCookiesCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns all browser cookies. Depending on the backend support, will return detailed cookie information in the <code>cookies</code> field.\n\n# Command `Network.getAllCookies`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Command Struct:* [`cdp::proto::network::GetAllCookiesCommand`](struct.GetAllCookiesCommand.html)  \n*Response Struct:* [`cdp::proto::network::GetAllCookiesResponse`](struct.GetAllCookiesResponse.html)"]
    pub struct GetAllCookiesResponse<'a> {
        #[serde(rename = "cookies")]
        #[doc = "Array of cookie objects."]
        pub cookies: Vec<::proto::network::Cookie<'a>>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for GetAllCookiesCommand {
        type Response = GetAllCookiesResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for GetAllCookiesResponse<'a> {
        type Command = GetAllCookiesCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Deletes browser cookie with given name, domain and path.\n\n# Command `Network.deleteCookie`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Command Struct:* [`cdp::proto::network::DeleteCookieCommand`](struct.DeleteCookieCommand.html)  \n*Response Struct:* [`cdp::proto::network::DeleteCookieResponse`](struct.DeleteCookieResponse.html)"]
    pub struct DeleteCookieCommand<'a> {
        #[serde(rename = "cookieName")]
        #[doc = "Name of the cookie to remove."]
        pub cookie_name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "url")]
        #[doc = "URL to match cooke domain and path."]
        pub url: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpCommand for DeleteCookieCommand<'a> {
        fn command_name(&self) -> &str {
            "Network.deleteCookie"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for DeleteCookieCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.deleteCookie" {
                Ok(
                    <DeleteCookieCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Deletes browser cookie with given name, domain and path.\n\n# Command `Network.deleteCookie`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Command Struct:* [`cdp::proto::network::DeleteCookieCommand`](struct.DeleteCookieCommand.html)  \n*Response Struct:* [`cdp::proto::network::DeleteCookieResponse`](struct.DeleteCookieResponse.html)"]
    pub struct DeleteCookieResponse;
    impl ::serde::Serialize for DeleteCookieResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DeleteCookieResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DeleteCookieResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for DeleteCookieCommand<'a> {
        type Response = DeleteCookieResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for DeleteCookieResponse {
        type Command = DeleteCookieCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Sets a cookie with the given cookie data; may overwrite equivalent cookies if they exist.\n\n# Command `Network.setCookie`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Command Struct:* [`cdp::proto::network::SetCookieCommand`](struct.SetCookieCommand.html)  \n*Response Struct:* [`cdp::proto::network::SetCookieResponse`](struct.SetCookieResponse.html)"]
    pub struct SetCookieCommand<'a> {
        #[serde(rename = "url")]
        #[doc = "The request-URI to associate with the setting of the cookie. This value can affect the default domain and path values of the created cookie."]
        pub url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "name")]
        #[doc = "The name of the cookie."]
        pub name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "value")]
        #[doc = "The value of the cookie."]
        pub value: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "domain", skip_serializing_if = "Option::is_none")]
        #[doc = "If omitted, the cookie becomes a host-only cookie."]
        pub domain: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "path", skip_serializing_if = "Option::is_none")]
        #[doc = "Defaults to the path portion of the url parameter."]
        pub path: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "secure", skip_serializing_if = "Option::is_none")]
        #[doc = "Defaults ot false."]
        pub secure: Option<bool>,
        #[serde(rename = "httpOnly", skip_serializing_if = "Option::is_none")]
        #[doc = "Defaults to false."]
        pub http_only: Option<bool>,
        #[serde(rename = "sameSite", skip_serializing_if = "Option::is_none")]
        #[doc = "Defaults to browser default behavior."]
        pub same_site: Option<::proto::network::CookieSameSite>,
        #[serde(rename = "expirationDate", skip_serializing_if = "Option::is_none")]
        #[doc = "If omitted, the cookie becomes a session cookie."]
        pub expiration_date: Option<::proto::network::TimeSinceEpoch>,
    }
    impl<'a> ::traits::SerializeCdpCommand for SetCookieCommand<'a> {
        fn command_name(&self) -> &str {
            "Network.setCookie"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for SetCookieCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.setCookie" {
                Ok(
                    <SetCookieCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Sets a cookie with the given cookie data; may overwrite equivalent cookies if they exist.\n\n# Command `Network.setCookie`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Command Struct:* [`cdp::proto::network::SetCookieCommand`](struct.SetCookieCommand.html)  \n*Response Struct:* [`cdp::proto::network::SetCookieResponse`](struct.SetCookieResponse.html)"]
    pub struct SetCookieResponse {
        #[serde(rename = "success")]
        #[doc = "True if successfully set cookie."]
        pub success: bool,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetCookieCommand<'a> {
        type Response = SetCookieResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetCookieResponse {
        type Command = SetCookieCommand<'a>;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Tells whether emulation of network conditions is supported.\n\n# Command `Network.canEmulateNetworkConditions`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Command Struct:* [`cdp::proto::network::CanEmulateNetworkConditionsCommand`](struct.CanEmulateNetworkConditionsCommand.html)  \n*Response Struct:* [`cdp::proto::network::CanEmulateNetworkConditionsResponse`](struct.CanEmulateNetworkConditionsResponse.html)"]
    pub struct CanEmulateNetworkConditionsCommand;
    impl ::serde::Serialize for CanEmulateNetworkConditionsCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CanEmulateNetworkConditionsCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| CanEmulateNetworkConditionsCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for CanEmulateNetworkConditionsCommand {
        fn command_name(&self) -> &str {
            "Network.canEmulateNetworkConditions"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for CanEmulateNetworkConditionsCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.canEmulateNetworkConditions" {
                Ok ( < CanEmulateNetworkConditionsCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Tells whether emulation of network conditions is supported.\n\n# Command `Network.canEmulateNetworkConditions`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Command Struct:* [`cdp::proto::network::CanEmulateNetworkConditionsCommand`](struct.CanEmulateNetworkConditionsCommand.html)  \n*Response Struct:* [`cdp::proto::network::CanEmulateNetworkConditionsResponse`](struct.CanEmulateNetworkConditionsResponse.html)"]
    pub struct CanEmulateNetworkConditionsResponse {
        #[serde(rename = "result")]
        #[doc = "True if emulation of network conditions is supported."]
        pub result: bool,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for CanEmulateNetworkConditionsCommand {
        type Response = CanEmulateNetworkConditionsResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for CanEmulateNetworkConditionsResponse {
        type Command = CanEmulateNetworkConditionsCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Activates emulation of network conditions.\n\n# Command `Network.emulateNetworkConditions`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Command Struct:* [`cdp::proto::network::EmulateNetworkConditionsCommand`](struct.EmulateNetworkConditionsCommand.html)  \n*Response Struct:* [`cdp::proto::network::EmulateNetworkConditionsResponse`](struct.EmulateNetworkConditionsResponse.html)"]
    pub struct EmulateNetworkConditionsCommand {
        #[serde(rename = "offline")]
        #[doc = "True to emulate internet disconnection."]
        pub offline: bool,
        #[serde(rename = "latency")]
        #[doc = "Additional latency \\(ms\\)."]
        pub latency: f64,
        #[serde(rename = "downloadThroughput")]
        #[doc = "Maximal aggregated download throughput."]
        pub download_throughput: f64,
        #[serde(rename = "uploadThroughput")]
        #[doc = "Maximal aggregated upload throughput."]
        pub upload_throughput: f64,
        #[serde(rename = "connectionType", skip_serializing_if = "Option::is_none")]
        #[doc = "Connection type if known."]
        pub connection_type: Option<::proto::network::ConnectionType>,
    }
    impl ::traits::SerializeCdpCommand for EmulateNetworkConditionsCommand {
        fn command_name(&self) -> &str {
            "Network.emulateNetworkConditions"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for EmulateNetworkConditionsCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.emulateNetworkConditions" {
                Ok ( < EmulateNetworkConditionsCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Activates emulation of network conditions.\n\n# Command `Network.emulateNetworkConditions`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Command Struct:* [`cdp::proto::network::EmulateNetworkConditionsCommand`](struct.EmulateNetworkConditionsCommand.html)  \n*Response Struct:* [`cdp::proto::network::EmulateNetworkConditionsResponse`](struct.EmulateNetworkConditionsResponse.html)"]
    pub struct EmulateNetworkConditionsResponse;
    impl ::serde::Serialize for EmulateNetworkConditionsResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EmulateNetworkConditionsResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EmulateNetworkConditionsResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for EmulateNetworkConditionsCommand {
        type Response = EmulateNetworkConditionsResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for EmulateNetworkConditionsResponse {
        type Command = EmulateNetworkConditionsCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Toggles ignoring cache for each request. If <code>true</code>, cache will not be used.\n\n# Command `Network.setCacheDisabled`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Command Struct:* [`cdp::proto::network::SetCacheDisabledCommand`](struct.SetCacheDisabledCommand.html)  \n*Response Struct:* [`cdp::proto::network::SetCacheDisabledResponse`](struct.SetCacheDisabledResponse.html)"]
    pub struct SetCacheDisabledCommand {
        #[serde(rename = "cacheDisabled")]
        #[doc = "Cache disabled state."]
        pub cache_disabled: bool,
    }
    impl ::traits::SerializeCdpCommand for SetCacheDisabledCommand {
        fn command_name(&self) -> &str {
            "Network.setCacheDisabled"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for SetCacheDisabledCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.setCacheDisabled" {
                Ok ( < SetCacheDisabledCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Toggles ignoring cache for each request. If <code>true</code>, cache will not be used.\n\n# Command `Network.setCacheDisabled`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Command Struct:* [`cdp::proto::network::SetCacheDisabledCommand`](struct.SetCacheDisabledCommand.html)  \n*Response Struct:* [`cdp::proto::network::SetCacheDisabledResponse`](struct.SetCacheDisabledResponse.html)"]
    pub struct SetCacheDisabledResponse;
    impl ::serde::Serialize for SetCacheDisabledResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetCacheDisabledResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetCacheDisabledResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetCacheDisabledCommand {
        type Response = SetCacheDisabledResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetCacheDisabledResponse {
        type Command = SetCacheDisabledCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Toggles ignoring of service worker for each request.\n\n# Command `Network.setBypassServiceWorker`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Command Struct:* [`cdp::proto::network::SetBypassServiceWorkerCommand`](struct.SetBypassServiceWorkerCommand.html)  \n*Response Struct:* [`cdp::proto::network::SetBypassServiceWorkerResponse`](struct.SetBypassServiceWorkerResponse.html)"]
    pub struct SetBypassServiceWorkerCommand {
        #[serde(rename = "bypass")]
        #[doc = "Bypass service worker and load from network."]
        pub bypass: bool,
    }
    impl ::traits::SerializeCdpCommand for SetBypassServiceWorkerCommand {
        fn command_name(&self) -> &str {
            "Network.setBypassServiceWorker"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for SetBypassServiceWorkerCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.setBypassServiceWorker" {
                Ok ( < SetBypassServiceWorkerCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Toggles ignoring of service worker for each request.\n\n# Command `Network.setBypassServiceWorker`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Command Struct:* [`cdp::proto::network::SetBypassServiceWorkerCommand`](struct.SetBypassServiceWorkerCommand.html)  \n*Response Struct:* [`cdp::proto::network::SetBypassServiceWorkerResponse`](struct.SetBypassServiceWorkerResponse.html)"]
    pub struct SetBypassServiceWorkerResponse;
    impl ::serde::Serialize for SetBypassServiceWorkerResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetBypassServiceWorkerResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetBypassServiceWorkerResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetBypassServiceWorkerCommand {
        type Response = SetBypassServiceWorkerResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetBypassServiceWorkerResponse {
        type Command = SetBypassServiceWorkerCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> For testing.\n\n# Command `Network.setDataSizeLimitsForTest`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Command Struct:* [`cdp::proto::network::SetDataSizeLimitsForTestCommand`](struct.SetDataSizeLimitsForTestCommand.html)  \n*Response Struct:* [`cdp::proto::network::SetDataSizeLimitsForTestResponse`](struct.SetDataSizeLimitsForTestResponse.html)"]
    pub struct SetDataSizeLimitsForTestCommand {
        #[serde(rename = "maxTotalSize")]
        #[doc = "Maximum total buffer size."]
        pub max_total_size: i32,
        #[serde(rename = "maxResourceSize")]
        #[doc = "Maximum per-resource size."]
        pub max_resource_size: i32,
    }
    impl ::traits::SerializeCdpCommand for SetDataSizeLimitsForTestCommand {
        fn command_name(&self) -> &str {
            "Network.setDataSizeLimitsForTest"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for SetDataSizeLimitsForTestCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.setDataSizeLimitsForTest" {
                Ok ( < SetDataSizeLimitsForTestCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> For testing.\n\n# Command `Network.setDataSizeLimitsForTest`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Command Struct:* [`cdp::proto::network::SetDataSizeLimitsForTestCommand`](struct.SetDataSizeLimitsForTestCommand.html)  \n*Response Struct:* [`cdp::proto::network::SetDataSizeLimitsForTestResponse`](struct.SetDataSizeLimitsForTestResponse.html)"]
    pub struct SetDataSizeLimitsForTestResponse;
    impl ::serde::Serialize for SetDataSizeLimitsForTestResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetDataSizeLimitsForTestResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetDataSizeLimitsForTestResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetDataSizeLimitsForTestCommand {
        type Response = SetDataSizeLimitsForTestResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetDataSizeLimitsForTestResponse {
        type Command = SetDataSizeLimitsForTestCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns the DER-encoded certificate.\n\n# Command `Network.getCertificate`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Command Struct:* [`cdp::proto::network::GetCertificateCommand`](struct.GetCertificateCommand.html)  \n*Response Struct:* [`cdp::proto::network::GetCertificateResponse`](struct.GetCertificateResponse.html)"]
    pub struct GetCertificateCommand<'a> {
        #[serde(rename = "origin")]
        #[doc = "Origin to get certificate for."]
        pub origin: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpCommand for GetCertificateCommand<'a> {
        fn command_name(&self) -> &str {
            "Network.getCertificate"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for GetCertificateCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.getCertificate" {
                Ok(
                    <GetCertificateCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns the DER-encoded certificate.\n\n# Command `Network.getCertificate`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Command Struct:* [`cdp::proto::network::GetCertificateCommand`](struct.GetCertificateCommand.html)  \n*Response Struct:* [`cdp::proto::network::GetCertificateResponse`](struct.GetCertificateResponse.html)"]
    pub struct GetCertificateResponse<'a> {
        #[serde(rename = "tableNames")]
        pub table_names: Vec<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for GetCertificateCommand<'a> {
        type Response = GetCertificateResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for GetCertificateResponse<'a> {
        type Command = GetCertificateCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `Network.setRequestInterceptionEnabled`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Command Struct:* [`cdp::proto::network::SetRequestInterceptionEnabledCommand`](struct.SetRequestInterceptionEnabledCommand.html)  \n*Response Struct:* [`cdp::proto::network::SetRequestInterceptionEnabledResponse`](struct.SetRequestInterceptionEnabledResponse.html)"]
    pub struct SetRequestInterceptionEnabledCommand {
        #[serde(rename = "enabled")]
        #[doc = "Whether or not HTTP requests should be intercepted and Network.requestIntercepted events sent."]
        pub enabled: bool,
    }
    impl ::traits::SerializeCdpCommand for SetRequestInterceptionEnabledCommand {
        fn command_name(&self) -> &str {
            "Network.setRequestInterceptionEnabled"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for SetRequestInterceptionEnabledCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.setRequestInterceptionEnabled" {
                Ok ( < SetRequestInterceptionEnabledCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `Network.setRequestInterceptionEnabled`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Command Struct:* [`cdp::proto::network::SetRequestInterceptionEnabledCommand`](struct.SetRequestInterceptionEnabledCommand.html)  \n*Response Struct:* [`cdp::proto::network::SetRequestInterceptionEnabledResponse`](struct.SetRequestInterceptionEnabledResponse.html)"]
    pub struct SetRequestInterceptionEnabledResponse;
    impl ::serde::Serialize for SetRequestInterceptionEnabledResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetRequestInterceptionEnabledResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetRequestInterceptionEnabledResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetRequestInterceptionEnabledCommand {
        type Response = SetRequestInterceptionEnabledResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetRequestInterceptionEnabledResponse {
        type Command = SetRequestInterceptionEnabledCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Response to Network.requestIntercepted which either modifies the request to continue with any modifications, or blocks it, or completes it with the provided response bytes. If a network fetch occurs as a result which encounters a redirect an additional Network.requestIntercepted event will be sent with the same InterceptionId.\n\n# Command `Network.continueInterceptedRequest`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Command Struct:* [`cdp::proto::network::ContinueInterceptedRequestCommand`](struct.ContinueInterceptedRequestCommand.html)  \n*Response Struct:* [`cdp::proto::network::ContinueInterceptedRequestResponse`](struct.ContinueInterceptedRequestResponse.html)"]
    pub struct ContinueInterceptedRequestCommand<'a> {
        #[serde(rename = "interceptionId")]
        pub interception_id: ::proto::network::InterceptionId<'a>,
        #[serde(rename = "errorReason", skip_serializing_if = "Option::is_none")]
        #[doc = "If set this causes the request to fail with the given reason. Must not be set in response to an authChallenge."]
        pub error_reason: Option<::proto::network::ErrorReason>,
        #[serde(rename = "rawResponse", skip_serializing_if = "Option::is_none")]
        #[doc = "If set the requests completes using with the provided base64 encoded raw response, including HTTP status line and headers etc... Must not be set in response to an authChallenge."]
        pub raw_response: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "url", skip_serializing_if = "Option::is_none")]
        #[doc = "If set the request url will be modified in a way that's not observable by page. Must not be set in response to an authChallenge."]
        pub url: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "method", skip_serializing_if = "Option::is_none")]
        #[doc = "If set this allows the request method to be overridden. Must not be set in response to an authChallenge."]
        pub method: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "postData", skip_serializing_if = "Option::is_none")]
        #[doc = "If set this allows postData to be set. Must not be set in response to an authChallenge."]
        pub post_data: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "headers", skip_serializing_if = "Option::is_none")]
        #[doc = "If set this allows the request headers to be changed. Must not be set in response to an authChallenge."]
        pub headers: Option<::proto::network::Headers>,
        #[serde(rename = "authChallengeResponse", skip_serializing_if = "Option::is_none")]
        #[doc = "Response to a requestIntercepted with an authChallenge. Must not be set otherwise."]
        pub auth_challenge_response: Option<::proto::network::AuthChallengeResponse<'a>>,
    }
    impl<'a> ::traits::SerializeCdpCommand for ContinueInterceptedRequestCommand<'a> {
        fn command_name(&self) -> &str {
            "Network.continueInterceptedRequest"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for ContinueInterceptedRequestCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.continueInterceptedRequest" {
                Ok ( < ContinueInterceptedRequestCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Response to Network.requestIntercepted which either modifies the request to continue with any modifications, or blocks it, or completes it with the provided response bytes. If a network fetch occurs as a result which encounters a redirect an additional Network.requestIntercepted event will be sent with the same InterceptionId.\n\n# Command `Network.continueInterceptedRequest`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Command Struct:* [`cdp::proto::network::ContinueInterceptedRequestCommand`](struct.ContinueInterceptedRequestCommand.html)  \n*Response Struct:* [`cdp::proto::network::ContinueInterceptedRequestResponse`](struct.ContinueInterceptedRequestResponse.html)"]
    pub struct ContinueInterceptedRequestResponse;
    impl ::serde::Serialize for ContinueInterceptedRequestResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ContinueInterceptedRequestResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ContinueInterceptedRequestResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for ContinueInterceptedRequestCommand<'a> {
        type Response = ContinueInterceptedRequestResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for ContinueInterceptedRequestResponse {
        type Command = ContinueInterceptedRequestCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Fired when resource loading priority is changed\n\n# Event `Network.resourceChangedPriority`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Event Struct:* [`cdp::proto::network::ResourceChangedPriorityEvent`](struct.ResourceChangedPriorityEvent.html)"]
    pub struct ResourceChangedPriorityEvent<'a> {
        #[serde(rename = "requestId")]
        #[doc = "Request identifier."]
        pub request_id: ::proto::network::RequestId<'a>,
        #[serde(rename = "newPriority")]
        #[doc = "New priority"]
        pub new_priority: ::proto::network::ResourcePriority,
        #[serde(rename = "timestamp")]
        #[doc = "Timestamp."]
        pub timestamp: ::proto::network::MonotonicTime,
    }
    impl<'a> ::traits::SerializeCdpEvent for ResourceChangedPriorityEvent<'a> {
        fn event_name(&self) -> &str {
            "Network.resourceChangedPriority"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for ResourceChangedPriorityEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.resourceChangedPriority" {
                Ok ( < ResourceChangedPriorityEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Fired when page is about to send HTTP request.\n\n# Event `Network.requestWillBeSent`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Event Struct:* [`cdp::proto::network::RequestWillBeSentEvent`](struct.RequestWillBeSentEvent.html)"]
    pub struct RequestWillBeSentEvent<'a> {
        #[serde(rename = "requestId")]
        #[doc = "Request identifier."]
        pub request_id: ::proto::network::RequestId<'a>,
        #[serde(rename = "loaderId")]
        #[doc = "Loader identifier. Empty string if the request is fetched form worker."]
        pub loader_id: ::proto::network::LoaderId<'a>,
        #[serde(rename = "documentURL")]
        #[doc = "URL of the document this request is loaded for."]
        pub document_url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "request")]
        #[doc = "Request data."]
        pub request: ::proto::network::Request<'a>,
        #[serde(rename = "timestamp")]
        #[doc = "Timestamp."]
        pub timestamp: ::proto::network::MonotonicTime,
        #[serde(rename = "wallTime")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Timestamp."]
        pub wall_time: ::proto::network::TimeSinceEpoch,
        #[serde(rename = "initiator")]
        #[doc = "Request initiator."]
        pub initiator: ::proto::network::Initiator<'a>,
        #[serde(rename = "redirectResponse", skip_serializing_if = "Option::is_none")]
        #[doc = "Redirect response data."]
        pub redirect_response: Option<::proto::network::Response<'a>>,
        #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Type of this resource."]
        pub ty: Option<::proto::page::ResourceType>,
        #[serde(rename = "frameId", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Frame identifier."]
        pub frame_id: Option<::proto::page::FrameId<'a>>,
    }
    impl<'a> ::traits::SerializeCdpEvent for RequestWillBeSentEvent<'a> {
        fn event_name(&self) -> &str {
            "Network.requestWillBeSent"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for RequestWillBeSentEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.requestWillBeSent" {
                Ok(
                    <RequestWillBeSentEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Fired if request ended up loading from cache.\n\n# Event `Network.requestServedFromCache`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Event Struct:* [`cdp::proto::network::RequestServedFromCacheEvent`](struct.RequestServedFromCacheEvent.html)"]
    pub struct RequestServedFromCacheEvent<'a> {
        #[serde(rename = "requestId")]
        #[doc = "Request identifier."]
        pub request_id: ::proto::network::RequestId<'a>,
    }
    impl<'a> ::traits::SerializeCdpEvent for RequestServedFromCacheEvent<'a> {
        fn event_name(&self) -> &str {
            "Network.requestServedFromCache"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for RequestServedFromCacheEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.requestServedFromCache" {
                Ok ( < RequestServedFromCacheEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Fired when HTTP response is available.\n\n# Event `Network.responseReceived`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Event Struct:* [`cdp::proto::network::ResponseReceivedEvent`](struct.ResponseReceivedEvent.html)"]
    pub struct ResponseReceivedEvent<'a> {
        #[serde(rename = "requestId")]
        #[doc = "Request identifier."]
        pub request_id: ::proto::network::RequestId<'a>,
        #[serde(rename = "loaderId")]
        #[doc = "Loader identifier. Empty string if the request is fetched form worker."]
        pub loader_id: ::proto::network::LoaderId<'a>,
        #[serde(rename = "timestamp")]
        #[doc = "Timestamp."]
        pub timestamp: ::proto::network::MonotonicTime,
        #[serde(rename = "type")]
        #[doc = "Resource type."]
        pub ty: ::proto::page::ResourceType,
        #[serde(rename = "response")]
        #[doc = "Response data."]
        pub response: ::proto::network::Response<'a>,
        #[serde(rename = "frameId", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Frame identifier."]
        pub frame_id: Option<::proto::page::FrameId<'a>>,
    }
    impl<'a> ::traits::SerializeCdpEvent for ResponseReceivedEvent<'a> {
        fn event_name(&self) -> &str {
            "Network.responseReceived"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for ResponseReceivedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.responseReceived" {
                Ok(
                    <ResponseReceivedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Fired when data chunk was received over the network.\n\n# Event `Network.dataReceived`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Event Struct:* [`cdp::proto::network::DataReceivedEvent`](struct.DataReceivedEvent.html)"]
    pub struct DataReceivedEvent<'a> {
        #[serde(rename = "requestId")]
        #[doc = "Request identifier."]
        pub request_id: ::proto::network::RequestId<'a>,
        #[serde(rename = "timestamp")]
        #[doc = "Timestamp."]
        pub timestamp: ::proto::network::MonotonicTime,
        #[serde(rename = "dataLength")]
        #[doc = "Data chunk length."]
        pub data_length: i32,
        #[serde(rename = "encodedDataLength")]
        #[doc = "Actual bytes received \\(might be less than dataLength for compressed encodings\\)."]
        pub encoded_data_length: i32,
    }
    impl<'a> ::traits::SerializeCdpEvent for DataReceivedEvent<'a> {
        fn event_name(&self) -> &str {
            "Network.dataReceived"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for DataReceivedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.dataReceived" {
                Ok(
                    <DataReceivedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Fired when HTTP request has finished loading.\n\n# Event `Network.loadingFinished`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Event Struct:* [`cdp::proto::network::LoadingFinishedEvent`](struct.LoadingFinishedEvent.html)"]
    pub struct LoadingFinishedEvent<'a> {
        #[serde(rename = "requestId")]
        #[doc = "Request identifier."]
        pub request_id: ::proto::network::RequestId<'a>,
        #[serde(rename = "timestamp")]
        #[doc = "Timestamp."]
        pub timestamp: ::proto::network::MonotonicTime,
        #[serde(rename = "encodedDataLength")]
        #[doc = "Total number of bytes received for this request."]
        pub encoded_data_length: f64,
    }
    impl<'a> ::traits::SerializeCdpEvent for LoadingFinishedEvent<'a> {
        fn event_name(&self) -> &str {
            "Network.loadingFinished"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for LoadingFinishedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.loadingFinished" {
                Ok(
                    <LoadingFinishedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Fired when HTTP request has failed to load.\n\n# Event `Network.loadingFailed`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Event Struct:* [`cdp::proto::network::LoadingFailedEvent`](struct.LoadingFailedEvent.html)"]
    pub struct LoadingFailedEvent<'a> {
        #[serde(rename = "requestId")]
        #[doc = "Request identifier."]
        pub request_id: ::proto::network::RequestId<'a>,
        #[serde(rename = "timestamp")]
        #[doc = "Timestamp."]
        pub timestamp: ::proto::network::MonotonicTime,
        #[serde(rename = "type")]
        #[doc = "Resource type."]
        pub ty: ::proto::page::ResourceType,
        #[serde(rename = "errorText")]
        #[doc = "User friendly error message."]
        pub error_text: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "canceled", skip_serializing_if = "Option::is_none")]
        #[doc = "True if loading was canceled."]
        pub canceled: Option<bool>,
        #[serde(rename = "blockedReason", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> The reason why loading was blocked, if any."]
        pub blocked_reason: Option<::proto::network::BlockedReason>,
    }
    impl<'a> ::traits::SerializeCdpEvent for LoadingFailedEvent<'a> {
        fn event_name(&self) -> &str {
            "Network.loadingFailed"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for LoadingFailedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.loadingFailed" {
                Ok(
                    <LoadingFailedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Fired when WebSocket is about to initiate handshake.\n\n# Event `Network.webSocketWillSendHandshakeRequest`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Event Struct:* [`cdp::proto::network::WebSocketWillSendHandshakeRequestEvent`](struct.WebSocketWillSendHandshakeRequestEvent.html)"]
    pub struct WebSocketWillSendHandshakeRequestEvent<'a> {
        #[serde(rename = "requestId")]
        #[doc = "Request identifier."]
        pub request_id: ::proto::network::RequestId<'a>,
        #[serde(rename = "timestamp")]
        #[doc = "Timestamp."]
        pub timestamp: ::proto::network::MonotonicTime,
        #[serde(rename = "wallTime")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> UTC Timestamp."]
        pub wall_time: ::proto::network::TimeSinceEpoch,
        #[serde(rename = "request")]
        #[doc = "WebSocket request data."]
        pub request: ::proto::network::WebSocketRequest,
    }
    impl<'a> ::traits::SerializeCdpEvent for WebSocketWillSendHandshakeRequestEvent<'a> {
        fn event_name(&self) -> &str {
            "Network.webSocketWillSendHandshakeRequest"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for WebSocketWillSendHandshakeRequestEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.webSocketWillSendHandshakeRequest" {
                Ok ( < WebSocketWillSendHandshakeRequestEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Fired when WebSocket handshake response becomes available.\n\n# Event `Network.webSocketHandshakeResponseReceived`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Event Struct:* [`cdp::proto::network::WebSocketHandshakeResponseReceivedEvent`](struct.WebSocketHandshakeResponseReceivedEvent.html)"]
    pub struct WebSocketHandshakeResponseReceivedEvent<'a> {
        #[serde(rename = "requestId")]
        #[doc = "Request identifier."]
        pub request_id: ::proto::network::RequestId<'a>,
        #[serde(rename = "timestamp")]
        #[doc = "Timestamp."]
        pub timestamp: ::proto::network::MonotonicTime,
        #[serde(rename = "response")]
        #[doc = "WebSocket response data."]
        pub response: ::proto::network::WebSocketResponse<'a>,
    }
    impl<'a> ::traits::SerializeCdpEvent for WebSocketHandshakeResponseReceivedEvent<'a> {
        fn event_name(&self) -> &str {
            "Network.webSocketHandshakeResponseReceived"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for WebSocketHandshakeResponseReceivedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.webSocketHandshakeResponseReceived" {
                Ok ( < WebSocketHandshakeResponseReceivedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Fired upon WebSocket creation.\n\n# Event `Network.webSocketCreated`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Event Struct:* [`cdp::proto::network::WebSocketCreatedEvent`](struct.WebSocketCreatedEvent.html)"]
    pub struct WebSocketCreatedEvent<'a> {
        #[serde(rename = "requestId")]
        #[doc = "Request identifier."]
        pub request_id: ::proto::network::RequestId<'a>,
        #[serde(rename = "url")]
        #[doc = "WebSocket request URL."]
        pub url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "initiator", skip_serializing_if = "Option::is_none")]
        #[doc = "Request initiator."]
        pub initiator: Option<::proto::network::Initiator<'a>>,
    }
    impl<'a> ::traits::SerializeCdpEvent for WebSocketCreatedEvent<'a> {
        fn event_name(&self) -> &str {
            "Network.webSocketCreated"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for WebSocketCreatedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.webSocketCreated" {
                Ok(
                    <WebSocketCreatedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Fired when WebSocket is closed.\n\n# Event `Network.webSocketClosed`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Event Struct:* [`cdp::proto::network::WebSocketClosedEvent`](struct.WebSocketClosedEvent.html)"]
    pub struct WebSocketClosedEvent<'a> {
        #[serde(rename = "requestId")]
        #[doc = "Request identifier."]
        pub request_id: ::proto::network::RequestId<'a>,
        #[serde(rename = "timestamp")]
        #[doc = "Timestamp."]
        pub timestamp: ::proto::network::MonotonicTime,
    }
    impl<'a> ::traits::SerializeCdpEvent for WebSocketClosedEvent<'a> {
        fn event_name(&self) -> &str {
            "Network.webSocketClosed"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for WebSocketClosedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.webSocketClosed" {
                Ok(
                    <WebSocketClosedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Fired when WebSocket frame is received.\n\n# Event `Network.webSocketFrameReceived`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Event Struct:* [`cdp::proto::network::WebSocketFrameReceivedEvent`](struct.WebSocketFrameReceivedEvent.html)"]
    pub struct WebSocketFrameReceivedEvent<'a> {
        #[serde(rename = "requestId")]
        #[doc = "Request identifier."]
        pub request_id: ::proto::network::RequestId<'a>,
        #[serde(rename = "timestamp")]
        #[doc = "Timestamp."]
        pub timestamp: ::proto::network::MonotonicTime,
        #[serde(rename = "response")]
        #[doc = "WebSocket response data."]
        pub response: ::proto::network::WebSocketFrame<'a>,
    }
    impl<'a> ::traits::SerializeCdpEvent for WebSocketFrameReceivedEvent<'a> {
        fn event_name(&self) -> &str {
            "Network.webSocketFrameReceived"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for WebSocketFrameReceivedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.webSocketFrameReceived" {
                Ok ( < WebSocketFrameReceivedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Fired when WebSocket frame error occurs.\n\n# Event `Network.webSocketFrameError`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Event Struct:* [`cdp::proto::network::WebSocketFrameErrorEvent`](struct.WebSocketFrameErrorEvent.html)"]
    pub struct WebSocketFrameErrorEvent<'a> {
        #[serde(rename = "requestId")]
        #[doc = "Request identifier."]
        pub request_id: ::proto::network::RequestId<'a>,
        #[serde(rename = "timestamp")]
        #[doc = "Timestamp."]
        pub timestamp: ::proto::network::MonotonicTime,
        #[serde(rename = "errorMessage")]
        #[doc = "WebSocket frame error message."]
        pub error_message: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpEvent for WebSocketFrameErrorEvent<'a> {
        fn event_name(&self) -> &str {
            "Network.webSocketFrameError"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for WebSocketFrameErrorEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.webSocketFrameError" {
                Ok ( < WebSocketFrameErrorEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Fired when WebSocket frame is sent.\n\n# Event `Network.webSocketFrameSent`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Event Struct:* [`cdp::proto::network::WebSocketFrameSentEvent`](struct.WebSocketFrameSentEvent.html)"]
    pub struct WebSocketFrameSentEvent<'a> {
        #[serde(rename = "requestId")]
        #[doc = "Request identifier."]
        pub request_id: ::proto::network::RequestId<'a>,
        #[serde(rename = "timestamp")]
        #[doc = "Timestamp."]
        pub timestamp: ::proto::network::MonotonicTime,
        #[serde(rename = "response")]
        #[doc = "WebSocket response data."]
        pub response: ::proto::network::WebSocketFrame<'a>,
    }
    impl<'a> ::traits::SerializeCdpEvent for WebSocketFrameSentEvent<'a> {
        fn event_name(&self) -> &str {
            "Network.webSocketFrameSent"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for WebSocketFrameSentEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.webSocketFrameSent" {
                Ok ( < WebSocketFrameSentEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Fired when EventSource message is received.\n\n# Event `Network.eventSourceMessageReceived`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Event Struct:* [`cdp::proto::network::EventSourceMessageReceivedEvent`](struct.EventSourceMessageReceivedEvent.html)"]
    pub struct EventSourceMessageReceivedEvent<'a> {
        #[serde(rename = "requestId")]
        #[doc = "Request identifier."]
        pub request_id: ::proto::network::RequestId<'a>,
        #[serde(rename = "timestamp")]
        #[doc = "Timestamp."]
        pub timestamp: ::proto::network::MonotonicTime,
        #[serde(rename = "eventName")]
        #[doc = "Message type."]
        pub event_name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "eventId")]
        #[doc = "Message identifier."]
        pub event_id: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "data")]
        #[doc = "Message content."]
        pub data: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpEvent for EventSourceMessageReceivedEvent<'a> {
        fn event_name(&self) -> &str {
            "Network.eventSourceMessageReceived"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for EventSourceMessageReceivedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.eventSourceMessageReceived" {
                Ok ( < EventSourceMessageReceivedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Details of an intercepted HTTP request, which must be either allowed, blocked, modified or mocked.\n\n# Event `Network.requestIntercepted`\n\n*Domain Module:* [`cdp::proto::network`](index.html)  \n*Event Struct:* [`cdp::proto::network::RequestInterceptedEvent`](struct.RequestInterceptedEvent.html)"]
    pub struct RequestInterceptedEvent<'a> {
        #[serde(rename = "interceptionId")]
        #[doc = "Each request the page makes will have a unique id, however if any redirects are encountered while processing that fetch, they will be reported with the same id as the original fetch. Likewise if HTTP authentication is needed then the same fetch id will be used."]
        pub interception_id: ::proto::network::InterceptionId<'a>,
        #[serde(rename = "request")]
        pub request: ::proto::network::Request<'a>,
        #[serde(rename = "resourceType")]
        #[doc = "How the requested resource will be used."]
        pub resource_type: ::proto::page::ResourceType,
        #[serde(rename = "redirectHeaders", skip_serializing_if = "Option::is_none")]
        #[doc = "HTTP response headers, only sent if a redirect was intercepted."]
        pub redirect_headers: Option<::proto::network::Headers>,
        #[serde(rename = "redirectStatusCode", skip_serializing_if = "Option::is_none")]
        #[doc = "HTTP response code, only sent if a redirect was intercepted."]
        pub redirect_status_code: Option<i32>,
        #[serde(rename = "redirectUrl", skip_serializing_if = "Option::is_none")]
        #[doc = "Redirect location, only sent if a redirect was intercepted."]
        pub redirect_url: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "authChallenge", skip_serializing_if = "Option::is_none")]
        #[doc = "Details of the Authorization Challenge encountered. If this is set then continueInterceptedRequest must contain an authChallengeResponse."]
        pub auth_challenge: Option<::proto::network::AuthChallenge<'a>>,
    }
    impl<'a> ::traits::SerializeCdpEvent for RequestInterceptedEvent<'a> {
        fn event_name(&self) -> &str {
            "Network.requestIntercepted"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for RequestInterceptedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.requestIntercepted" {
                Ok ( < RequestInterceptedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[doc = "Unique loader identifier."]
    pub type LoaderId<'a> = ::std::borrow::Cow<'a, str>;
    #[doc = "Unique request identifier."]
    pub type RequestId<'a> = ::std::borrow::Cow<'a, str>;
    #[doc = "Unique intercepted request identifier."]
    pub type InterceptionId<'a> = ::std::borrow::Cow<'a, str>;
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "Network level fetch failure reason."]
    pub enum ErrorReason {
        #[serde(rename = "Failed")]
        #[doc = "Represented as `\"Failed\"`."]
        Failed,
        #[serde(rename = "Aborted")]
        #[doc = "Represented as `\"Aborted\"`."]
        Aborted,
        #[serde(rename = "TimedOut")]
        #[doc = "Represented as `\"TimedOut\"`."]
        TimedOut,
        #[serde(rename = "AccessDenied")]
        #[doc = "Represented as `\"AccessDenied\"`."]
        AccessDenied,
        #[serde(rename = "ConnectionClosed")]
        #[doc = "Represented as `\"ConnectionClosed\"`."]
        ConnectionClosed,
        #[serde(rename = "ConnectionReset")]
        #[doc = "Represented as `\"ConnectionReset\"`."]
        ConnectionReset,
        #[serde(rename = "ConnectionRefused")]
        #[doc = "Represented as `\"ConnectionRefused\"`."]
        ConnectionRefused,
        #[serde(rename = "ConnectionAborted")]
        #[doc = "Represented as `\"ConnectionAborted\"`."]
        ConnectionAborted,
        #[serde(rename = "ConnectionFailed")]
        #[doc = "Represented as `\"ConnectionFailed\"`."]
        ConnectionFailed,
        #[serde(rename = "NameNotResolved")]
        #[doc = "Represented as `\"NameNotResolved\"`."]
        NameNotResolved,
        #[serde(rename = "InternetDisconnected")]
        #[doc = "Represented as `\"InternetDisconnected\"`."]
        InternetDisconnected,
        #[serde(rename = "AddressUnreachable")]
        #[doc = "Represented as `\"AddressUnreachable\"`."]
        AddressUnreachable,
    }
    impl ErrorReason {
        pub const ENUM_VALUES: &'static [ErrorReason] = &[
            ErrorReason::Failed,
            ErrorReason::Aborted,
            ErrorReason::TimedOut,
            ErrorReason::AccessDenied,
            ErrorReason::ConnectionClosed,
            ErrorReason::ConnectionReset,
            ErrorReason::ConnectionRefused,
            ErrorReason::ConnectionAborted,
            ErrorReason::ConnectionFailed,
            ErrorReason::NameNotResolved,
            ErrorReason::InternetDisconnected,
            ErrorReason::AddressUnreachable,
        ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "Failed",
            "Aborted",
            "TimedOut",
            "AccessDenied",
            "ConnectionClosed",
            "ConnectionReset",
            "ConnectionRefused",
            "ConnectionAborted",
            "ConnectionFailed",
            "NameNotResolved",
            "InternetDisconnected",
            "AddressUnreachable",
        ];
    }
    impl ::std::str::FromStr for ErrorReason {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "Failed" => Ok(ErrorReason::Failed),
                "Aborted" => Ok(ErrorReason::Aborted),
                "TimedOut" => Ok(ErrorReason::TimedOut),
                "AccessDenied" => Ok(ErrorReason::AccessDenied),
                "ConnectionClosed" => Ok(ErrorReason::ConnectionClosed),
                "ConnectionReset" => Ok(ErrorReason::ConnectionReset),
                "ConnectionRefused" => Ok(ErrorReason::ConnectionRefused),
                "ConnectionAborted" => Ok(ErrorReason::ConnectionAborted),
                "ConnectionFailed" => Ok(ErrorReason::ConnectionFailed),
                "NameNotResolved" => Ok(ErrorReason::NameNotResolved),
                "InternetDisconnected" => Ok(ErrorReason::InternetDisconnected),
                "AddressUnreachable" => Ok(ErrorReason::AddressUnreachable),
                _ => Err(::proto::ParseEnumError {
                    expected: ErrorReason::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for ErrorReason {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    ErrorReason::Failed => "Failed",
                    ErrorReason::Aborted => "Aborted",
                    ErrorReason::TimedOut => "TimedOut",
                    ErrorReason::AccessDenied => "AccessDenied",
                    ErrorReason::ConnectionClosed => "ConnectionClosed",
                    ErrorReason::ConnectionReset => "ConnectionReset",
                    ErrorReason::ConnectionRefused => "ConnectionRefused",
                    ErrorReason::ConnectionAborted => "ConnectionAborted",
                    ErrorReason::ConnectionFailed => "ConnectionFailed",
                    ErrorReason::NameNotResolved => "NameNotResolved",
                    ErrorReason::InternetDisconnected => "InternetDisconnected",
                    ErrorReason::AddressUnreachable => "AddressUnreachable",
                }
            )
        }
    }
    #[doc = "UTC time in seconds, counted from January 1, 1970."]
    pub type TimeSinceEpoch = f64;
    #[doc = "Monotonically increasing time in seconds since an arbitrary point in the past."]
    pub type MonotonicTime = f64;
    #[doc = "Request / response headers as keys / values of JSON object."]
    pub type Headers = ::proto::Empty;
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "Loading priority of a resource request."]
    pub enum ConnectionType {
        #[serde(rename = "none")]
        #[doc = "Represented as `\"none\"`."]
        None,
        #[serde(rename = "cellular2g")]
        #[doc = "Represented as `\"cellular2g\"`."]
        Cellular2G,
        #[serde(rename = "cellular3g")]
        #[doc = "Represented as `\"cellular3g\"`."]
        Cellular3G,
        #[serde(rename = "cellular4g")]
        #[doc = "Represented as `\"cellular4g\"`."]
        Cellular4G,
        #[serde(rename = "bluetooth")]
        #[doc = "Represented as `\"bluetooth\"`."]
        Bluetooth,
        #[serde(rename = "ethernet")]
        #[doc = "Represented as `\"ethernet\"`."]
        Ethernet,
        #[serde(rename = "wifi")]
        #[doc = "Represented as `\"wifi\"`."]
        Wifi,
        #[serde(rename = "wimax")]
        #[doc = "Represented as `\"wimax\"`."]
        Wimax,
        #[serde(rename = "other")]
        #[doc = "Represented as `\"other\"`."]
        Other,
    }
    impl ConnectionType {
        pub const ENUM_VALUES: &'static [ConnectionType] = &[
            ConnectionType::None,
            ConnectionType::Cellular2G,
            ConnectionType::Cellular3G,
            ConnectionType::Cellular4G,
            ConnectionType::Bluetooth,
            ConnectionType::Ethernet,
            ConnectionType::Wifi,
            ConnectionType::Wimax,
            ConnectionType::Other,
        ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "none",
            "cellular2g",
            "cellular3g",
            "cellular4g",
            "bluetooth",
            "ethernet",
            "wifi",
            "wimax",
            "other",
        ];
    }
    impl ::std::str::FromStr for ConnectionType {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "none" => Ok(ConnectionType::None),
                "cellular2g" => Ok(ConnectionType::Cellular2G),
                "cellular3g" => Ok(ConnectionType::Cellular3G),
                "cellular4g" => Ok(ConnectionType::Cellular4G),
                "bluetooth" => Ok(ConnectionType::Bluetooth),
                "ethernet" => Ok(ConnectionType::Ethernet),
                "wifi" => Ok(ConnectionType::Wifi),
                "wimax" => Ok(ConnectionType::Wimax),
                "other" => Ok(ConnectionType::Other),
                _ => Err(::proto::ParseEnumError {
                    expected: ConnectionType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for ConnectionType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    ConnectionType::None => "none",
                    ConnectionType::Cellular2G => "cellular2g",
                    ConnectionType::Cellular3G => "cellular3g",
                    ConnectionType::Cellular4G => "cellular4g",
                    ConnectionType::Bluetooth => "bluetooth",
                    ConnectionType::Ethernet => "ethernet",
                    ConnectionType::Wifi => "wifi",
                    ConnectionType::Wimax => "wimax",
                    ConnectionType::Other => "other",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "Represents the cookie's 'SameSite' status: https://tools.ietf.org/html/draft-west-first-party-cookies"]
    pub enum CookieSameSite {
        #[serde(rename = "Strict")]
        #[doc = "Represented as `\"Strict\"`."]
        Strict,
        #[serde(rename = "Lax")]
        #[doc = "Represented as `\"Lax\"`."]
        Lax,
    }
    impl CookieSameSite {
        pub const ENUM_VALUES: &'static [CookieSameSite] =
            &[CookieSameSite::Strict, CookieSameSite::Lax];
        pub const STR_VALUES: &'static [&'static str] = &["Strict", "Lax"];
    }
    impl ::std::str::FromStr for CookieSameSite {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "Strict" => Ok(CookieSameSite::Strict),
                "Lax" => Ok(CookieSameSite::Lax),
                _ => Err(::proto::ParseEnumError {
                    expected: CookieSameSite::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for CookieSameSite {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    CookieSameSite::Strict => "Strict",
                    CookieSameSite::Lax => "Lax",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Timing information for the request."]
    pub struct ResourceTiming {
        #[serde(rename = "requestTime")]
        #[doc = "Timing's requestTime is a baseline in seconds, while the other numbers are ticks in milliseconds relatively to this requestTime."]
        pub request_time: f64,
        #[serde(rename = "proxyStart")]
        #[doc = "Started resolving proxy."]
        pub proxy_start: f64,
        #[serde(rename = "proxyEnd")]
        #[doc = "Finished resolving proxy."]
        pub proxy_end: f64,
        #[serde(rename = "dnsStart")]
        #[doc = "Started DNS address resolve."]
        pub dns_start: f64,
        #[serde(rename = "dnsEnd")]
        #[doc = "Finished DNS address resolve."]
        pub dns_end: f64,
        #[serde(rename = "connectStart")]
        #[doc = "Started connecting to the remote host."]
        pub connect_start: f64,
        #[serde(rename = "connectEnd")]
        #[doc = "Connected to the remote host."]
        pub connect_end: f64,
        #[serde(rename = "sslStart")]
        #[doc = "Started SSL handshake."]
        pub ssl_start: f64,
        #[serde(rename = "sslEnd")]
        #[doc = "Finished SSL handshake."]
        pub ssl_end: f64,
        #[serde(rename = "workerStart")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Started running ServiceWorker."]
        pub worker_start: f64,
        #[serde(rename = "workerReady")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Finished Starting ServiceWorker."]
        pub worker_ready: f64,
        #[serde(rename = "sendStart")]
        #[doc = "Started sending request."]
        pub send_start: f64,
        #[serde(rename = "sendEnd")]
        #[doc = "Finished sending request."]
        pub send_end: f64,
        #[serde(rename = "pushStart")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Time the server started pushing request."]
        pub push_start: f64,
        #[serde(rename = "pushEnd")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Time the server finished pushing request."]
        pub push_end: f64,
        #[serde(rename = "receiveHeadersEnd")]
        #[doc = "Finished receiving response headers."]
        pub receive_headers_end: f64,
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "Loading priority of a resource request."]
    pub enum ResourcePriority {
        #[serde(rename = "VeryLow")]
        #[doc = "Represented as `\"VeryLow\"`."]
        VeryLow,
        #[serde(rename = "Low")]
        #[doc = "Represented as `\"Low\"`."]
        Low,
        #[serde(rename = "Medium")]
        #[doc = "Represented as `\"Medium\"`."]
        Medium,
        #[serde(rename = "High")]
        #[doc = "Represented as `\"High\"`."]
        High,
        #[serde(rename = "VeryHigh")]
        #[doc = "Represented as `\"VeryHigh\"`."]
        VeryHigh,
    }
    impl ResourcePriority {
        pub const ENUM_VALUES: &'static [ResourcePriority] = &[
            ResourcePriority::VeryLow,
            ResourcePriority::Low,
            ResourcePriority::Medium,
            ResourcePriority::High,
            ResourcePriority::VeryHigh,
        ];
        pub const STR_VALUES: &'static [&'static str] =
            &["VeryLow", "Low", "Medium", "High", "VeryHigh"];
    }
    impl ::std::str::FromStr for ResourcePriority {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "VeryLow" => Ok(ResourcePriority::VeryLow),
                "Low" => Ok(ResourcePriority::Low),
                "Medium" => Ok(ResourcePriority::Medium),
                "High" => Ok(ResourcePriority::High),
                "VeryHigh" => Ok(ResourcePriority::VeryHigh),
                _ => Err(::proto::ParseEnumError {
                    expected: ResourcePriority::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for ResourcePriority {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    ResourcePriority::VeryLow => "VeryLow",
                    ResourcePriority::Low => "Low",
                    ResourcePriority::Medium => "Medium",
                    ResourcePriority::High => "High",
                    ResourcePriority::VeryHigh => "VeryHigh",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "Used in the type of [`cdp::proto::network::Request::referrer_policy`](struct.Request.html#structfield.referrer_policy)."]
    pub enum RequestReferrerPolicy {
        #[serde(rename = "unsafe-url")]
        #[doc = "Represented as `\"unsafe-url\"`."]
        UnsafeUrl,
        #[serde(rename = "no-referrer-when-downgrade")]
        #[doc = "Represented as `\"no-referrer-when-downgrade\"`."]
        NoReferrerWhenDowngrade,
        #[serde(rename = "no-referrer")]
        #[doc = "Represented as `\"no-referrer\"`."]
        NoReferrer,
        #[serde(rename = "origin")]
        #[doc = "Represented as `\"origin\"`."]
        Origin,
        #[serde(rename = "origin-when-cross-origin")]
        #[doc = "Represented as `\"origin-when-cross-origin\"`."]
        OriginWhenCrossOrigin,
        #[serde(rename = "same-origin")]
        #[doc = "Represented as `\"same-origin\"`."]
        SameOrigin,
        #[serde(rename = "strict-origin")]
        #[doc = "Represented as `\"strict-origin\"`."]
        StrictOrigin,
        #[serde(rename = "strict-origin-when-cross-origin")]
        #[doc = "Represented as `\"strict-origin-when-cross-origin\"`."]
        StrictOriginWhenCrossOrigin,
    }
    impl RequestReferrerPolicy {
        pub const ENUM_VALUES: &'static [RequestReferrerPolicy] =
            &[
                RequestReferrerPolicy::UnsafeUrl,
                RequestReferrerPolicy::NoReferrerWhenDowngrade,
                RequestReferrerPolicy::NoReferrer,
                RequestReferrerPolicy::Origin,
                RequestReferrerPolicy::OriginWhenCrossOrigin,
                RequestReferrerPolicy::SameOrigin,
                RequestReferrerPolicy::StrictOrigin,
                RequestReferrerPolicy::StrictOriginWhenCrossOrigin,
            ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "unsafe-url",
            "no-referrer-when-downgrade",
            "no-referrer",
            "origin",
            "origin-when-cross-origin",
            "same-origin",
            "strict-origin",
            "strict-origin-when-cross-origin",
        ];
    }
    impl ::std::str::FromStr for RequestReferrerPolicy {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "unsafe-url" => Ok(RequestReferrerPolicy::UnsafeUrl),
                "no-referrer-when-downgrade" => Ok(RequestReferrerPolicy::NoReferrerWhenDowngrade),
                "no-referrer" => Ok(RequestReferrerPolicy::NoReferrer),
                "origin" => Ok(RequestReferrerPolicy::Origin),
                "origin-when-cross-origin" => Ok(RequestReferrerPolicy::OriginWhenCrossOrigin),
                "same-origin" => Ok(RequestReferrerPolicy::SameOrigin),
                "strict-origin" => Ok(RequestReferrerPolicy::StrictOrigin),
                "strict-origin-when-cross-origin" => {
                    Ok(RequestReferrerPolicy::StrictOriginWhenCrossOrigin)
                }
                _ => Err(::proto::ParseEnumError {
                    expected: RequestReferrerPolicy::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for RequestReferrerPolicy {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    RequestReferrerPolicy::UnsafeUrl => "unsafe-url",
                    RequestReferrerPolicy::NoReferrerWhenDowngrade => "no-referrer-when-downgrade",
                    RequestReferrerPolicy::NoReferrer => "no-referrer",
                    RequestReferrerPolicy::Origin => "origin",
                    RequestReferrerPolicy::OriginWhenCrossOrigin => "origin-when-cross-origin",
                    RequestReferrerPolicy::SameOrigin => "same-origin",
                    RequestReferrerPolicy::StrictOrigin => "strict-origin",
                    RequestReferrerPolicy::StrictOriginWhenCrossOrigin => {
                        "strict-origin-when-cross-origin"
                    }
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "HTTP request data."]
    pub struct Request<'a> {
        #[serde(rename = "url")]
        #[doc = "Request URL."]
        pub url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "method")]
        #[doc = "HTTP request method."]
        pub method: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "headers")]
        #[doc = "HTTP request headers."]
        pub headers: ::proto::network::Headers,
        #[serde(rename = "postData", skip_serializing_if = "Option::is_none")]
        #[doc = "HTTP POST request data."]
        pub post_data: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "mixedContentType", skip_serializing_if = "Option::is_none")]
        #[doc = "The mixed content type of the request."]
        pub mixed_content_type: Option<::proto::security::MixedContentType>,
        #[serde(rename = "initialPriority")]
        #[doc = "Priority of the resource request at the time request is sent."]
        pub initial_priority: ::proto::network::ResourcePriority,
        #[serde(rename = "referrerPolicy")]
        #[doc = "The referrer policy of the request, as defined in https://www.w3.org/TR/referrer-policy/"]
        pub referrer_policy: ::proto::network::RequestReferrerPolicy,
        #[serde(rename = "isLinkPreload", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether is loaded via link preload."]
        pub is_link_preload: Option<bool>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Details of a signed certificate timestamp \\(SCT\\)."]
    pub struct SignedCertificateTimestamp<'a> {
        #[serde(rename = "status")]
        #[doc = "Validation status."]
        pub status: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "origin")]
        #[doc = "Origin."]
        pub origin: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "logDescription")]
        #[doc = "Log name / description."]
        pub log_description: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "logId")]
        #[doc = "Log ID."]
        pub log_id: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "timestamp")]
        #[doc = "Issuance date."]
        pub timestamp: ::proto::network::TimeSinceEpoch,
        #[serde(rename = "hashAlgorithm")]
        #[doc = "Hash algorithm."]
        pub hash_algorithm: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "signatureAlgorithm")]
        #[doc = "Signature algorithm."]
        pub signature_algorithm: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "signatureData")]
        #[doc = "Signature data."]
        pub signature_data: ::std::borrow::Cow<'a, str>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Security details about a request."]
    pub struct SecurityDetails<'a> {
        #[serde(rename = "protocol")]
        #[doc = "Protocol name \\(e.g. \"TLS 1.2\" or \"QUIC\"\\)."]
        pub protocol: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "keyExchange")]
        #[doc = "Key Exchange used by the connection, or the empty string if not applicable."]
        pub key_exchange: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "keyExchangeGroup", skip_serializing_if = "Option::is_none")]
        #[doc = "\\(EC\\)DH group used by the connection, if applicable."]
        pub key_exchange_group: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "cipher")]
        #[doc = "Cipher name."]
        pub cipher: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "mac", skip_serializing_if = "Option::is_none")]
        #[doc = "TLS MAC. Note that AEAD ciphers do not have separate MACs."]
        pub mac: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "certificateId")]
        #[doc = "Certificate ID value."]
        pub certificate_id: ::proto::security::CertificateId,
        #[serde(rename = "subjectName")]
        #[doc = "Certificate subject name."]
        pub subject_name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "sanList")]
        #[doc = "Subject Alternative Name \\(SAN\\) DNS names and IP addresses."]
        pub san_list: Vec<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "issuer")]
        #[doc = "Name of the issuing CA."]
        pub issuer: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "validFrom")]
        #[doc = "Certificate valid from date."]
        pub valid_from: ::proto::network::TimeSinceEpoch,
        #[serde(rename = "validTo")]
        #[doc = "Certificate valid to \\(expiration\\) date"]
        pub valid_to: ::proto::network::TimeSinceEpoch,
        #[serde(rename = "signedCertificateTimestampList")]
        #[doc = "List of signed certificate timestamps \\(SCTs\\)."]
        pub signed_certificate_timestamp_list:
            Vec<::proto::network::SignedCertificateTimestamp<'a>>,
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> The reason why request was blocked."]
    pub enum BlockedReason {
        #[serde(rename = "csp")]
        #[doc = "Represented as `\"csp\"`."]
        Csp,
        #[serde(rename = "mixed-content")]
        #[doc = "Represented as `\"mixed-content\"`."]
        MixedContent,
        #[serde(rename = "origin")]
        #[doc = "Represented as `\"origin\"`."]
        Origin,
        #[serde(rename = "inspector")]
        #[doc = "Represented as `\"inspector\"`."]
        Inspector,
        #[serde(rename = "subresource-filter")]
        #[doc = "Represented as `\"subresource-filter\"`."]
        SubresourceFilter,
        #[serde(rename = "other")]
        #[doc = "Represented as `\"other\"`."]
        Other,
    }
    impl BlockedReason {
        pub const ENUM_VALUES: &'static [BlockedReason] = &[
            BlockedReason::Csp,
            BlockedReason::MixedContent,
            BlockedReason::Origin,
            BlockedReason::Inspector,
            BlockedReason::SubresourceFilter,
            BlockedReason::Other,
        ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "csp",
            "mixed-content",
            "origin",
            "inspector",
            "subresource-filter",
            "other",
        ];
    }
    impl ::std::str::FromStr for BlockedReason {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "csp" => Ok(BlockedReason::Csp),
                "mixed-content" => Ok(BlockedReason::MixedContent),
                "origin" => Ok(BlockedReason::Origin),
                "inspector" => Ok(BlockedReason::Inspector),
                "subresource-filter" => Ok(BlockedReason::SubresourceFilter),
                "other" => Ok(BlockedReason::Other),
                _ => Err(::proto::ParseEnumError {
                    expected: BlockedReason::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for BlockedReason {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    BlockedReason::Csp => "csp",
                    BlockedReason::MixedContent => "mixed-content",
                    BlockedReason::Origin => "origin",
                    BlockedReason::Inspector => "inspector",
                    BlockedReason::SubresourceFilter => "subresource-filter",
                    BlockedReason::Other => "other",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "HTTP response data."]
    pub struct Response<'a> {
        #[serde(rename = "url")]
        #[doc = "Response URL. This URL can be different from CachedResource.url in case of redirect."]
        pub url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "status")]
        #[doc = "HTTP response status code."]
        pub status: f64,
        #[serde(rename = "statusText")]
        #[doc = "HTTP response status text."]
        pub status_text: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "headers")]
        #[doc = "HTTP response headers."]
        pub headers: ::proto::network::Headers,
        #[serde(rename = "headersText", skip_serializing_if = "Option::is_none")]
        #[doc = "HTTP response headers text."]
        pub headers_text: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "mimeType")]
        #[doc = "Resource mimeType as determined by the browser."]
        pub mime_type: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "requestHeaders", skip_serializing_if = "Option::is_none")]
        #[doc = "Refined HTTP request headers that were actually transmitted over the network."]
        pub request_headers: Option<::proto::network::Headers>,
        #[serde(rename = "requestHeadersText", skip_serializing_if = "Option::is_none")]
        #[doc = "HTTP request headers text."]
        pub request_headers_text: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "connectionReused")]
        #[doc = "Specifies whether physical connection was actually reused for this request."]
        pub connection_reused: bool,
        #[serde(rename = "connectionId")]
        #[doc = "Physical connection id that was actually used for this request."]
        pub connection_id: f64,
        #[serde(rename = "remoteIPAddress", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Remote IP address."]
        pub remote_ip_address: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "remotePort", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Remote port."]
        pub remote_port: Option<i32>,
        #[serde(rename = "fromDiskCache", skip_serializing_if = "Option::is_none")]
        #[doc = "Specifies that the request was served from the disk cache."]
        pub from_disk_cache: Option<bool>,
        #[serde(rename = "fromServiceWorker", skip_serializing_if = "Option::is_none")]
        #[doc = "Specifies that the request was served from the ServiceWorker."]
        pub from_service_worker: Option<bool>,
        #[serde(rename = "encodedDataLength")]
        #[doc = "Total number of bytes received for this request so far."]
        pub encoded_data_length: f64,
        #[serde(rename = "timing", skip_serializing_if = "Option::is_none")]
        #[doc = "Timing information for the given request."]
        pub timing: Option<::proto::network::ResourceTiming>,
        #[serde(rename = "protocol", skip_serializing_if = "Option::is_none")]
        #[doc = "Protocol used to fetch this request."]
        pub protocol: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "securityState")]
        #[doc = "Security state of the request resource."]
        pub security_state: ::proto::security::SecurityState,
        #[serde(rename = "securityDetails", skip_serializing_if = "Option::is_none")]
        #[doc = "Security details for the request."]
        pub security_details: Option<::proto::network::SecurityDetails<'a>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> WebSocket request data."]
    pub struct WebSocketRequest {
        #[serde(rename = "headers")]
        #[doc = "HTTP request headers."]
        pub headers: ::proto::network::Headers,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> WebSocket response data."]
    pub struct WebSocketResponse<'a> {
        #[serde(rename = "status")]
        #[doc = "HTTP response status code."]
        pub status: f64,
        #[serde(rename = "statusText")]
        #[doc = "HTTP response status text."]
        pub status_text: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "headers")]
        #[doc = "HTTP response headers."]
        pub headers: ::proto::network::Headers,
        #[serde(rename = "headersText", skip_serializing_if = "Option::is_none")]
        #[doc = "HTTP response headers text."]
        pub headers_text: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "requestHeaders", skip_serializing_if = "Option::is_none")]
        #[doc = "HTTP request headers."]
        pub request_headers: Option<::proto::network::Headers>,
        #[serde(rename = "requestHeadersText", skip_serializing_if = "Option::is_none")]
        #[doc = "HTTP request headers text."]
        pub request_headers_text: Option<::std::borrow::Cow<'a, str>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> WebSocket frame data."]
    pub struct WebSocketFrame<'a> {
        #[serde(rename = "opcode")]
        #[doc = "WebSocket frame opcode."]
        pub opcode: f64,
        #[serde(rename = "mask")]
        #[doc = "WebSocke frame mask."]
        pub mask: bool,
        #[serde(rename = "payloadData")]
        #[doc = "WebSocke frame payload data."]
        pub payload_data: ::std::borrow::Cow<'a, str>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Information about the cached resource."]
    pub struct CachedResource<'a> {
        #[serde(rename = "url")]
        #[doc = "Resource URL. This is the url of the original network request."]
        pub url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "type")]
        #[doc = "Type of this resource."]
        pub ty: ::proto::page::ResourceType,
        #[serde(rename = "response", skip_serializing_if = "Option::is_none")]
        #[doc = "Cached response data."]
        pub response: Option<::proto::network::Response<'a>>,
        #[serde(rename = "bodySize")]
        #[doc = "Cached response body size."]
        pub body_size: f64,
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "Used in the type of [`cdp::proto::network::Initiator::ty`](struct.Initiator.html#structfield.ty)."]
    pub enum InitiatorType {
        #[serde(rename = "parser")]
        #[doc = "Represented as `\"parser\"`."]
        Parser,
        #[serde(rename = "script")]
        #[doc = "Represented as `\"script\"`."]
        Script,
        #[serde(rename = "preload")]
        #[doc = "Represented as `\"preload\"`."]
        Preload,
        #[serde(rename = "other")]
        #[doc = "Represented as `\"other\"`."]
        Other,
    }
    impl InitiatorType {
        pub const ENUM_VALUES: &'static [InitiatorType] = &[
            InitiatorType::Parser,
            InitiatorType::Script,
            InitiatorType::Preload,
            InitiatorType::Other,
        ];
        pub const STR_VALUES: &'static [&'static str] = &["parser", "script", "preload", "other"];
    }
    impl ::std::str::FromStr for InitiatorType {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "parser" => Ok(InitiatorType::Parser),
                "script" => Ok(InitiatorType::Script),
                "preload" => Ok(InitiatorType::Preload),
                "other" => Ok(InitiatorType::Other),
                _ => Err(::proto::ParseEnumError {
                    expected: InitiatorType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for InitiatorType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    InitiatorType::Parser => "parser",
                    InitiatorType::Script => "script",
                    InitiatorType::Preload => "preload",
                    InitiatorType::Other => "other",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Information about the request initiator."]
    pub struct Initiator<'a> {
        #[serde(rename = "type")]
        #[doc = "Type of this initiator."]
        pub ty: ::proto::network::InitiatorType,
        #[serde(rename = "stack", skip_serializing_if = "Option::is_none")]
        #[doc = "Initiator JavaScript stack trace, set for Script only."]
        pub stack: Option<::proto::runtime::StackTrace<'a>>,
        #[serde(rename = "url", skip_serializing_if = "Option::is_none")]
        #[doc = "Initiator URL, set for Parser type or for Script type \\(when script is importing module\\)."]
        pub url: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "lineNumber", skip_serializing_if = "Option::is_none")]
        #[doc = "Initiator line number, set for Parser type or for Script type \\(when script is importing module\\) \\(0-based\\)."]
        pub line_number: Option<f64>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Cookie object"]
    pub struct Cookie<'a> {
        #[serde(rename = "name")]
        #[doc = "Cookie name."]
        pub name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "value")]
        #[doc = "Cookie value."]
        pub value: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "domain")]
        #[doc = "Cookie domain."]
        pub domain: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "path")]
        #[doc = "Cookie path."]
        pub path: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "expires")]
        #[doc = "Cookie expiration date as the number of seconds since the UNIX epoch."]
        pub expires: f64,
        #[serde(rename = "size")]
        #[doc = "Cookie size."]
        pub size: i32,
        #[serde(rename = "httpOnly")]
        #[doc = "True if cookie is http-only."]
        pub http_only: bool,
        #[serde(rename = "secure")]
        #[doc = "True if cookie is secure."]
        pub secure: bool,
        #[serde(rename = "session")]
        #[doc = "True in case of session cookie."]
        pub session: bool,
        #[serde(rename = "sameSite", skip_serializing_if = "Option::is_none")]
        #[doc = "Cookie SameSite type."]
        pub same_site: Option<::proto::network::CookieSameSite>,
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\nUsed in the type of [`cdp::proto::network::AuthChallenge::source`](struct.AuthChallenge.html#structfield.source)."]
    pub enum AuthChallengeSource {
        #[serde(rename = "Server")]
        #[doc = "Represented as `\"Server\"`."]
        Server,
        #[serde(rename = "Proxy")]
        #[doc = "Represented as `\"Proxy\"`."]
        Proxy,
    }
    impl AuthChallengeSource {
        pub const ENUM_VALUES: &'static [AuthChallengeSource] =
            &[AuthChallengeSource::Server, AuthChallengeSource::Proxy];
        pub const STR_VALUES: &'static [&'static str] = &["Server", "Proxy"];
    }
    impl ::std::str::FromStr for AuthChallengeSource {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "Server" => Ok(AuthChallengeSource::Server),
                "Proxy" => Ok(AuthChallengeSource::Proxy),
                _ => Err(::proto::ParseEnumError {
                    expected: AuthChallengeSource::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for AuthChallengeSource {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    AuthChallengeSource::Server => "Server",
                    AuthChallengeSource::Proxy => "Proxy",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Authorization challenge for HTTP status code 401 or 407."]
    pub struct AuthChallenge<'a> {
        #[serde(rename = "source", skip_serializing_if = "Option::is_none")]
        #[doc = "Source of the authentication challenge."]
        pub source: Option<::proto::network::AuthChallengeSource>,
        #[serde(rename = "origin")]
        #[doc = "Origin of the challenger."]
        pub origin: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "scheme")]
        #[doc = "The authentication scheme used, such as basic or digest"]
        pub scheme: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "realm")]
        #[doc = "The realm of the challenge. May be empty."]
        pub realm: ::std::borrow::Cow<'a, str>,
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\nUsed in the type of [`cdp::proto::network::AuthChallengeResponse::response`](struct.AuthChallengeResponse.html#structfield.response)."]
    pub enum AuthChallengeResponseResponse {
        #[serde(rename = "Default")]
        #[doc = "Represented as `\"Default\"`."]
        Default,
        #[serde(rename = "CancelAuth")]
        #[doc = "Represented as `\"CancelAuth\"`."]
        CancelAuth,
        #[serde(rename = "ProvideCredentials")]
        #[doc = "Represented as `\"ProvideCredentials\"`."]
        ProvideCredentials,
    }
    impl AuthChallengeResponseResponse {
        pub const ENUM_VALUES: &'static [AuthChallengeResponseResponse] =
            &[
                AuthChallengeResponseResponse::Default,
                AuthChallengeResponseResponse::CancelAuth,
                AuthChallengeResponseResponse::ProvideCredentials,
            ];
        pub const STR_VALUES: &'static [&'static str] =
            &["Default", "CancelAuth", "ProvideCredentials"];
    }
    impl ::std::str::FromStr for AuthChallengeResponseResponse {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "Default" => Ok(AuthChallengeResponseResponse::Default),
                "CancelAuth" => Ok(AuthChallengeResponseResponse::CancelAuth),
                "ProvideCredentials" => Ok(AuthChallengeResponseResponse::ProvideCredentials),
                _ => Err(::proto::ParseEnumError {
                    expected: AuthChallengeResponseResponse::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for AuthChallengeResponseResponse {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    AuthChallengeResponseResponse::Default => "Default",
                    AuthChallengeResponseResponse::CancelAuth => "CancelAuth",
                    AuthChallengeResponseResponse::ProvideCredentials => "ProvideCredentials",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Response to an AuthChallenge."]
    pub struct AuthChallengeResponse<'a> {
        #[serde(rename = "response")]
        #[doc = "The decision on what to do in response to the authorization challenge.  Default means deferring to the default behavior of the net stack, which will likely either the Cancel authentication or display a popup dialog box."]
        pub response: ::proto::network::AuthChallengeResponseResponse,
        #[serde(rename = "username", skip_serializing_if = "Option::is_none")]
        #[doc = "The username to provide, possibly empty. Should only be set if response is ProvideCredentials."]
        pub username: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "password", skip_serializing_if = "Option::is_none")]
        #[doc = "The password to provide, possibly empty. Should only be set if response is ProvideCredentials."]
        pub password: Option<::std::borrow::Cow<'a, str>>,
    }
}
#[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Database\n\n## Commands\n\n- [`Database.enable`](struct.EnableCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Enables database tracking, database events will now be delivered to the client.\n- [`Database.disable`](struct.DisableCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Disables database tracking, prevents database events from being sent to the client.\n- [`Database.getDatabaseTableNames`](struct.GetDatabaseTableNamesCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`Database.executeSQL`](struct.ExecuteSqlCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n## Events\n\n- [`Database.addDatabase`](struct.AddDatabaseEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n##Types\n\n- [`DatabaseId`](type.DatabaseId.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Unique identifier of Database object.\n- [`Database`](struct.Database.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Database object.\n- [`Error`](struct.Error.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Database error.\n"]
pub mod database {
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables database tracking, database events will now be delivered to the client.\n\n# Command `Database.enable`\n\n*Domain Module:* [`cdp::proto::database`](index.html)  \n*Command Struct:* [`cdp::proto::database::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::proto::database::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableCommand;
    impl ::serde::Serialize for EnableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for EnableCommand {
        fn command_name(&self) -> &str {
            "Database.enable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for EnableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Database.enable" {
                Ok(
                    <EnableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables database tracking, database events will now be delivered to the client.\n\n# Command `Database.enable`\n\n*Domain Module:* [`cdp::proto::database`](index.html)  \n*Command Struct:* [`cdp::proto::database::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::proto::database::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableResponse;
    impl ::serde::Serialize for EnableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for EnableCommand {
        type Response = EnableResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for EnableResponse {
        type Command = EnableCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Disables database tracking, prevents database events from being sent to the client.\n\n# Command `Database.disable`\n\n*Domain Module:* [`cdp::proto::database`](index.html)  \n*Command Struct:* [`cdp::proto::database::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::proto::database::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableCommand;
    impl ::serde::Serialize for DisableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for DisableCommand {
        fn command_name(&self) -> &str {
            "Database.disable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for DisableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Database.disable" {
                Ok(
                    <DisableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Disables database tracking, prevents database events from being sent to the client.\n\n# Command `Database.disable`\n\n*Domain Module:* [`cdp::proto::database`](index.html)  \n*Command Struct:* [`cdp::proto::database::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::proto::database::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableResponse;
    impl ::serde::Serialize for DisableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for DisableCommand {
        type Response = DisableResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for DisableResponse {
        type Command = DisableCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `Database.getDatabaseTableNames`\n\n*Domain Module:* [`cdp::proto::database`](index.html)  \n*Command Struct:* [`cdp::proto::database::GetDatabaseTableNamesCommand`](struct.GetDatabaseTableNamesCommand.html)  \n*Response Struct:* [`cdp::proto::database::GetDatabaseTableNamesResponse`](struct.GetDatabaseTableNamesResponse.html)"]
    pub struct GetDatabaseTableNamesCommand<'a> {
        #[serde(rename = "databaseId")]
        pub database_id: ::proto::database::DatabaseId<'a>,
    }
    impl<'a> ::traits::SerializeCdpCommand for GetDatabaseTableNamesCommand<'a> {
        fn command_name(&self) -> &str {
            "Database.getDatabaseTableNames"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for GetDatabaseTableNamesCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Database.getDatabaseTableNames" {
                Ok ( < GetDatabaseTableNamesCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `Database.getDatabaseTableNames`\n\n*Domain Module:* [`cdp::proto::database`](index.html)  \n*Command Struct:* [`cdp::proto::database::GetDatabaseTableNamesCommand`](struct.GetDatabaseTableNamesCommand.html)  \n*Response Struct:* [`cdp::proto::database::GetDatabaseTableNamesResponse`](struct.GetDatabaseTableNamesResponse.html)"]
    pub struct GetDatabaseTableNamesResponse<'a> {
        #[serde(rename = "tableNames")]
        pub table_names: Vec<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for GetDatabaseTableNamesCommand<'a> {
        type Response = GetDatabaseTableNamesResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for GetDatabaseTableNamesResponse<'a> {
        type Command = GetDatabaseTableNamesCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `Database.executeSQL`\n\n*Domain Module:* [`cdp::proto::database`](index.html)  \n*Command Struct:* [`cdp::proto::database::ExecuteSqlCommand`](struct.ExecuteSqlCommand.html)  \n*Response Struct:* [`cdp::proto::database::ExecuteSqlResponse`](struct.ExecuteSqlResponse.html)"]
    pub struct ExecuteSqlCommand<'a> {
        #[serde(rename = "databaseId")]
        pub database_id: ::proto::database::DatabaseId<'a>,
        #[serde(rename = "query")]
        pub query: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpCommand for ExecuteSqlCommand<'a> {
        fn command_name(&self) -> &str {
            "Database.executeSQL"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for ExecuteSqlCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Database.executeSQL" {
                Ok(
                    <ExecuteSqlCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `Database.executeSQL`\n\n*Domain Module:* [`cdp::proto::database`](index.html)  \n*Command Struct:* [`cdp::proto::database::ExecuteSqlCommand`](struct.ExecuteSqlCommand.html)  \n*Response Struct:* [`cdp::proto::database::ExecuteSqlResponse`](struct.ExecuteSqlResponse.html)"]
    pub struct ExecuteSqlResponse<'a> {
        #[serde(rename = "columnNames", skip_serializing_if = "Option::is_none")]
        pub column_names: Option<Vec<::std::borrow::Cow<'a, str>>>,
        #[serde(rename = "values", skip_serializing_if = "Option::is_none")]
        pub values: Option<Vec<::serde_json::Value>>,
        #[serde(rename = "sqlError", skip_serializing_if = "Option::is_none")]
        pub sql_error: Option<::proto::database::Error<'a>>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for ExecuteSqlCommand<'a> {
        type Response = ExecuteSqlResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for ExecuteSqlResponse<'a> {
        type Command = ExecuteSqlCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Event `Database.addDatabase`\n\n*Domain Module:* [`cdp::proto::database`](index.html)  \n*Event Struct:* [`cdp::proto::database::AddDatabaseEvent`](struct.AddDatabaseEvent.html)"]
    pub struct AddDatabaseEvent<'a> {
        #[serde(rename = "database")]
        pub database: ::proto::database::Database<'a>,
    }
    impl<'a> ::traits::SerializeCdpEvent for AddDatabaseEvent<'a> {
        fn event_name(&self) -> &str {
            "Database.addDatabase"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for AddDatabaseEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Database.addDatabase" {
                Ok(
                    <AddDatabaseEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Unique identifier of Database object."]
    pub type DatabaseId<'a> = ::std::borrow::Cow<'a, str>;
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Database object."]
    pub struct Database<'a> {
        #[serde(rename = "id")]
        #[doc = "Database ID."]
        pub id: ::proto::database::DatabaseId<'a>,
        #[serde(rename = "domain")]
        #[doc = "Database domain."]
        pub domain: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "name")]
        #[doc = "Database name."]
        pub name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "version")]
        #[doc = "Database version."]
        pub version: ::std::borrow::Cow<'a, str>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Database error."]
    pub struct Error<'a> {
        #[serde(rename = "message")]
        #[doc = "Error message."]
        pub message: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "code")]
        #[doc = "Error code."]
        pub code: i32,
    }
}
#[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# IndexedDB\n\n## Commands\n\n- [`IndexedDB.enable`](struct.EnableCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Enables events from backend.\n- [`IndexedDB.disable`](struct.DisableCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Disables events from backend.\n- [`IndexedDB.requestDatabaseNames`](struct.RequestDatabaseNamesCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Requests database names for given security origin.\n- [`IndexedDB.requestDatabase`](struct.RequestDatabaseCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Requests database with given name in given frame.\n- [`IndexedDB.requestData`](struct.RequestDataCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Requests data from object store or index.\n- [`IndexedDB.clearObjectStore`](struct.ClearObjectStoreCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Clears all entries from an object store.\n- [`IndexedDB.deleteDatabase`](struct.DeleteDatabaseCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Deletes a database.\n\n##Types\n\n- [`DatabaseWithObjectStores`](struct.DatabaseWithObjectStores.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Database with an array of object stores.\n- [`ObjectStore`](struct.ObjectStore.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Object store.\n- [`ObjectStoreIndex`](struct.ObjectStoreIndex.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Object store index.\n- [`Key`](struct.Key.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Key.\n- [`KeyRange`](struct.KeyRange.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Key range.\n- [`DataEntry`](struct.DataEntry.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Data entry.\n- [`KeyPath`](struct.KeyPath.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Key path.\n"]
pub mod indexed_db {
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables events from backend.\n\n# Command `IndexedDB.enable`\n\n*Domain Module:* [`cdp::proto::indexed_db`](index.html)  \n*Command Struct:* [`cdp::proto::indexed_db::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::proto::indexed_db::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableCommand;
    impl ::serde::Serialize for EnableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for EnableCommand {
        fn command_name(&self) -> &str {
            "IndexedDB.enable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for EnableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "IndexedDB.enable" {
                Ok(
                    <EnableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables events from backend.\n\n# Command `IndexedDB.enable`\n\n*Domain Module:* [`cdp::proto::indexed_db`](index.html)  \n*Command Struct:* [`cdp::proto::indexed_db::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::proto::indexed_db::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableResponse;
    impl ::serde::Serialize for EnableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for EnableCommand {
        type Response = EnableResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for EnableResponse {
        type Command = EnableCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Disables events from backend.\n\n# Command `IndexedDB.disable`\n\n*Domain Module:* [`cdp::proto::indexed_db`](index.html)  \n*Command Struct:* [`cdp::proto::indexed_db::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::proto::indexed_db::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableCommand;
    impl ::serde::Serialize for DisableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for DisableCommand {
        fn command_name(&self) -> &str {
            "IndexedDB.disable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for DisableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "IndexedDB.disable" {
                Ok(
                    <DisableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Disables events from backend.\n\n# Command `IndexedDB.disable`\n\n*Domain Module:* [`cdp::proto::indexed_db`](index.html)  \n*Command Struct:* [`cdp::proto::indexed_db::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::proto::indexed_db::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableResponse;
    impl ::serde::Serialize for DisableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for DisableCommand {
        type Response = DisableResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for DisableResponse {
        type Command = DisableCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Requests database names for given security origin.\n\n# Command `IndexedDB.requestDatabaseNames`\n\n*Domain Module:* [`cdp::proto::indexed_db`](index.html)  \n*Command Struct:* [`cdp::proto::indexed_db::RequestDatabaseNamesCommand`](struct.RequestDatabaseNamesCommand.html)  \n*Response Struct:* [`cdp::proto::indexed_db::RequestDatabaseNamesResponse`](struct.RequestDatabaseNamesResponse.html)"]
    pub struct RequestDatabaseNamesCommand<'a> {
        #[serde(rename = "securityOrigin")]
        #[doc = "Security origin."]
        pub security_origin: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpCommand for RequestDatabaseNamesCommand<'a> {
        fn command_name(&self) -> &str {
            "IndexedDB.requestDatabaseNames"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for RequestDatabaseNamesCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "IndexedDB.requestDatabaseNames" {
                Ok ( < RequestDatabaseNamesCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Requests database names for given security origin.\n\n# Command `IndexedDB.requestDatabaseNames`\n\n*Domain Module:* [`cdp::proto::indexed_db`](index.html)  \n*Command Struct:* [`cdp::proto::indexed_db::RequestDatabaseNamesCommand`](struct.RequestDatabaseNamesCommand.html)  \n*Response Struct:* [`cdp::proto::indexed_db::RequestDatabaseNamesResponse`](struct.RequestDatabaseNamesResponse.html)"]
    pub struct RequestDatabaseNamesResponse<'a> {
        #[serde(rename = "databaseNames")]
        #[doc = "Database names for origin."]
        pub database_names: Vec<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for RequestDatabaseNamesCommand<'a> {
        type Response = RequestDatabaseNamesResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for RequestDatabaseNamesResponse<'a> {
        type Command = RequestDatabaseNamesCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Requests database with given name in given frame.\n\n# Command `IndexedDB.requestDatabase`\n\n*Domain Module:* [`cdp::proto::indexed_db`](index.html)  \n*Command Struct:* [`cdp::proto::indexed_db::RequestDatabaseCommand`](struct.RequestDatabaseCommand.html)  \n*Response Struct:* [`cdp::proto::indexed_db::RequestDatabaseResponse`](struct.RequestDatabaseResponse.html)"]
    pub struct RequestDatabaseCommand<'a> {
        #[serde(rename = "securityOrigin")]
        #[doc = "Security origin."]
        pub security_origin: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "databaseName")]
        #[doc = "Database name."]
        pub database_name: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpCommand for RequestDatabaseCommand<'a> {
        fn command_name(&self) -> &str {
            "IndexedDB.requestDatabase"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for RequestDatabaseCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "IndexedDB.requestDatabase" {
                Ok(
                    <RequestDatabaseCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Requests database with given name in given frame.\n\n# Command `IndexedDB.requestDatabase`\n\n*Domain Module:* [`cdp::proto::indexed_db`](index.html)  \n*Command Struct:* [`cdp::proto::indexed_db::RequestDatabaseCommand`](struct.RequestDatabaseCommand.html)  \n*Response Struct:* [`cdp::proto::indexed_db::RequestDatabaseResponse`](struct.RequestDatabaseResponse.html)"]
    pub struct RequestDatabaseResponse<'a> {
        #[serde(rename = "databaseWithObjectStores")]
        #[doc = "Database with an array of object stores."]
        pub database_with_object_stores: ::proto::indexed_db::DatabaseWithObjectStores<'a>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for RequestDatabaseCommand<'a> {
        type Response = RequestDatabaseResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for RequestDatabaseResponse<'a> {
        type Command = RequestDatabaseCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Requests data from object store or index.\n\n# Command `IndexedDB.requestData`\n\n*Domain Module:* [`cdp::proto::indexed_db`](index.html)  \n*Command Struct:* [`cdp::proto::indexed_db::RequestDataCommand`](struct.RequestDataCommand.html)  \n*Response Struct:* [`cdp::proto::indexed_db::RequestDataResponse`](struct.RequestDataResponse.html)"]
    pub struct RequestDataCommand<'a> {
        #[serde(rename = "securityOrigin")]
        #[doc = "Security origin."]
        pub security_origin: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "databaseName")]
        #[doc = "Database name."]
        pub database_name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "objectStoreName")]
        #[doc = "Object store name."]
        pub object_store_name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "indexName")]
        #[doc = "Index name, empty string for object store data requests."]
        pub index_name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "skipCount")]
        #[doc = "Number of records to skip."]
        pub skip_count: i32,
        #[serde(rename = "pageSize")]
        #[doc = "Number of records to fetch."]
        pub page_size: i32,
        #[serde(rename = "keyRange", skip_serializing_if = "Option::is_none")]
        #[doc = "Key range."]
        pub key_range: Option<::proto::indexed_db::KeyRange<'a>>,
    }
    impl<'a> ::traits::SerializeCdpCommand for RequestDataCommand<'a> {
        fn command_name(&self) -> &str {
            "IndexedDB.requestData"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for RequestDataCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "IndexedDB.requestData" {
                Ok(
                    <RequestDataCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Requests data from object store or index.\n\n# Command `IndexedDB.requestData`\n\n*Domain Module:* [`cdp::proto::indexed_db`](index.html)  \n*Command Struct:* [`cdp::proto::indexed_db::RequestDataCommand`](struct.RequestDataCommand.html)  \n*Response Struct:* [`cdp::proto::indexed_db::RequestDataResponse`](struct.RequestDataResponse.html)"]
    pub struct RequestDataResponse<'a> {
        #[serde(rename = "objectStoreDataEntries")]
        #[doc = "Array of object store data entries."]
        pub object_store_data_entries: Vec<::proto::indexed_db::DataEntry<'a>>,
        #[serde(rename = "hasMore")]
        #[doc = "If true, there are more entries to fetch in the given range."]
        pub has_more: bool,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for RequestDataCommand<'a> {
        type Response = RequestDataResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for RequestDataResponse<'a> {
        type Command = RequestDataCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Clears all entries from an object store.\n\n# Command `IndexedDB.clearObjectStore`\n\n*Domain Module:* [`cdp::proto::indexed_db`](index.html)  \n*Command Struct:* [`cdp::proto::indexed_db::ClearObjectStoreCommand`](struct.ClearObjectStoreCommand.html)  \n*Response Struct:* [`cdp::proto::indexed_db::ClearObjectStoreResponse`](struct.ClearObjectStoreResponse.html)"]
    pub struct ClearObjectStoreCommand<'a> {
        #[serde(rename = "securityOrigin")]
        #[doc = "Security origin."]
        pub security_origin: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "databaseName")]
        #[doc = "Database name."]
        pub database_name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "objectStoreName")]
        #[doc = "Object store name."]
        pub object_store_name: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpCommand for ClearObjectStoreCommand<'a> {
        fn command_name(&self) -> &str {
            "IndexedDB.clearObjectStore"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for ClearObjectStoreCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "IndexedDB.clearObjectStore" {
                Ok ( < ClearObjectStoreCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Clears all entries from an object store.\n\n# Command `IndexedDB.clearObjectStore`\n\n*Domain Module:* [`cdp::proto::indexed_db`](index.html)  \n*Command Struct:* [`cdp::proto::indexed_db::ClearObjectStoreCommand`](struct.ClearObjectStoreCommand.html)  \n*Response Struct:* [`cdp::proto::indexed_db::ClearObjectStoreResponse`](struct.ClearObjectStoreResponse.html)"]
    pub struct ClearObjectStoreResponse;
    impl ::serde::Serialize for ClearObjectStoreResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ClearObjectStoreResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ClearObjectStoreResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for ClearObjectStoreCommand<'a> {
        type Response = ClearObjectStoreResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for ClearObjectStoreResponse {
        type Command = ClearObjectStoreCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Deletes a database.\n\n# Command `IndexedDB.deleteDatabase`\n\n*Domain Module:* [`cdp::proto::indexed_db`](index.html)  \n*Command Struct:* [`cdp::proto::indexed_db::DeleteDatabaseCommand`](struct.DeleteDatabaseCommand.html)  \n*Response Struct:* [`cdp::proto::indexed_db::DeleteDatabaseResponse`](struct.DeleteDatabaseResponse.html)"]
    pub struct DeleteDatabaseCommand<'a> {
        #[serde(rename = "securityOrigin")]
        #[doc = "Security origin."]
        pub security_origin: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "databaseName")]
        #[doc = "Database name."]
        pub database_name: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpCommand for DeleteDatabaseCommand<'a> {
        fn command_name(&self) -> &str {
            "IndexedDB.deleteDatabase"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for DeleteDatabaseCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "IndexedDB.deleteDatabase" {
                Ok(
                    <DeleteDatabaseCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Deletes a database.\n\n# Command `IndexedDB.deleteDatabase`\n\n*Domain Module:* [`cdp::proto::indexed_db`](index.html)  \n*Command Struct:* [`cdp::proto::indexed_db::DeleteDatabaseCommand`](struct.DeleteDatabaseCommand.html)  \n*Response Struct:* [`cdp::proto::indexed_db::DeleteDatabaseResponse`](struct.DeleteDatabaseResponse.html)"]
    pub struct DeleteDatabaseResponse;
    impl ::serde::Serialize for DeleteDatabaseResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DeleteDatabaseResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DeleteDatabaseResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for DeleteDatabaseCommand<'a> {
        type Response = DeleteDatabaseResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for DeleteDatabaseResponse {
        type Command = DeleteDatabaseCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Database with an array of object stores."]
    pub struct DatabaseWithObjectStores<'a> {
        #[serde(rename = "name")]
        #[doc = "Database name."]
        pub name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "version")]
        #[doc = "Database version."]
        pub version: i32,
        #[serde(rename = "objectStores")]
        #[doc = "Object stores in this database."]
        pub object_stores: Vec<::proto::indexed_db::ObjectStore<'a>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Object store."]
    pub struct ObjectStore<'a> {
        #[serde(rename = "name")]
        #[doc = "Object store name."]
        pub name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "keyPath")]
        #[doc = "Object store key path."]
        pub key_path: ::proto::indexed_db::KeyPath<'a>,
        #[serde(rename = "autoIncrement")]
        #[doc = "If true, object store has auto increment flag set."]
        pub auto_increment: bool,
        #[serde(rename = "indexes")]
        #[doc = "Indexes in this object store."]
        pub indexes: Vec<::proto::indexed_db::ObjectStoreIndex<'a>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Object store index."]
    pub struct ObjectStoreIndex<'a> {
        #[serde(rename = "name")]
        #[doc = "Index name."]
        pub name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "keyPath")]
        #[doc = "Index key path."]
        pub key_path: ::proto::indexed_db::KeyPath<'a>,
        #[serde(rename = "unique")]
        #[doc = "If true, index is unique."]
        pub unique: bool,
        #[serde(rename = "multiEntry")]
        #[doc = "If true, index allows multiple entries for a key."]
        pub multi_entry: bool,
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\nUsed in the type of [`cdp::proto::indexed_db::Key::ty`](struct.Key.html#structfield.ty)."]
    pub enum KeyType {
        #[serde(rename = "number")]
        #[doc = "Represented as `\"number\"`."]
        Number,
        #[serde(rename = "string")]
        #[doc = "Represented as `\"string\"`."]
        String,
        #[serde(rename = "date")]
        #[doc = "Represented as `\"date\"`."]
        Date,
        #[serde(rename = "array")]
        #[doc = "Represented as `\"array\"`."]
        Array,
    }
    impl KeyType {
        pub const ENUM_VALUES: &'static [KeyType] = &[
            KeyType::Number,
            KeyType::String,
            KeyType::Date,
            KeyType::Array,
        ];
        pub const STR_VALUES: &'static [&'static str] = &["number", "string", "date", "array"];
    }
    impl ::std::str::FromStr for KeyType {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "number" => Ok(KeyType::Number),
                "string" => Ok(KeyType::String),
                "date" => Ok(KeyType::Date),
                "array" => Ok(KeyType::Array),
                _ => Err(::proto::ParseEnumError {
                    expected: KeyType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for KeyType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    KeyType::Number => "number",
                    KeyType::String => "string",
                    KeyType::Date => "date",
                    KeyType::Array => "array",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Key."]
    pub struct Key<'a> {
        #[serde(rename = "type")]
        #[doc = "Key type."]
        pub ty: ::proto::indexed_db::KeyType,
        #[serde(rename = "number", skip_serializing_if = "Option::is_none")]
        #[doc = "Number value."]
        pub number: Option<f64>,
        #[serde(rename = "string", skip_serializing_if = "Option::is_none")]
        #[doc = "String value."]
        pub string: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "date", skip_serializing_if = "Option::is_none")]
        #[doc = "Date value."]
        pub date: Option<f64>,
        #[serde(rename = "array", skip_serializing_if = "Option::is_none")]
        #[doc = "Array value."]
        pub array: Option<Vec<Box<::proto::indexed_db::Key<'a>>>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Key range."]
    pub struct KeyRange<'a> {
        #[serde(rename = "lower", skip_serializing_if = "Option::is_none")]
        #[doc = "Lower bound."]
        pub lower: Option<::proto::indexed_db::Key<'a>>,
        #[serde(rename = "upper", skip_serializing_if = "Option::is_none")]
        #[doc = "Upper bound."]
        pub upper: Option<::proto::indexed_db::Key<'a>>,
        #[serde(rename = "lowerOpen")]
        #[doc = "If true lower bound is open."]
        pub lower_open: bool,
        #[serde(rename = "upperOpen")]
        #[doc = "If true upper bound is open."]
        pub upper_open: bool,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Data entry."]
    pub struct DataEntry<'a> {
        #[serde(rename = "key")]
        #[doc = "Key object."]
        pub key: ::proto::runtime::RemoteObject<'a>,
        #[serde(rename = "primaryKey")]
        #[doc = "Primary key object."]
        pub primary_key: ::proto::runtime::RemoteObject<'a>,
        #[serde(rename = "value")]
        #[doc = "Value object."]
        pub value: ::proto::runtime::RemoteObject<'a>,
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\nUsed in the type of [`cdp::proto::indexed_db::KeyPath::ty`](struct.KeyPath.html#structfield.ty)."]
    pub enum KeyPathType {
        #[serde(rename = "null")]
        #[doc = "Represented as `\"null\"`."]
        Null,
        #[serde(rename = "string")]
        #[doc = "Represented as `\"string\"`."]
        String,
        #[serde(rename = "array")]
        #[doc = "Represented as `\"array\"`."]
        Array,
    }
    impl KeyPathType {
        pub const ENUM_VALUES: &'static [KeyPathType] =
            &[KeyPathType::Null, KeyPathType::String, KeyPathType::Array];
        pub const STR_VALUES: &'static [&'static str] = &["null", "string", "array"];
    }
    impl ::std::str::FromStr for KeyPathType {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "null" => Ok(KeyPathType::Null),
                "string" => Ok(KeyPathType::String),
                "array" => Ok(KeyPathType::Array),
                _ => Err(::proto::ParseEnumError {
                    expected: KeyPathType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for KeyPathType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    KeyPathType::Null => "null",
                    KeyPathType::String => "string",
                    KeyPathType::Array => "array",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Key path."]
    pub struct KeyPath<'a> {
        #[serde(rename = "type")]
        #[doc = "Key path type."]
        pub ty: ::proto::indexed_db::KeyPathType,
        #[serde(rename = "string", skip_serializing_if = "Option::is_none")]
        #[doc = "String value."]
        pub string: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "array", skip_serializing_if = "Option::is_none")]
        #[doc = "Array value."]
        pub array: Option<Vec<::std::borrow::Cow<'a, str>>>,
    }
}
#[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# CacheStorage\n\n## Commands\n\n- [`CacheStorage.requestCacheNames`](struct.RequestCacheNamesCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Requests cache names.\n- [`CacheStorage.requestEntries`](struct.RequestEntriesCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Requests data from cache.\n- [`CacheStorage.deleteCache`](struct.DeleteCacheCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Deletes a cache.\n- [`CacheStorage.deleteEntry`](struct.DeleteEntryCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Deletes a cache entry.\n\n##Types\n\n- [`CacheId`](type.CacheId.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Unique identifier of the Cache object.\n- [`DataEntry`](struct.DataEntry.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Data entry.\n- [`Cache`](struct.Cache.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Cache identifier.\n"]
pub mod cache_storage {
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Requests cache names.\n\n# Command `CacheStorage.requestCacheNames`\n\n*Domain Module:* [`cdp::proto::cache_storage`](index.html)  \n*Command Struct:* [`cdp::proto::cache_storage::RequestCacheNamesCommand`](struct.RequestCacheNamesCommand.html)  \n*Response Struct:* [`cdp::proto::cache_storage::RequestCacheNamesResponse`](struct.RequestCacheNamesResponse.html)"]
    pub struct RequestCacheNamesCommand<'a> {
        #[serde(rename = "securityOrigin")]
        #[doc = "Security origin."]
        pub security_origin: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpCommand for RequestCacheNamesCommand<'a> {
        fn command_name(&self) -> &str {
            "CacheStorage.requestCacheNames"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for RequestCacheNamesCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CacheStorage.requestCacheNames" {
                Ok ( < RequestCacheNamesCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Requests cache names.\n\n# Command `CacheStorage.requestCacheNames`\n\n*Domain Module:* [`cdp::proto::cache_storage`](index.html)  \n*Command Struct:* [`cdp::proto::cache_storage::RequestCacheNamesCommand`](struct.RequestCacheNamesCommand.html)  \n*Response Struct:* [`cdp::proto::cache_storage::RequestCacheNamesResponse`](struct.RequestCacheNamesResponse.html)"]
    pub struct RequestCacheNamesResponse<'a> {
        #[serde(rename = "caches")]
        #[doc = "Caches for the security origin."]
        pub caches: Vec<::proto::cache_storage::Cache<'a>>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for RequestCacheNamesCommand<'a> {
        type Response = RequestCacheNamesResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for RequestCacheNamesResponse<'a> {
        type Command = RequestCacheNamesCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Requests data from cache.\n\n# Command `CacheStorage.requestEntries`\n\n*Domain Module:* [`cdp::proto::cache_storage`](index.html)  \n*Command Struct:* [`cdp::proto::cache_storage::RequestEntriesCommand`](struct.RequestEntriesCommand.html)  \n*Response Struct:* [`cdp::proto::cache_storage::RequestEntriesResponse`](struct.RequestEntriesResponse.html)"]
    pub struct RequestEntriesCommand<'a> {
        #[serde(rename = "cacheId")]
        #[doc = "ID of cache to get entries from."]
        pub cache_id: ::proto::cache_storage::CacheId<'a>,
        #[serde(rename = "skipCount")]
        #[doc = "Number of records to skip."]
        pub skip_count: i32,
        #[serde(rename = "pageSize")]
        #[doc = "Number of records to fetch."]
        pub page_size: i32,
    }
    impl<'a> ::traits::SerializeCdpCommand for RequestEntriesCommand<'a> {
        fn command_name(&self) -> &str {
            "CacheStorage.requestEntries"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for RequestEntriesCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CacheStorage.requestEntries" {
                Ok(
                    <RequestEntriesCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Requests data from cache.\n\n# Command `CacheStorage.requestEntries`\n\n*Domain Module:* [`cdp::proto::cache_storage`](index.html)  \n*Command Struct:* [`cdp::proto::cache_storage::RequestEntriesCommand`](struct.RequestEntriesCommand.html)  \n*Response Struct:* [`cdp::proto::cache_storage::RequestEntriesResponse`](struct.RequestEntriesResponse.html)"]
    pub struct RequestEntriesResponse<'a> {
        #[serde(rename = "cacheDataEntries")]
        #[doc = "Array of object store data entries."]
        pub cache_data_entries: Vec<::proto::cache_storage::DataEntry<'a>>,
        #[serde(rename = "hasMore")]
        #[doc = "If true, there are more entries to fetch in the given range."]
        pub has_more: bool,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for RequestEntriesCommand<'a> {
        type Response = RequestEntriesResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for RequestEntriesResponse<'a> {
        type Command = RequestEntriesCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Deletes a cache.\n\n# Command `CacheStorage.deleteCache`\n\n*Domain Module:* [`cdp::proto::cache_storage`](index.html)  \n*Command Struct:* [`cdp::proto::cache_storage::DeleteCacheCommand`](struct.DeleteCacheCommand.html)  \n*Response Struct:* [`cdp::proto::cache_storage::DeleteCacheResponse`](struct.DeleteCacheResponse.html)"]
    pub struct DeleteCacheCommand<'a> {
        #[serde(rename = "cacheId")]
        #[doc = "Id of cache for deletion."]
        pub cache_id: ::proto::cache_storage::CacheId<'a>,
    }
    impl<'a> ::traits::SerializeCdpCommand for DeleteCacheCommand<'a> {
        fn command_name(&self) -> &str {
            "CacheStorage.deleteCache"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for DeleteCacheCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CacheStorage.deleteCache" {
                Ok(
                    <DeleteCacheCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Deletes a cache.\n\n# Command `CacheStorage.deleteCache`\n\n*Domain Module:* [`cdp::proto::cache_storage`](index.html)  \n*Command Struct:* [`cdp::proto::cache_storage::DeleteCacheCommand`](struct.DeleteCacheCommand.html)  \n*Response Struct:* [`cdp::proto::cache_storage::DeleteCacheResponse`](struct.DeleteCacheResponse.html)"]
    pub struct DeleteCacheResponse;
    impl ::serde::Serialize for DeleteCacheResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DeleteCacheResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DeleteCacheResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for DeleteCacheCommand<'a> {
        type Response = DeleteCacheResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for DeleteCacheResponse {
        type Command = DeleteCacheCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Deletes a cache entry.\n\n# Command `CacheStorage.deleteEntry`\n\n*Domain Module:* [`cdp::proto::cache_storage`](index.html)  \n*Command Struct:* [`cdp::proto::cache_storage::DeleteEntryCommand`](struct.DeleteEntryCommand.html)  \n*Response Struct:* [`cdp::proto::cache_storage::DeleteEntryResponse`](struct.DeleteEntryResponse.html)"]
    pub struct DeleteEntryCommand<'a> {
        #[serde(rename = "cacheId")]
        #[doc = "Id of cache where the entry will be deleted."]
        pub cache_id: ::proto::cache_storage::CacheId<'a>,
        #[serde(rename = "request")]
        #[doc = "URL spec of the request."]
        pub request: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpCommand for DeleteEntryCommand<'a> {
        fn command_name(&self) -> &str {
            "CacheStorage.deleteEntry"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for DeleteEntryCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CacheStorage.deleteEntry" {
                Ok(
                    <DeleteEntryCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Deletes a cache entry.\n\n# Command `CacheStorage.deleteEntry`\n\n*Domain Module:* [`cdp::proto::cache_storage`](index.html)  \n*Command Struct:* [`cdp::proto::cache_storage::DeleteEntryCommand`](struct.DeleteEntryCommand.html)  \n*Response Struct:* [`cdp::proto::cache_storage::DeleteEntryResponse`](struct.DeleteEntryResponse.html)"]
    pub struct DeleteEntryResponse;
    impl ::serde::Serialize for DeleteEntryResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DeleteEntryResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DeleteEntryResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for DeleteEntryCommand<'a> {
        type Response = DeleteEntryResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for DeleteEntryResponse {
        type Command = DeleteEntryCommand<'a>;
    }
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Unique identifier of the Cache object."]
    pub type CacheId<'a> = ::std::borrow::Cow<'a, str>;
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Data entry."]
    pub struct DataEntry<'a> {
        #[serde(rename = "request")]
        #[doc = "Request url spec."]
        pub request: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "response")]
        #[doc = "Response status text."]
        pub response: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "responseTime")]
        #[doc = "Number of seconds since epoch."]
        pub response_time: f64,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Cache identifier."]
    pub struct Cache<'a> {
        #[serde(rename = "cacheId")]
        #[doc = "An opaque unique id of the cache."]
        pub cache_id: ::proto::cache_storage::CacheId<'a>,
        #[serde(rename = "securityOrigin")]
        #[doc = "Security origin of the cache."]
        pub security_origin: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "cacheName")]
        #[doc = "The name of the cache."]
        pub cache_name: ::std::borrow::Cow<'a, str>,
    }
}
#[doc = "<span class=\"stab unstable\">[Experimental]</span> Query and modify DOM storage.\n\n# DOMStorage\n\n## Commands\n\n- [`DOMStorage.enable`](struct.EnableCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Enables storage tracking, storage events will now be delivered to the client.\n- [`DOMStorage.disable`](struct.DisableCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Disables storage tracking, prevents storage events from being sent to the client.\n- [`DOMStorage.clear`](struct.ClearCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`DOMStorage.getDOMStorageItems`](struct.GetDomStorageItemsCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`DOMStorage.setDOMStorageItem`](struct.SetDomStorageItemCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`DOMStorage.removeDOMStorageItem`](struct.RemoveDomStorageItemCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n## Events\n\n- [`DOMStorage.domStorageItemsCleared`](struct.DomStorageItemsClearedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`DOMStorage.domStorageItemRemoved`](struct.DomStorageItemRemovedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`DOMStorage.domStorageItemAdded`](struct.DomStorageItemAddedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`DOMStorage.domStorageItemUpdated`](struct.DomStorageItemUpdatedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n##Types\n\n- [`StorageId`](struct.StorageId.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  DOM Storage identifier.\n- [`Item`](type.Item.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  DOM Storage item.\n"]
pub mod dom_storage {
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables storage tracking, storage events will now be delivered to the client.\n\n# Command `DOMStorage.enable`\n\n*Domain Module:* [`cdp::proto::dom_storage`](index.html)  \n*Command Struct:* [`cdp::proto::dom_storage::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::proto::dom_storage::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableCommand;
    impl ::serde::Serialize for EnableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for EnableCommand {
        fn command_name(&self) -> &str {
            "DOMStorage.enable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for EnableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOMStorage.enable" {
                Ok(
                    <EnableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables storage tracking, storage events will now be delivered to the client.\n\n# Command `DOMStorage.enable`\n\n*Domain Module:* [`cdp::proto::dom_storage`](index.html)  \n*Command Struct:* [`cdp::proto::dom_storage::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::proto::dom_storage::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableResponse;
    impl ::serde::Serialize for EnableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for EnableCommand {
        type Response = EnableResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for EnableResponse {
        type Command = EnableCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Disables storage tracking, prevents storage events from being sent to the client.\n\n# Command `DOMStorage.disable`\n\n*Domain Module:* [`cdp::proto::dom_storage`](index.html)  \n*Command Struct:* [`cdp::proto::dom_storage::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::proto::dom_storage::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableCommand;
    impl ::serde::Serialize for DisableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for DisableCommand {
        fn command_name(&self) -> &str {
            "DOMStorage.disable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for DisableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOMStorage.disable" {
                Ok(
                    <DisableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Disables storage tracking, prevents storage events from being sent to the client.\n\n# Command `DOMStorage.disable`\n\n*Domain Module:* [`cdp::proto::dom_storage`](index.html)  \n*Command Struct:* [`cdp::proto::dom_storage::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::proto::dom_storage::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableResponse;
    impl ::serde::Serialize for DisableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for DisableCommand {
        type Response = DisableResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for DisableResponse {
        type Command = DisableCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `DOMStorage.clear`\n\n*Domain Module:* [`cdp::proto::dom_storage`](index.html)  \n*Command Struct:* [`cdp::proto::dom_storage::ClearCommand`](struct.ClearCommand.html)  \n*Response Struct:* [`cdp::proto::dom_storage::ClearResponse`](struct.ClearResponse.html)"]
    pub struct ClearCommand<'a> {
        #[serde(rename = "storageId")]
        pub storage_id: ::proto::dom_storage::StorageId<'a>,
    }
    impl<'a> ::traits::SerializeCdpCommand for ClearCommand<'a> {
        fn command_name(&self) -> &str {
            "DOMStorage.clear"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for ClearCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOMStorage.clear" {
                Ok(
                    <ClearCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `DOMStorage.clear`\n\n*Domain Module:* [`cdp::proto::dom_storage`](index.html)  \n*Command Struct:* [`cdp::proto::dom_storage::ClearCommand`](struct.ClearCommand.html)  \n*Response Struct:* [`cdp::proto::dom_storage::ClearResponse`](struct.ClearResponse.html)"]
    pub struct ClearResponse;
    impl ::serde::Serialize for ClearResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ClearResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ClearResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for ClearCommand<'a> {
        type Response = ClearResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for ClearResponse {
        type Command = ClearCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `DOMStorage.getDOMStorageItems`\n\n*Domain Module:* [`cdp::proto::dom_storage`](index.html)  \n*Command Struct:* [`cdp::proto::dom_storage::GetDomStorageItemsCommand`](struct.GetDomStorageItemsCommand.html)  \n*Response Struct:* [`cdp::proto::dom_storage::GetDomStorageItemsResponse`](struct.GetDomStorageItemsResponse.html)"]
    pub struct GetDomStorageItemsCommand<'a> {
        #[serde(rename = "storageId")]
        pub storage_id: ::proto::dom_storage::StorageId<'a>,
    }
    impl<'a> ::traits::SerializeCdpCommand for GetDomStorageItemsCommand<'a> {
        fn command_name(&self) -> &str {
            "DOMStorage.getDOMStorageItems"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for GetDomStorageItemsCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOMStorage.getDOMStorageItems" {
                Ok ( < GetDomStorageItemsCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `DOMStorage.getDOMStorageItems`\n\n*Domain Module:* [`cdp::proto::dom_storage`](index.html)  \n*Command Struct:* [`cdp::proto::dom_storage::GetDomStorageItemsCommand`](struct.GetDomStorageItemsCommand.html)  \n*Response Struct:* [`cdp::proto::dom_storage::GetDomStorageItemsResponse`](struct.GetDomStorageItemsResponse.html)"]
    pub struct GetDomStorageItemsResponse<'a> {
        #[serde(rename = "entries")]
        pub entries: Vec<::proto::dom_storage::Item<'a>>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for GetDomStorageItemsCommand<'a> {
        type Response = GetDomStorageItemsResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for GetDomStorageItemsResponse<'a> {
        type Command = GetDomStorageItemsCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `DOMStorage.setDOMStorageItem`\n\n*Domain Module:* [`cdp::proto::dom_storage`](index.html)  \n*Command Struct:* [`cdp::proto::dom_storage::SetDomStorageItemCommand`](struct.SetDomStorageItemCommand.html)  \n*Response Struct:* [`cdp::proto::dom_storage::SetDomStorageItemResponse`](struct.SetDomStorageItemResponse.html)"]
    pub struct SetDomStorageItemCommand<'a> {
        #[serde(rename = "storageId")]
        pub storage_id: ::proto::dom_storage::StorageId<'a>,
        #[serde(rename = "key")]
        pub key: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "value")]
        pub value: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpCommand for SetDomStorageItemCommand<'a> {
        fn command_name(&self) -> &str {
            "DOMStorage.setDOMStorageItem"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for SetDomStorageItemCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOMStorage.setDOMStorageItem" {
                Ok ( < SetDomStorageItemCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `DOMStorage.setDOMStorageItem`\n\n*Domain Module:* [`cdp::proto::dom_storage`](index.html)  \n*Command Struct:* [`cdp::proto::dom_storage::SetDomStorageItemCommand`](struct.SetDomStorageItemCommand.html)  \n*Response Struct:* [`cdp::proto::dom_storage::SetDomStorageItemResponse`](struct.SetDomStorageItemResponse.html)"]
    pub struct SetDomStorageItemResponse;
    impl ::serde::Serialize for SetDomStorageItemResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetDomStorageItemResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetDomStorageItemResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetDomStorageItemCommand<'a> {
        type Response = SetDomStorageItemResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetDomStorageItemResponse {
        type Command = SetDomStorageItemCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `DOMStorage.removeDOMStorageItem`\n\n*Domain Module:* [`cdp::proto::dom_storage`](index.html)  \n*Command Struct:* [`cdp::proto::dom_storage::RemoveDomStorageItemCommand`](struct.RemoveDomStorageItemCommand.html)  \n*Response Struct:* [`cdp::proto::dom_storage::RemoveDomStorageItemResponse`](struct.RemoveDomStorageItemResponse.html)"]
    pub struct RemoveDomStorageItemCommand<'a> {
        #[serde(rename = "storageId")]
        pub storage_id: ::proto::dom_storage::StorageId<'a>,
        #[serde(rename = "key")]
        pub key: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpCommand for RemoveDomStorageItemCommand<'a> {
        fn command_name(&self) -> &str {
            "DOMStorage.removeDOMStorageItem"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for RemoveDomStorageItemCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOMStorage.removeDOMStorageItem" {
                Ok ( < RemoveDomStorageItemCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `DOMStorage.removeDOMStorageItem`\n\n*Domain Module:* [`cdp::proto::dom_storage`](index.html)  \n*Command Struct:* [`cdp::proto::dom_storage::RemoveDomStorageItemCommand`](struct.RemoveDomStorageItemCommand.html)  \n*Response Struct:* [`cdp::proto::dom_storage::RemoveDomStorageItemResponse`](struct.RemoveDomStorageItemResponse.html)"]
    pub struct RemoveDomStorageItemResponse;
    impl ::serde::Serialize for RemoveDomStorageItemResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for RemoveDomStorageItemResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| RemoveDomStorageItemResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for RemoveDomStorageItemCommand<'a> {
        type Response = RemoveDomStorageItemResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for RemoveDomStorageItemResponse {
        type Command = RemoveDomStorageItemCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Event `DOMStorage.domStorageItemsCleared`\n\n*Domain Module:* [`cdp::proto::dom_storage`](index.html)  \n*Event Struct:* [`cdp::proto::dom_storage::DomStorageItemsClearedEvent`](struct.DomStorageItemsClearedEvent.html)"]
    pub struct DomStorageItemsClearedEvent<'a> {
        #[serde(rename = "storageId")]
        pub storage_id: ::proto::dom_storage::StorageId<'a>,
    }
    impl<'a> ::traits::SerializeCdpEvent for DomStorageItemsClearedEvent<'a> {
        fn event_name(&self) -> &str {
            "DOMStorage.domStorageItemsCleared"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for DomStorageItemsClearedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOMStorage.domStorageItemsCleared" {
                Ok ( < DomStorageItemsClearedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Event `DOMStorage.domStorageItemRemoved`\n\n*Domain Module:* [`cdp::proto::dom_storage`](index.html)  \n*Event Struct:* [`cdp::proto::dom_storage::DomStorageItemRemovedEvent`](struct.DomStorageItemRemovedEvent.html)"]
    pub struct DomStorageItemRemovedEvent<'a> {
        #[serde(rename = "storageId")]
        pub storage_id: ::proto::dom_storage::StorageId<'a>,
        #[serde(rename = "key")]
        pub key: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpEvent for DomStorageItemRemovedEvent<'a> {
        fn event_name(&self) -> &str {
            "DOMStorage.domStorageItemRemoved"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for DomStorageItemRemovedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOMStorage.domStorageItemRemoved" {
                Ok ( < DomStorageItemRemovedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Event `DOMStorage.domStorageItemAdded`\n\n*Domain Module:* [`cdp::proto::dom_storage`](index.html)  \n*Event Struct:* [`cdp::proto::dom_storage::DomStorageItemAddedEvent`](struct.DomStorageItemAddedEvent.html)"]
    pub struct DomStorageItemAddedEvent<'a> {
        #[serde(rename = "storageId")]
        pub storage_id: ::proto::dom_storage::StorageId<'a>,
        #[serde(rename = "key")]
        pub key: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "newValue")]
        pub new_value: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpEvent for DomStorageItemAddedEvent<'a> {
        fn event_name(&self) -> &str {
            "DOMStorage.domStorageItemAdded"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for DomStorageItemAddedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOMStorage.domStorageItemAdded" {
                Ok ( < DomStorageItemAddedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Event `DOMStorage.domStorageItemUpdated`\n\n*Domain Module:* [`cdp::proto::dom_storage`](index.html)  \n*Event Struct:* [`cdp::proto::dom_storage::DomStorageItemUpdatedEvent`](struct.DomStorageItemUpdatedEvent.html)"]
    pub struct DomStorageItemUpdatedEvent<'a> {
        #[serde(rename = "storageId")]
        pub storage_id: ::proto::dom_storage::StorageId<'a>,
        #[serde(rename = "key")]
        pub key: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "oldValue")]
        pub old_value: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "newValue")]
        pub new_value: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpEvent for DomStorageItemUpdatedEvent<'a> {
        fn event_name(&self) -> &str {
            "DOMStorage.domStorageItemUpdated"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for DomStorageItemUpdatedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOMStorage.domStorageItemUpdated" {
                Ok ( < DomStorageItemUpdatedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> DOM Storage identifier."]
    pub struct StorageId<'a> {
        #[serde(rename = "securityOrigin")]
        #[doc = "Security origin for the storage."]
        pub security_origin: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "isLocalStorage")]
        #[doc = "Whether the storage is local storage \\(not session storage\\)."]
        pub is_local_storage: bool,
    }
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> DOM Storage item."]
    pub type Item<'a> = Vec<::std::borrow::Cow<'a, str>>;
}
#[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# ApplicationCache\n\n## Commands\n\n- [`ApplicationCache.getFramesWithManifests`](struct.GetFramesWithManifestsCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns array of frame identifiers with manifest urls for each frame containing a document associated with some application cache.\n- [`ApplicationCache.enable`](struct.EnableCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Enables application cache domain notifications.\n- [`ApplicationCache.getManifestForFrame`](struct.GetManifestForFrameCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns manifest URL for document in the given frame.\n- [`ApplicationCache.getApplicationCacheForFrame`](struct.GetApplicationCacheForFrameCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns relevant application cache data for the document in given frame.\n\n## Events\n\n- [`ApplicationCache.applicationCacheStatusUpdated`](struct.ApplicationCacheStatusUpdatedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`ApplicationCache.networkStateUpdated`](struct.NetworkStateUpdatedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n##Types\n\n- [`ApplicationCacheResource`](struct.ApplicationCacheResource.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Detailed application cache resource information.\n- [`ApplicationCache`](struct.ApplicationCache.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Detailed application cache information.\n- [`FrameWithManifest`](struct.FrameWithManifest.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Frame identifier - manifest URL pair.\n"]
pub mod application_cache {
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns array of frame identifiers with manifest urls for each frame containing a document associated with some application cache.\n\n# Command `ApplicationCache.getFramesWithManifests`\n\n*Domain Module:* [`cdp::proto::application_cache`](index.html)  \n*Command Struct:* [`cdp::proto::application_cache::GetFramesWithManifestsCommand`](struct.GetFramesWithManifestsCommand.html)  \n*Response Struct:* [`cdp::proto::application_cache::GetFramesWithManifestsResponse`](struct.GetFramesWithManifestsResponse.html)"]
    pub struct GetFramesWithManifestsCommand;
    impl ::serde::Serialize for GetFramesWithManifestsCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetFramesWithManifestsCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| GetFramesWithManifestsCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for GetFramesWithManifestsCommand {
        fn command_name(&self) -> &str {
            "ApplicationCache.getFramesWithManifests"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for GetFramesWithManifestsCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "ApplicationCache.getFramesWithManifests" {
                Ok ( < GetFramesWithManifestsCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns array of frame identifiers with manifest urls for each frame containing a document associated with some application cache.\n\n# Command `ApplicationCache.getFramesWithManifests`\n\n*Domain Module:* [`cdp::proto::application_cache`](index.html)  \n*Command Struct:* [`cdp::proto::application_cache::GetFramesWithManifestsCommand`](struct.GetFramesWithManifestsCommand.html)  \n*Response Struct:* [`cdp::proto::application_cache::GetFramesWithManifestsResponse`](struct.GetFramesWithManifestsResponse.html)"]
    pub struct GetFramesWithManifestsResponse<'a> {
        #[serde(rename = "frameIds")]
        #[doc = "Array of frame identifiers with manifest urls for each frame containing a document associated with some application cache."]
        pub frame_ids: Vec<::proto::application_cache::FrameWithManifest<'a>>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for GetFramesWithManifestsCommand {
        type Response = GetFramesWithManifestsResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for GetFramesWithManifestsResponse<'a> {
        type Command = GetFramesWithManifestsCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables application cache domain notifications.\n\n# Command `ApplicationCache.enable`\n\n*Domain Module:* [`cdp::proto::application_cache`](index.html)  \n*Command Struct:* [`cdp::proto::application_cache::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::proto::application_cache::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableCommand;
    impl ::serde::Serialize for EnableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for EnableCommand {
        fn command_name(&self) -> &str {
            "ApplicationCache.enable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for EnableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "ApplicationCache.enable" {
                Ok(
                    <EnableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables application cache domain notifications.\n\n# Command `ApplicationCache.enable`\n\n*Domain Module:* [`cdp::proto::application_cache`](index.html)  \n*Command Struct:* [`cdp::proto::application_cache::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::proto::application_cache::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableResponse;
    impl ::serde::Serialize for EnableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for EnableCommand {
        type Response = EnableResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for EnableResponse {
        type Command = EnableCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns manifest URL for document in the given frame.\n\n# Command `ApplicationCache.getManifestForFrame`\n\n*Domain Module:* [`cdp::proto::application_cache`](index.html)  \n*Command Struct:* [`cdp::proto::application_cache::GetManifestForFrameCommand`](struct.GetManifestForFrameCommand.html)  \n*Response Struct:* [`cdp::proto::application_cache::GetManifestForFrameResponse`](struct.GetManifestForFrameResponse.html)"]
    pub struct GetManifestForFrameCommand<'a> {
        #[serde(rename = "frameId")]
        #[doc = "Identifier of the frame containing document whose manifest is retrieved."]
        pub frame_id: ::proto::page::FrameId<'a>,
    }
    impl<'a> ::traits::SerializeCdpCommand for GetManifestForFrameCommand<'a> {
        fn command_name(&self) -> &str {
            "ApplicationCache.getManifestForFrame"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for GetManifestForFrameCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "ApplicationCache.getManifestForFrame" {
                Ok ( < GetManifestForFrameCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns manifest URL for document in the given frame.\n\n# Command `ApplicationCache.getManifestForFrame`\n\n*Domain Module:* [`cdp::proto::application_cache`](index.html)  \n*Command Struct:* [`cdp::proto::application_cache::GetManifestForFrameCommand`](struct.GetManifestForFrameCommand.html)  \n*Response Struct:* [`cdp::proto::application_cache::GetManifestForFrameResponse`](struct.GetManifestForFrameResponse.html)"]
    pub struct GetManifestForFrameResponse<'a> {
        #[serde(rename = "manifestURL")]
        #[doc = "Manifest URL for document in the given frame."]
        pub manifest_url: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for GetManifestForFrameCommand<'a> {
        type Response = GetManifestForFrameResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for GetManifestForFrameResponse<'a> {
        type Command = GetManifestForFrameCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns relevant application cache data for the document in given frame.\n\n# Command `ApplicationCache.getApplicationCacheForFrame`\n\n*Domain Module:* [`cdp::proto::application_cache`](index.html)  \n*Command Struct:* [`cdp::proto::application_cache::GetApplicationCacheForFrameCommand`](struct.GetApplicationCacheForFrameCommand.html)  \n*Response Struct:* [`cdp::proto::application_cache::GetApplicationCacheForFrameResponse`](struct.GetApplicationCacheForFrameResponse.html)"]
    pub struct GetApplicationCacheForFrameCommand<'a> {
        #[serde(rename = "frameId")]
        #[doc = "Identifier of the frame containing document whose application cache is retrieved."]
        pub frame_id: ::proto::page::FrameId<'a>,
    }
    impl<'a> ::traits::SerializeCdpCommand for GetApplicationCacheForFrameCommand<'a> {
        fn command_name(&self) -> &str {
            "ApplicationCache.getApplicationCacheForFrame"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for GetApplicationCacheForFrameCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "ApplicationCache.getApplicationCacheForFrame" {
                Ok ( < GetApplicationCacheForFrameCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns relevant application cache data for the document in given frame.\n\n# Command `ApplicationCache.getApplicationCacheForFrame`\n\n*Domain Module:* [`cdp::proto::application_cache`](index.html)  \n*Command Struct:* [`cdp::proto::application_cache::GetApplicationCacheForFrameCommand`](struct.GetApplicationCacheForFrameCommand.html)  \n*Response Struct:* [`cdp::proto::application_cache::GetApplicationCacheForFrameResponse`](struct.GetApplicationCacheForFrameResponse.html)"]
    pub struct GetApplicationCacheForFrameResponse<'a> {
        #[serde(rename = "applicationCache")]
        #[doc = "Relevant application cache data for the document in given frame."]
        pub application_cache: ::proto::application_cache::ApplicationCache<'a>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for GetApplicationCacheForFrameCommand<'a> {
        type Response = GetApplicationCacheForFrameResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for GetApplicationCacheForFrameResponse<'a> {
        type Command = GetApplicationCacheForFrameCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Event `ApplicationCache.applicationCacheStatusUpdated`\n\n*Domain Module:* [`cdp::proto::application_cache`](index.html)  \n*Event Struct:* [`cdp::proto::application_cache::ApplicationCacheStatusUpdatedEvent`](struct.ApplicationCacheStatusUpdatedEvent.html)"]
    pub struct ApplicationCacheStatusUpdatedEvent<'a> {
        #[serde(rename = "frameId")]
        #[doc = "Identifier of the frame containing document whose application cache updated status."]
        pub frame_id: ::proto::page::FrameId<'a>,
        #[serde(rename = "manifestURL")]
        #[doc = "Manifest URL."]
        pub manifest_url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "status")]
        #[doc = "Updated application cache status."]
        pub status: i32,
    }
    impl<'a> ::traits::SerializeCdpEvent for ApplicationCacheStatusUpdatedEvent<'a> {
        fn event_name(&self) -> &str {
            "ApplicationCache.applicationCacheStatusUpdated"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for ApplicationCacheStatusUpdatedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "ApplicationCache.applicationCacheStatusUpdated" {
                Ok ( < ApplicationCacheStatusUpdatedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Event `ApplicationCache.networkStateUpdated`\n\n*Domain Module:* [`cdp::proto::application_cache`](index.html)  \n*Event Struct:* [`cdp::proto::application_cache::NetworkStateUpdatedEvent`](struct.NetworkStateUpdatedEvent.html)"]
    pub struct NetworkStateUpdatedEvent {
        #[serde(rename = "isNowOnline")]
        pub is_now_online: bool,
    }
    impl ::traits::SerializeCdpEvent for NetworkStateUpdatedEvent {
        fn event_name(&self) -> &str {
            "ApplicationCache.networkStateUpdated"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpEvent<'de> for NetworkStateUpdatedEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "ApplicationCache.networkStateUpdated" {
                Ok ( < NetworkStateUpdatedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Detailed application cache resource information."]
    pub struct ApplicationCacheResource<'a> {
        #[serde(rename = "url")]
        #[doc = "Resource url."]
        pub url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "size")]
        #[doc = "Resource size."]
        pub size: i32,
        #[serde(rename = "type")]
        #[doc = "Resource type."]
        pub ty: ::std::borrow::Cow<'a, str>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Detailed application cache information."]
    pub struct ApplicationCache<'a> {
        #[serde(rename = "manifestURL")]
        #[doc = "Manifest URL."]
        pub manifest_url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "size")]
        #[doc = "Application cache size."]
        pub size: f64,
        #[serde(rename = "creationTime")]
        #[doc = "Application cache creation time."]
        pub creation_time: f64,
        #[serde(rename = "updateTime")]
        #[doc = "Application cache update time."]
        pub update_time: f64,
        #[serde(rename = "resources")]
        #[doc = "Application cache resources."]
        pub resources: Vec<::proto::application_cache::ApplicationCacheResource<'a>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Frame identifier - manifest URL pair."]
    pub struct FrameWithManifest<'a> {
        #[serde(rename = "frameId")]
        #[doc = "Frame identifier."]
        pub frame_id: ::proto::page::FrameId<'a>,
        #[serde(rename = "manifestURL")]
        #[doc = "Manifest URL."]
        pub manifest_url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "status")]
        #[doc = "Application cache status."]
        pub status: i32,
    }
}
#[doc = "This domain exposes DOM read/write operations. Each DOM Node is represented with its mirror object that has an <code>id</code>. This <code>id</code> can be used to get additional information on the Node, resolve it into the JavaScript object wrapper, etc. It is important that client receives DOM events only for the nodes that are known to the client. Backend keeps track of the nodes that were sent to the client and never sends the same node twice. It is client's responsibility to collect information about the nodes that were sent to the client.<p>Note that <code>iframe</code> owner elements will return corresponding document elements as their child nodes.</p>\n\n# DOM\n\n## Commands\n\n- [`DOM.enable`](struct.EnableCommand.html)\n\n  Enables DOM agent for the given page.\n- [`DOM.disable`](struct.DisableCommand.html)\n\n  Disables DOM agent for the given page.\n- [`DOM.getDocument`](struct.GetDocumentCommand.html)\n\n  Returns the root DOM node \\(and optionally the subtree\\) to the caller.\n- [`DOM.getFlattenedDocument`](struct.GetFlattenedDocumentCommand.html)\n\n  Returns the root DOM node \\(and optionally the subtree\\) to the caller.\n- [`DOM.collectClassNamesFromSubtree`](struct.CollectClassNamesFromSubtreeCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Collects class names for the node with given id and all of it's child nodes.\n- [`DOM.requestChildNodes`](struct.RequestChildNodesCommand.html)\n\n  Requests that children of the node with given id are returned to the caller in form of <code>setChildNodes</code> events where not only immediate children are retrieved, but all children down to the specified depth.\n- [`DOM.querySelector`](struct.QuerySelectorCommand.html)\n\n  Executes <code>querySelector</code> on a given node.\n- [`DOM.querySelectorAll`](struct.QuerySelectorAllCommand.html)\n\n  Executes <code>querySelectorAll</code> on a given node.\n- [`DOM.setNodeName`](struct.SetNodeNameCommand.html)\n\n  Sets node name for a node with given id.\n- [`DOM.setNodeValue`](struct.SetNodeValueCommand.html)\n\n  Sets node value for a node with given id.\n- [`DOM.removeNode`](struct.RemoveNodeCommand.html)\n\n  Removes node with given id.\n- [`DOM.setAttributeValue`](struct.SetAttributeValueCommand.html)\n\n  Sets attribute for an element with given id.\n- [`DOM.setAttributesAsText`](struct.SetAttributesAsTextCommand.html)\n\n  Sets attributes on element with given id. This method is useful when user edits some existing attribute value and types in several attribute name/value pairs.\n- [`DOM.removeAttribute`](struct.RemoveAttributeCommand.html)\n\n  Removes attribute with given name from an element with given id.\n- [`DOM.getOuterHTML`](struct.GetOuterHtmlCommand.html)\n\n  Returns node's HTML markup.\n- [`DOM.setOuterHTML`](struct.SetOuterHtmlCommand.html)\n\n  Sets node HTML markup, returns new node id.\n- [`DOM.performSearch`](struct.PerformSearchCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Searches for a given string in the DOM tree. Use <code>getSearchResults</code> to access search results or <code>cancelSearch</code> to end this search session.\n- [`DOM.getSearchResults`](struct.GetSearchResultsCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns search results from given <code>fromIndex</code> to given <code>toIndex</code> from the sarch with the given identifier.\n- [`DOM.discardSearchResults`](struct.DiscardSearchResultsCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Discards search results from the session with the given id. <code>getSearchResults</code> should no longer be called for that search.\n- [`DOM.requestNode`](struct.RequestNodeCommand.html)\n\n  Requests that the node is sent to the caller given the JavaScript node object reference. All nodes that form the path from the node to the root are also sent to the client as a series of <code>setChildNodes</code> notifications.\n- [`DOM.highlightRect`](struct.HighlightRectCommand.html)\n\n  Highlights given rectangle.\n- [`DOM.highlightNode`](struct.HighlightNodeCommand.html)\n\n  Highlights DOM node.\n- [`DOM.hideHighlight`](struct.HideHighlightCommand.html)\n\n  Hides any highlight.\n- [`DOM.pushNodeByPathToFrontend`](struct.PushNodeByPathToFrontendCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Requests that the node is sent to the caller given its path. // FIXME, use XPath\n- [`DOM.pushNodesByBackendIdsToFrontend`](struct.PushNodesByBackendIdsToFrontendCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Requests that a batch of nodes is sent to the caller given their backend node ids.\n- [`DOM.setInspectedNode`](struct.SetInspectedNodeCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Enables console to refer to the node with given id via $x \\(see Command Line API for more details $x functions\\).\n- [`DOM.resolveNode`](struct.ResolveNodeCommand.html)\n\n  Resolves the JavaScript node object for a given NodeId or BackendNodeId.\n- [`DOM.getAttributes`](struct.GetAttributesCommand.html)\n\n  Returns attributes for the specified node.\n- [`DOM.copyTo`](struct.CopyToCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Creates a deep copy of the specified node and places it into the target container before the given anchor.\n- [`DOM.moveTo`](struct.MoveToCommand.html)\n\n  Moves node into the new container, places it before the given anchor.\n- [`DOM.undo`](struct.UndoCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Undoes the last performed action.\n- [`DOM.redo`](struct.RedoCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Re-does the last undone action.\n- [`DOM.markUndoableState`](struct.MarkUndoableStateCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Marks last undoable state.\n- [`DOM.focus`](struct.FocusCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Focuses the given element.\n- [`DOM.setFileInputFiles`](struct.SetFileInputFilesCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Sets files for the given file input element.\n- [`DOM.getBoxModel`](struct.GetBoxModelCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns boxes for the currently selected nodes.\n- [`DOM.getNodeForLocation`](struct.GetNodeForLocationCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns node id at given location.\n- [`DOM.getRelayoutBoundary`](struct.GetRelayoutBoundaryCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns the id of the nearest ancestor that is a relayout boundary.\n\n## Events\n\n- [`DOM.documentUpdated`](struct.DocumentUpdatedEvent.html)\n\n  Fired when <code>Document</code> has been totally updated. Node ids are no longer valid.\n- [`DOM.setChildNodes`](struct.SetChildNodesEvent.html)\n\n  Fired when backend wants to provide client with the missing DOM structure. This happens upon most of the calls requesting node ids.\n- [`DOM.attributeModified`](struct.AttributeModifiedEvent.html)\n\n  Fired when <code>Element</code>'s attribute is modified.\n- [`DOM.attributeRemoved`](struct.AttributeRemovedEvent.html)\n\n  Fired when <code>Element</code>'s attribute is removed.\n- [`DOM.inlineStyleInvalidated`](struct.InlineStyleInvalidatedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Fired when <code>Element</code>'s inline style is modified via a CSS property modification.\n- [`DOM.characterDataModified`](struct.CharacterDataModifiedEvent.html)\n\n  Mirrors <code>DOMCharacterDataModified</code> event.\n- [`DOM.childNodeCountUpdated`](struct.ChildNodeCountUpdatedEvent.html)\n\n  Fired when <code>Container</code>'s child node count has changed.\n- [`DOM.childNodeInserted`](struct.ChildNodeInsertedEvent.html)\n\n  Mirrors <code>DOMNodeInserted</code> event.\n- [`DOM.childNodeRemoved`](struct.ChildNodeRemovedEvent.html)\n\n  Mirrors <code>DOMNodeRemoved</code> event.\n- [`DOM.shadowRootPushed`](struct.ShadowRootPushedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Called when shadow root is pushed into the element.\n- [`DOM.shadowRootPopped`](struct.ShadowRootPoppedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Called when shadow root is popped from the element.\n- [`DOM.pseudoElementAdded`](struct.PseudoElementAddedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Called when a pseudo element is added to an element.\n- [`DOM.pseudoElementRemoved`](struct.PseudoElementRemovedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Called when a pseudo element is removed from an element.\n- [`DOM.distributedNodesUpdated`](struct.DistributedNodesUpdatedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Called when distrubution is changed.\n\n##Types\n\n- [`NodeId`](type.NodeId.html)\n\n  Unique DOM node identifier.\n- [`BackendNodeId`](type.BackendNodeId.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Unique DOM node identifier used to reference a node that may not have been pushed to the front-end.\n- [`BackendNode`](struct.BackendNode.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Backend node with a friendly name.\n- [`PseudoType`](enum.PseudoType.html)\n\n  Pseudo element type.\n- [`ShadowRootType`](enum.ShadowRootType.html)\n\n  Shadow root type.\n- [`Node`](struct.Node.html)\n\n  DOM interaction is implemented in terms of mirror objects that represent the actual DOM nodes. DOMNode is a base node mirror type.\n- [`RGBA`](struct.Rgba.html)\n\n  A structure holding an RGBA color.\n- [`Quad`](type.Quad.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  An array of quad vertices, x immediately followed by y for each point, points clock-wise.\n- [`BoxModel`](struct.BoxModel.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Box model.\n- [`ShapeOutsideInfo`](struct.ShapeOutsideInfo.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  CSS Shape Outside details.\n- [`Rect`](struct.Rect.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Rectangle.\n"]
pub mod dom {
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Enables DOM agent for the given page.\n\n# Command `DOM.enable`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::proto::dom::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableCommand;
    impl ::serde::Serialize for EnableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for EnableCommand {
        fn command_name(&self) -> &str {
            "DOM.enable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for EnableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.enable" {
                Ok(
                    <EnableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Enables DOM agent for the given page.\n\n# Command `DOM.enable`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::proto::dom::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableResponse;
    impl ::serde::Serialize for EnableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for EnableCommand {
        type Response = EnableResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for EnableResponse {
        type Command = EnableCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Disables DOM agent for the given page.\n\n# Command `DOM.disable`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::proto::dom::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableCommand;
    impl ::serde::Serialize for DisableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for DisableCommand {
        fn command_name(&self) -> &str {
            "DOM.disable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for DisableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.disable" {
                Ok(
                    <DisableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Disables DOM agent for the given page.\n\n# Command `DOM.disable`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::proto::dom::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableResponse;
    impl ::serde::Serialize for DisableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for DisableCommand {
        type Response = DisableResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for DisableResponse {
        type Command = DisableCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Returns the root DOM node \\(and optionally the subtree\\) to the caller.\n\n# Command `DOM.getDocument`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::GetDocumentCommand`](struct.GetDocumentCommand.html)  \n*Response Struct:* [`cdp::proto::dom::GetDocumentResponse`](struct.GetDocumentResponse.html)"]
    pub struct GetDocumentCommand {
        #[serde(rename = "depth", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0."]
        pub depth: Option<i32>,
        #[serde(rename = "pierce", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Whether or not iframes and shadow roots should be traversed when returning the subtree \\(default is false\\)."]
        pub pierce: Option<bool>,
    }
    impl ::traits::SerializeCdpCommand for GetDocumentCommand {
        fn command_name(&self) -> &str {
            "DOM.getDocument"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for GetDocumentCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.getDocument" {
                Ok(
                    <GetDocumentCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Returns the root DOM node \\(and optionally the subtree\\) to the caller.\n\n# Command `DOM.getDocument`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::GetDocumentCommand`](struct.GetDocumentCommand.html)  \n*Response Struct:* [`cdp::proto::dom::GetDocumentResponse`](struct.GetDocumentResponse.html)"]
    pub struct GetDocumentResponse<'a> {
        #[serde(rename = "root")]
        #[doc = "Resulting node."]
        pub root: ::proto::dom::Node<'a>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for GetDocumentCommand {
        type Response = GetDocumentResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for GetDocumentResponse<'a> {
        type Command = GetDocumentCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Returns the root DOM node \\(and optionally the subtree\\) to the caller.\n\n# Command `DOM.getFlattenedDocument`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::GetFlattenedDocumentCommand`](struct.GetFlattenedDocumentCommand.html)  \n*Response Struct:* [`cdp::proto::dom::GetFlattenedDocumentResponse`](struct.GetFlattenedDocumentResponse.html)"]
    pub struct GetFlattenedDocumentCommand {
        #[serde(rename = "depth", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0."]
        pub depth: Option<i32>,
        #[serde(rename = "pierce", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Whether or not iframes and shadow roots should be traversed when returning the subtree \\(default is false\\)."]
        pub pierce: Option<bool>,
    }
    impl ::traits::SerializeCdpCommand for GetFlattenedDocumentCommand {
        fn command_name(&self) -> &str {
            "DOM.getFlattenedDocument"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for GetFlattenedDocumentCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.getFlattenedDocument" {
                Ok ( < GetFlattenedDocumentCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Returns the root DOM node \\(and optionally the subtree\\) to the caller.\n\n# Command `DOM.getFlattenedDocument`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::GetFlattenedDocumentCommand`](struct.GetFlattenedDocumentCommand.html)  \n*Response Struct:* [`cdp::proto::dom::GetFlattenedDocumentResponse`](struct.GetFlattenedDocumentResponse.html)"]
    pub struct GetFlattenedDocumentResponse<'a> {
        #[serde(rename = "nodes")]
        #[doc = "Resulting node."]
        pub nodes: Vec<::proto::dom::Node<'a>>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for GetFlattenedDocumentCommand {
        type Response = GetFlattenedDocumentResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for GetFlattenedDocumentResponse<'a> {
        type Command = GetFlattenedDocumentCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Collects class names for the node with given id and all of it's child nodes.\n\n# Command `DOM.collectClassNamesFromSubtree`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::CollectClassNamesFromSubtreeCommand`](struct.CollectClassNamesFromSubtreeCommand.html)  \n*Response Struct:* [`cdp::proto::dom::CollectClassNamesFromSubtreeResponse`](struct.CollectClassNamesFromSubtreeResponse.html)"]
    pub struct CollectClassNamesFromSubtreeCommand {
        #[serde(rename = "nodeId")]
        #[doc = "Id of the node to collect class names."]
        pub node_id: ::proto::dom::NodeId,
    }
    impl ::traits::SerializeCdpCommand for CollectClassNamesFromSubtreeCommand {
        fn command_name(&self) -> &str {
            "DOM.collectClassNamesFromSubtree"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for CollectClassNamesFromSubtreeCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.collectClassNamesFromSubtree" {
                Ok ( < CollectClassNamesFromSubtreeCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Collects class names for the node with given id and all of it's child nodes.\n\n# Command `DOM.collectClassNamesFromSubtree`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::CollectClassNamesFromSubtreeCommand`](struct.CollectClassNamesFromSubtreeCommand.html)  \n*Response Struct:* [`cdp::proto::dom::CollectClassNamesFromSubtreeResponse`](struct.CollectClassNamesFromSubtreeResponse.html)"]
    pub struct CollectClassNamesFromSubtreeResponse<'a> {
        #[serde(rename = "classNames")]
        #[doc = "Class name list."]
        pub class_names: Vec<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for CollectClassNamesFromSubtreeCommand {
        type Response = CollectClassNamesFromSubtreeResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for CollectClassNamesFromSubtreeResponse<'a> {
        type Command = CollectClassNamesFromSubtreeCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Requests that children of the node with given id are returned to the caller in form of <code>setChildNodes</code> events where not only immediate children are retrieved, but all children down to the specified depth.\n\n# Command `DOM.requestChildNodes`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::RequestChildNodesCommand`](struct.RequestChildNodesCommand.html)  \n*Response Struct:* [`cdp::proto::dom::RequestChildNodesResponse`](struct.RequestChildNodesResponse.html)"]
    pub struct RequestChildNodesCommand {
        #[serde(rename = "nodeId")]
        #[doc = "Id of the node to get children for."]
        pub node_id: ::proto::dom::NodeId,
        #[serde(rename = "depth", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0."]
        pub depth: Option<i32>,
        #[serde(rename = "pierce", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Whether or not iframes and shadow roots should be traversed when returning the sub-tree \\(default is false\\)."]
        pub pierce: Option<bool>,
    }
    impl ::traits::SerializeCdpCommand for RequestChildNodesCommand {
        fn command_name(&self) -> &str {
            "DOM.requestChildNodes"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for RequestChildNodesCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.requestChildNodes" {
                Ok ( < RequestChildNodesCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Requests that children of the node with given id are returned to the caller in form of <code>setChildNodes</code> events where not only immediate children are retrieved, but all children down to the specified depth.\n\n# Command `DOM.requestChildNodes`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::RequestChildNodesCommand`](struct.RequestChildNodesCommand.html)  \n*Response Struct:* [`cdp::proto::dom::RequestChildNodesResponse`](struct.RequestChildNodesResponse.html)"]
    pub struct RequestChildNodesResponse;
    impl ::serde::Serialize for RequestChildNodesResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for RequestChildNodesResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| RequestChildNodesResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for RequestChildNodesCommand {
        type Response = RequestChildNodesResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for RequestChildNodesResponse {
        type Command = RequestChildNodesCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Executes <code>querySelector</code> on a given node.\n\n# Command `DOM.querySelector`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::QuerySelectorCommand`](struct.QuerySelectorCommand.html)  \n*Response Struct:* [`cdp::proto::dom::QuerySelectorResponse`](struct.QuerySelectorResponse.html)"]
    pub struct QuerySelectorCommand<'a> {
        #[serde(rename = "nodeId")]
        #[doc = "Id of the node to query upon."]
        pub node_id: ::proto::dom::NodeId,
        #[serde(rename = "selector")]
        #[doc = "Selector string."]
        pub selector: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpCommand for QuerySelectorCommand<'a> {
        fn command_name(&self) -> &str {
            "DOM.querySelector"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for QuerySelectorCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.querySelector" {
                Ok(
                    <QuerySelectorCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Executes <code>querySelector</code> on a given node.\n\n# Command `DOM.querySelector`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::QuerySelectorCommand`](struct.QuerySelectorCommand.html)  \n*Response Struct:* [`cdp::proto::dom::QuerySelectorResponse`](struct.QuerySelectorResponse.html)"]
    pub struct QuerySelectorResponse {
        #[serde(rename = "nodeId")]
        #[doc = "Query selector result."]
        pub node_id: ::proto::dom::NodeId,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for QuerySelectorCommand<'a> {
        type Response = QuerySelectorResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for QuerySelectorResponse {
        type Command = QuerySelectorCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Executes <code>querySelectorAll</code> on a given node.\n\n# Command `DOM.querySelectorAll`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::QuerySelectorAllCommand`](struct.QuerySelectorAllCommand.html)  \n*Response Struct:* [`cdp::proto::dom::QuerySelectorAllResponse`](struct.QuerySelectorAllResponse.html)"]
    pub struct QuerySelectorAllCommand<'a> {
        #[serde(rename = "nodeId")]
        #[doc = "Id of the node to query upon."]
        pub node_id: ::proto::dom::NodeId,
        #[serde(rename = "selector")]
        #[doc = "Selector string."]
        pub selector: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpCommand for QuerySelectorAllCommand<'a> {
        fn command_name(&self) -> &str {
            "DOM.querySelectorAll"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for QuerySelectorAllCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.querySelectorAll" {
                Ok ( < QuerySelectorAllCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Executes <code>querySelectorAll</code> on a given node.\n\n# Command `DOM.querySelectorAll`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::QuerySelectorAllCommand`](struct.QuerySelectorAllCommand.html)  \n*Response Struct:* [`cdp::proto::dom::QuerySelectorAllResponse`](struct.QuerySelectorAllResponse.html)"]
    pub struct QuerySelectorAllResponse {
        #[serde(rename = "nodeIds")]
        #[doc = "Query selector result."]
        pub node_ids: Vec<::proto::dom::NodeId>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for QuerySelectorAllCommand<'a> {
        type Response = QuerySelectorAllResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for QuerySelectorAllResponse {
        type Command = QuerySelectorAllCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Sets node name for a node with given id.\n\n# Command `DOM.setNodeName`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::SetNodeNameCommand`](struct.SetNodeNameCommand.html)  \n*Response Struct:* [`cdp::proto::dom::SetNodeNameResponse`](struct.SetNodeNameResponse.html)"]
    pub struct SetNodeNameCommand<'a> {
        #[serde(rename = "nodeId")]
        #[doc = "Id of the node to set name for."]
        pub node_id: ::proto::dom::NodeId,
        #[serde(rename = "name")]
        #[doc = "New node's name."]
        pub name: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpCommand for SetNodeNameCommand<'a> {
        fn command_name(&self) -> &str {
            "DOM.setNodeName"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for SetNodeNameCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.setNodeName" {
                Ok(
                    <SetNodeNameCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Sets node name for a node with given id.\n\n# Command `DOM.setNodeName`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::SetNodeNameCommand`](struct.SetNodeNameCommand.html)  \n*Response Struct:* [`cdp::proto::dom::SetNodeNameResponse`](struct.SetNodeNameResponse.html)"]
    pub struct SetNodeNameResponse {
        #[serde(rename = "nodeId")]
        #[doc = "New node's id."]
        pub node_id: ::proto::dom::NodeId,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetNodeNameCommand<'a> {
        type Response = SetNodeNameResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetNodeNameResponse {
        type Command = SetNodeNameCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Sets node value for a node with given id.\n\n# Command `DOM.setNodeValue`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::SetNodeValueCommand`](struct.SetNodeValueCommand.html)  \n*Response Struct:* [`cdp::proto::dom::SetNodeValueResponse`](struct.SetNodeValueResponse.html)"]
    pub struct SetNodeValueCommand<'a> {
        #[serde(rename = "nodeId")]
        #[doc = "Id of the node to set value for."]
        pub node_id: ::proto::dom::NodeId,
        #[serde(rename = "value")]
        #[doc = "New node's value."]
        pub value: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpCommand for SetNodeValueCommand<'a> {
        fn command_name(&self) -> &str {
            "DOM.setNodeValue"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for SetNodeValueCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.setNodeValue" {
                Ok(
                    <SetNodeValueCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Sets node value for a node with given id.\n\n# Command `DOM.setNodeValue`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::SetNodeValueCommand`](struct.SetNodeValueCommand.html)  \n*Response Struct:* [`cdp::proto::dom::SetNodeValueResponse`](struct.SetNodeValueResponse.html)"]
    pub struct SetNodeValueResponse;
    impl ::serde::Serialize for SetNodeValueResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetNodeValueResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetNodeValueResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetNodeValueCommand<'a> {
        type Response = SetNodeValueResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetNodeValueResponse {
        type Command = SetNodeValueCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Removes node with given id.\n\n# Command `DOM.removeNode`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::RemoveNodeCommand`](struct.RemoveNodeCommand.html)  \n*Response Struct:* [`cdp::proto::dom::RemoveNodeResponse`](struct.RemoveNodeResponse.html)"]
    pub struct RemoveNodeCommand {
        #[serde(rename = "nodeId")]
        #[doc = "Id of the node to remove."]
        pub node_id: ::proto::dom::NodeId,
    }
    impl ::traits::SerializeCdpCommand for RemoveNodeCommand {
        fn command_name(&self) -> &str {
            "DOM.removeNode"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for RemoveNodeCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.removeNode" {
                Ok(
                    <RemoveNodeCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Removes node with given id.\n\n# Command `DOM.removeNode`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::RemoveNodeCommand`](struct.RemoveNodeCommand.html)  \n*Response Struct:* [`cdp::proto::dom::RemoveNodeResponse`](struct.RemoveNodeResponse.html)"]
    pub struct RemoveNodeResponse;
    impl ::serde::Serialize for RemoveNodeResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for RemoveNodeResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| RemoveNodeResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for RemoveNodeCommand {
        type Response = RemoveNodeResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for RemoveNodeResponse {
        type Command = RemoveNodeCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Sets attribute for an element with given id.\n\n# Command `DOM.setAttributeValue`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::SetAttributeValueCommand`](struct.SetAttributeValueCommand.html)  \n*Response Struct:* [`cdp::proto::dom::SetAttributeValueResponse`](struct.SetAttributeValueResponse.html)"]
    pub struct SetAttributeValueCommand<'a> {
        #[serde(rename = "nodeId")]
        #[doc = "Id of the element to set attribute for."]
        pub node_id: ::proto::dom::NodeId,
        #[serde(rename = "name")]
        #[doc = "Attribute name."]
        pub name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "value")]
        #[doc = "Attribute value."]
        pub value: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpCommand for SetAttributeValueCommand<'a> {
        fn command_name(&self) -> &str {
            "DOM.setAttributeValue"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for SetAttributeValueCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.setAttributeValue" {
                Ok ( < SetAttributeValueCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Sets attribute for an element with given id.\n\n# Command `DOM.setAttributeValue`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::SetAttributeValueCommand`](struct.SetAttributeValueCommand.html)  \n*Response Struct:* [`cdp::proto::dom::SetAttributeValueResponse`](struct.SetAttributeValueResponse.html)"]
    pub struct SetAttributeValueResponse;
    impl ::serde::Serialize for SetAttributeValueResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetAttributeValueResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetAttributeValueResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetAttributeValueCommand<'a> {
        type Response = SetAttributeValueResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetAttributeValueResponse {
        type Command = SetAttributeValueCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Sets attributes on element with given id. This method is useful when user edits some existing attribute value and types in several attribute name/value pairs.\n\n# Command `DOM.setAttributesAsText`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::SetAttributesAsTextCommand`](struct.SetAttributesAsTextCommand.html)  \n*Response Struct:* [`cdp::proto::dom::SetAttributesAsTextResponse`](struct.SetAttributesAsTextResponse.html)"]
    pub struct SetAttributesAsTextCommand<'a> {
        #[serde(rename = "nodeId")]
        #[doc = "Id of the element to set attributes for."]
        pub node_id: ::proto::dom::NodeId,
        #[serde(rename = "text")]
        #[doc = "Text with a number of attributes. Will parse this text using HTML parser."]
        pub text: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "name", skip_serializing_if = "Option::is_none")]
        #[doc = "Attribute name to replace with new attributes derived from text in case text parsed successfully."]
        pub name: Option<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::traits::SerializeCdpCommand for SetAttributesAsTextCommand<'a> {
        fn command_name(&self) -> &str {
            "DOM.setAttributesAsText"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for SetAttributesAsTextCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.setAttributesAsText" {
                Ok ( < SetAttributesAsTextCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Sets attributes on element with given id. This method is useful when user edits some existing attribute value and types in several attribute name/value pairs.\n\n# Command `DOM.setAttributesAsText`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::SetAttributesAsTextCommand`](struct.SetAttributesAsTextCommand.html)  \n*Response Struct:* [`cdp::proto::dom::SetAttributesAsTextResponse`](struct.SetAttributesAsTextResponse.html)"]
    pub struct SetAttributesAsTextResponse;
    impl ::serde::Serialize for SetAttributesAsTextResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetAttributesAsTextResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetAttributesAsTextResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetAttributesAsTextCommand<'a> {
        type Response = SetAttributesAsTextResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetAttributesAsTextResponse {
        type Command = SetAttributesAsTextCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Removes attribute with given name from an element with given id.\n\n# Command `DOM.removeAttribute`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::RemoveAttributeCommand`](struct.RemoveAttributeCommand.html)  \n*Response Struct:* [`cdp::proto::dom::RemoveAttributeResponse`](struct.RemoveAttributeResponse.html)"]
    pub struct RemoveAttributeCommand<'a> {
        #[serde(rename = "nodeId")]
        #[doc = "Id of the element to remove attribute from."]
        pub node_id: ::proto::dom::NodeId,
        #[serde(rename = "name")]
        #[doc = "Name of the attribute to remove."]
        pub name: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpCommand for RemoveAttributeCommand<'a> {
        fn command_name(&self) -> &str {
            "DOM.removeAttribute"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for RemoveAttributeCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.removeAttribute" {
                Ok(
                    <RemoveAttributeCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Removes attribute with given name from an element with given id.\n\n# Command `DOM.removeAttribute`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::RemoveAttributeCommand`](struct.RemoveAttributeCommand.html)  \n*Response Struct:* [`cdp::proto::dom::RemoveAttributeResponse`](struct.RemoveAttributeResponse.html)"]
    pub struct RemoveAttributeResponse;
    impl ::serde::Serialize for RemoveAttributeResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for RemoveAttributeResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| RemoveAttributeResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for RemoveAttributeCommand<'a> {
        type Response = RemoveAttributeResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for RemoveAttributeResponse {
        type Command = RemoveAttributeCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Returns node's HTML markup.\n\n# Command `DOM.getOuterHTML`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::GetOuterHtmlCommand`](struct.GetOuterHtmlCommand.html)  \n*Response Struct:* [`cdp::proto::dom::GetOuterHtmlResponse`](struct.GetOuterHtmlResponse.html)"]
    pub struct GetOuterHtmlCommand {
        #[serde(rename = "nodeId")]
        #[doc = "Id of the node to get markup for."]
        pub node_id: ::proto::dom::NodeId,
    }
    impl ::traits::SerializeCdpCommand for GetOuterHtmlCommand {
        fn command_name(&self) -> &str {
            "DOM.getOuterHTML"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for GetOuterHtmlCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.getOuterHTML" {
                Ok(
                    <GetOuterHtmlCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Returns node's HTML markup.\n\n# Command `DOM.getOuterHTML`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::GetOuterHtmlCommand`](struct.GetOuterHtmlCommand.html)  \n*Response Struct:* [`cdp::proto::dom::GetOuterHtmlResponse`](struct.GetOuterHtmlResponse.html)"]
    pub struct GetOuterHtmlResponse<'a> {
        #[serde(rename = "outerHTML")]
        #[doc = "Outer HTML markup."]
        pub outer_html: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for GetOuterHtmlCommand {
        type Response = GetOuterHtmlResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for GetOuterHtmlResponse<'a> {
        type Command = GetOuterHtmlCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Sets node HTML markup, returns new node id.\n\n# Command `DOM.setOuterHTML`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::SetOuterHtmlCommand`](struct.SetOuterHtmlCommand.html)  \n*Response Struct:* [`cdp::proto::dom::SetOuterHtmlResponse`](struct.SetOuterHtmlResponse.html)"]
    pub struct SetOuterHtmlCommand<'a> {
        #[serde(rename = "nodeId")]
        #[doc = "Id of the node to set markup for."]
        pub node_id: ::proto::dom::NodeId,
        #[serde(rename = "outerHTML")]
        #[doc = "Outer HTML markup to set."]
        pub outer_html: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpCommand for SetOuterHtmlCommand<'a> {
        fn command_name(&self) -> &str {
            "DOM.setOuterHTML"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for SetOuterHtmlCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.setOuterHTML" {
                Ok(
                    <SetOuterHtmlCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Sets node HTML markup, returns new node id.\n\n# Command `DOM.setOuterHTML`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::SetOuterHtmlCommand`](struct.SetOuterHtmlCommand.html)  \n*Response Struct:* [`cdp::proto::dom::SetOuterHtmlResponse`](struct.SetOuterHtmlResponse.html)"]
    pub struct SetOuterHtmlResponse;
    impl ::serde::Serialize for SetOuterHtmlResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetOuterHtmlResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetOuterHtmlResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetOuterHtmlCommand<'a> {
        type Response = SetOuterHtmlResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetOuterHtmlResponse {
        type Command = SetOuterHtmlCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Searches for a given string in the DOM tree. Use <code>getSearchResults</code> to access search results or <code>cancelSearch</code> to end this search session.\n\n# Command `DOM.performSearch`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::PerformSearchCommand`](struct.PerformSearchCommand.html)  \n*Response Struct:* [`cdp::proto::dom::PerformSearchResponse`](struct.PerformSearchResponse.html)"]
    pub struct PerformSearchCommand<'a> {
        #[serde(rename = "query")]
        #[doc = "Plain text or query selector or XPath search query."]
        pub query: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "includeUserAgentShadowDOM", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> True to search in user agent shadow DOM."]
        pub include_user_agent_shadow_dom: Option<bool>,
    }
    impl<'a> ::traits::SerializeCdpCommand for PerformSearchCommand<'a> {
        fn command_name(&self) -> &str {
            "DOM.performSearch"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for PerformSearchCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.performSearch" {
                Ok(
                    <PerformSearchCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Searches for a given string in the DOM tree. Use <code>getSearchResults</code> to access search results or <code>cancelSearch</code> to end this search session.\n\n# Command `DOM.performSearch`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::PerformSearchCommand`](struct.PerformSearchCommand.html)  \n*Response Struct:* [`cdp::proto::dom::PerformSearchResponse`](struct.PerformSearchResponse.html)"]
    pub struct PerformSearchResponse<'a> {
        #[serde(rename = "searchId")]
        #[doc = "Unique search session identifier."]
        pub search_id: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "resultCount")]
        #[doc = "Number of search results."]
        pub result_count: i32,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for PerformSearchCommand<'a> {
        type Response = PerformSearchResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for PerformSearchResponse<'a> {
        type Command = PerformSearchCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns search results from given <code>fromIndex</code> to given <code>toIndex</code> from the sarch with the given identifier.\n\n# Command `DOM.getSearchResults`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::GetSearchResultsCommand`](struct.GetSearchResultsCommand.html)  \n*Response Struct:* [`cdp::proto::dom::GetSearchResultsResponse`](struct.GetSearchResultsResponse.html)"]
    pub struct GetSearchResultsCommand<'a> {
        #[serde(rename = "searchId")]
        #[doc = "Unique search session identifier."]
        pub search_id: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "fromIndex")]
        #[doc = "Start index of the search result to be returned."]
        pub from_index: i32,
        #[serde(rename = "toIndex")]
        #[doc = "End index of the search result to be returned."]
        pub to_index: i32,
    }
    impl<'a> ::traits::SerializeCdpCommand for GetSearchResultsCommand<'a> {
        fn command_name(&self) -> &str {
            "DOM.getSearchResults"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for GetSearchResultsCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.getSearchResults" {
                Ok ( < GetSearchResultsCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns search results from given <code>fromIndex</code> to given <code>toIndex</code> from the sarch with the given identifier.\n\n# Command `DOM.getSearchResults`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::GetSearchResultsCommand`](struct.GetSearchResultsCommand.html)  \n*Response Struct:* [`cdp::proto::dom::GetSearchResultsResponse`](struct.GetSearchResultsResponse.html)"]
    pub struct GetSearchResultsResponse {
        #[serde(rename = "nodeIds")]
        #[doc = "Ids of the search result nodes."]
        pub node_ids: Vec<::proto::dom::NodeId>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for GetSearchResultsCommand<'a> {
        type Response = GetSearchResultsResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for GetSearchResultsResponse {
        type Command = GetSearchResultsCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Discards search results from the session with the given id. <code>getSearchResults</code> should no longer be called for that search.\n\n# Command `DOM.discardSearchResults`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::DiscardSearchResultsCommand`](struct.DiscardSearchResultsCommand.html)  \n*Response Struct:* [`cdp::proto::dom::DiscardSearchResultsResponse`](struct.DiscardSearchResultsResponse.html)"]
    pub struct DiscardSearchResultsCommand<'a> {
        #[serde(rename = "searchId")]
        #[doc = "Unique search session identifier."]
        pub search_id: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpCommand for DiscardSearchResultsCommand<'a> {
        fn command_name(&self) -> &str {
            "DOM.discardSearchResults"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for DiscardSearchResultsCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.discardSearchResults" {
                Ok ( < DiscardSearchResultsCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Discards search results from the session with the given id. <code>getSearchResults</code> should no longer be called for that search.\n\n# Command `DOM.discardSearchResults`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::DiscardSearchResultsCommand`](struct.DiscardSearchResultsCommand.html)  \n*Response Struct:* [`cdp::proto::dom::DiscardSearchResultsResponse`](struct.DiscardSearchResultsResponse.html)"]
    pub struct DiscardSearchResultsResponse;
    impl ::serde::Serialize for DiscardSearchResultsResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DiscardSearchResultsResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DiscardSearchResultsResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for DiscardSearchResultsCommand<'a> {
        type Response = DiscardSearchResultsResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for DiscardSearchResultsResponse {
        type Command = DiscardSearchResultsCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Requests that the node is sent to the caller given the JavaScript node object reference. All nodes that form the path from the node to the root are also sent to the client as a series of <code>setChildNodes</code> notifications.\n\n# Command `DOM.requestNode`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::RequestNodeCommand`](struct.RequestNodeCommand.html)  \n*Response Struct:* [`cdp::proto::dom::RequestNodeResponse`](struct.RequestNodeResponse.html)"]
    pub struct RequestNodeCommand<'a> {
        #[serde(rename = "objectId")]
        #[doc = "JavaScript object id to convert into node."]
        pub object_id: ::proto::runtime::RemoteObjectId<'a>,
    }
    impl<'a> ::traits::SerializeCdpCommand for RequestNodeCommand<'a> {
        fn command_name(&self) -> &str {
            "DOM.requestNode"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for RequestNodeCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.requestNode" {
                Ok(
                    <RequestNodeCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Requests that the node is sent to the caller given the JavaScript node object reference. All nodes that form the path from the node to the root are also sent to the client as a series of <code>setChildNodes</code> notifications.\n\n# Command `DOM.requestNode`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::RequestNodeCommand`](struct.RequestNodeCommand.html)  \n*Response Struct:* [`cdp::proto::dom::RequestNodeResponse`](struct.RequestNodeResponse.html)"]
    pub struct RequestNodeResponse {
        #[serde(rename = "nodeId")]
        #[doc = "Node id for given object."]
        pub node_id: ::proto::dom::NodeId,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for RequestNodeCommand<'a> {
        type Response = RequestNodeResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for RequestNodeResponse {
        type Command = RequestNodeCommand<'a>;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Highlights given rectangle.\n\n# Command `DOM.highlightRect`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::HighlightRectCommand`](struct.HighlightRectCommand.html)  \n*Response Struct:* [`cdp::proto::dom::HighlightRectResponse`](struct.HighlightRectResponse.html)"]
    pub struct HighlightRectCommand;
    impl ::serde::Serialize for HighlightRectCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for HighlightRectCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| HighlightRectCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for HighlightRectCommand {
        fn command_name(&self) -> &str {
            "DOM.highlightRect"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for HighlightRectCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.highlightRect" {
                Ok(
                    <HighlightRectCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Highlights given rectangle.\n\n# Command `DOM.highlightRect`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::HighlightRectCommand`](struct.HighlightRectCommand.html)  \n*Response Struct:* [`cdp::proto::dom::HighlightRectResponse`](struct.HighlightRectResponse.html)"]
    pub struct HighlightRectResponse;
    impl ::serde::Serialize for HighlightRectResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for HighlightRectResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| HighlightRectResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for HighlightRectCommand {
        type Response = HighlightRectResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for HighlightRectResponse {
        type Command = HighlightRectCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Highlights DOM node.\n\n# Command `DOM.highlightNode`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::HighlightNodeCommand`](struct.HighlightNodeCommand.html)  \n*Response Struct:* [`cdp::proto::dom::HighlightNodeResponse`](struct.HighlightNodeResponse.html)"]
    pub struct HighlightNodeCommand;
    impl ::serde::Serialize for HighlightNodeCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for HighlightNodeCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| HighlightNodeCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for HighlightNodeCommand {
        fn command_name(&self) -> &str {
            "DOM.highlightNode"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for HighlightNodeCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.highlightNode" {
                Ok(
                    <HighlightNodeCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Highlights DOM node.\n\n# Command `DOM.highlightNode`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::HighlightNodeCommand`](struct.HighlightNodeCommand.html)  \n*Response Struct:* [`cdp::proto::dom::HighlightNodeResponse`](struct.HighlightNodeResponse.html)"]
    pub struct HighlightNodeResponse;
    impl ::serde::Serialize for HighlightNodeResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for HighlightNodeResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| HighlightNodeResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for HighlightNodeCommand {
        type Response = HighlightNodeResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for HighlightNodeResponse {
        type Command = HighlightNodeCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Hides any highlight.\n\n# Command `DOM.hideHighlight`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::HideHighlightCommand`](struct.HideHighlightCommand.html)  \n*Response Struct:* [`cdp::proto::dom::HideHighlightResponse`](struct.HideHighlightResponse.html)"]
    pub struct HideHighlightCommand;
    impl ::serde::Serialize for HideHighlightCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for HideHighlightCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| HideHighlightCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for HideHighlightCommand {
        fn command_name(&self) -> &str {
            "DOM.hideHighlight"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for HideHighlightCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.hideHighlight" {
                Ok(
                    <HideHighlightCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Hides any highlight.\n\n# Command `DOM.hideHighlight`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::HideHighlightCommand`](struct.HideHighlightCommand.html)  \n*Response Struct:* [`cdp::proto::dom::HideHighlightResponse`](struct.HideHighlightResponse.html)"]
    pub struct HideHighlightResponse;
    impl ::serde::Serialize for HideHighlightResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for HideHighlightResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| HideHighlightResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for HideHighlightCommand {
        type Response = HideHighlightResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for HideHighlightResponse {
        type Command = HideHighlightCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Requests that the node is sent to the caller given its path. // FIXME, use XPath\n\n# Command `DOM.pushNodeByPathToFrontend`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::PushNodeByPathToFrontendCommand`](struct.PushNodeByPathToFrontendCommand.html)  \n*Response Struct:* [`cdp::proto::dom::PushNodeByPathToFrontendResponse`](struct.PushNodeByPathToFrontendResponse.html)"]
    pub struct PushNodeByPathToFrontendCommand<'a> {
        #[serde(rename = "path")]
        #[doc = "Path to node in the proprietary format."]
        pub path: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpCommand for PushNodeByPathToFrontendCommand<'a> {
        fn command_name(&self) -> &str {
            "DOM.pushNodeByPathToFrontend"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for PushNodeByPathToFrontendCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.pushNodeByPathToFrontend" {
                Ok ( < PushNodeByPathToFrontendCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Requests that the node is sent to the caller given its path. // FIXME, use XPath\n\n# Command `DOM.pushNodeByPathToFrontend`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::PushNodeByPathToFrontendCommand`](struct.PushNodeByPathToFrontendCommand.html)  \n*Response Struct:* [`cdp::proto::dom::PushNodeByPathToFrontendResponse`](struct.PushNodeByPathToFrontendResponse.html)"]
    pub struct PushNodeByPathToFrontendResponse {
        #[serde(rename = "nodeId")]
        #[doc = "Id of the node for given path."]
        pub node_id: ::proto::dom::NodeId,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for PushNodeByPathToFrontendCommand<'a> {
        type Response = PushNodeByPathToFrontendResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for PushNodeByPathToFrontendResponse {
        type Command = PushNodeByPathToFrontendCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Requests that a batch of nodes is sent to the caller given their backend node ids.\n\n# Command `DOM.pushNodesByBackendIdsToFrontend`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::PushNodesByBackendIdsToFrontendCommand`](struct.PushNodesByBackendIdsToFrontendCommand.html)  \n*Response Struct:* [`cdp::proto::dom::PushNodesByBackendIdsToFrontendResponse`](struct.PushNodesByBackendIdsToFrontendResponse.html)"]
    pub struct PushNodesByBackendIdsToFrontendCommand {
        #[serde(rename = "backendNodeIds")]
        #[doc = "The array of backend node ids."]
        pub backend_node_ids: Vec<::proto::dom::BackendNodeId>,
    }
    impl ::traits::SerializeCdpCommand for PushNodesByBackendIdsToFrontendCommand {
        fn command_name(&self) -> &str {
            "DOM.pushNodesByBackendIdsToFrontend"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for PushNodesByBackendIdsToFrontendCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.pushNodesByBackendIdsToFrontend" {
                Ok ( < PushNodesByBackendIdsToFrontendCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Requests that a batch of nodes is sent to the caller given their backend node ids.\n\n# Command `DOM.pushNodesByBackendIdsToFrontend`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::PushNodesByBackendIdsToFrontendCommand`](struct.PushNodesByBackendIdsToFrontendCommand.html)  \n*Response Struct:* [`cdp::proto::dom::PushNodesByBackendIdsToFrontendResponse`](struct.PushNodesByBackendIdsToFrontendResponse.html)"]
    pub struct PushNodesByBackendIdsToFrontendResponse {
        #[serde(rename = "nodeIds")]
        #[doc = "The array of ids of pushed nodes that correspond to the backend ids specified in backendNodeIds."]
        pub node_ids: Vec<::proto::dom::NodeId>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for PushNodesByBackendIdsToFrontendCommand {
        type Response = PushNodesByBackendIdsToFrontendResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for PushNodesByBackendIdsToFrontendResponse {
        type Command = PushNodesByBackendIdsToFrontendCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables console to refer to the node with given id via $x \\(see Command Line API for more details $x functions\\).\n\n# Command `DOM.setInspectedNode`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::SetInspectedNodeCommand`](struct.SetInspectedNodeCommand.html)  \n*Response Struct:* [`cdp::proto::dom::SetInspectedNodeResponse`](struct.SetInspectedNodeResponse.html)"]
    pub struct SetInspectedNodeCommand {
        #[serde(rename = "nodeId")]
        #[doc = "DOM node id to be accessible by means of $x command line API."]
        pub node_id: ::proto::dom::NodeId,
    }
    impl ::traits::SerializeCdpCommand for SetInspectedNodeCommand {
        fn command_name(&self) -> &str {
            "DOM.setInspectedNode"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for SetInspectedNodeCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.setInspectedNode" {
                Ok ( < SetInspectedNodeCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables console to refer to the node with given id via $x \\(see Command Line API for more details $x functions\\).\n\n# Command `DOM.setInspectedNode`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::SetInspectedNodeCommand`](struct.SetInspectedNodeCommand.html)  \n*Response Struct:* [`cdp::proto::dom::SetInspectedNodeResponse`](struct.SetInspectedNodeResponse.html)"]
    pub struct SetInspectedNodeResponse;
    impl ::serde::Serialize for SetInspectedNodeResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetInspectedNodeResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetInspectedNodeResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetInspectedNodeCommand {
        type Response = SetInspectedNodeResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetInspectedNodeResponse {
        type Command = SetInspectedNodeCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Resolves the JavaScript node object for a given NodeId or BackendNodeId.\n\n# Command `DOM.resolveNode`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::ResolveNodeCommand`](struct.ResolveNodeCommand.html)  \n*Response Struct:* [`cdp::proto::dom::ResolveNodeResponse`](struct.ResolveNodeResponse.html)"]
    pub struct ResolveNodeCommand<'a> {
        #[serde(rename = "nodeId", skip_serializing_if = "Option::is_none")]
        #[doc = "Id of the node to resolve."]
        pub node_id: Option<::proto::dom::NodeId>,
        #[serde(rename = "backendNodeId", skip_serializing_if = "Option::is_none")]
        #[doc = "Backend identifier of the node to resolve."]
        pub backend_node_id: Option<::proto::dom::BackendNodeId>,
        #[serde(rename = "objectGroup", skip_serializing_if = "Option::is_none")]
        #[doc = "Symbolic group name that can be used to release multiple objects."]
        pub object_group: Option<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::traits::SerializeCdpCommand for ResolveNodeCommand<'a> {
        fn command_name(&self) -> &str {
            "DOM.resolveNode"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for ResolveNodeCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.resolveNode" {
                Ok(
                    <ResolveNodeCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Resolves the JavaScript node object for a given NodeId or BackendNodeId.\n\n# Command `DOM.resolveNode`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::ResolveNodeCommand`](struct.ResolveNodeCommand.html)  \n*Response Struct:* [`cdp::proto::dom::ResolveNodeResponse`](struct.ResolveNodeResponse.html)"]
    pub struct ResolveNodeResponse<'a> {
        #[serde(rename = "object")]
        #[doc = "JavaScript object wrapper for given node."]
        pub object: ::proto::runtime::RemoteObject<'a>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for ResolveNodeCommand<'a> {
        type Response = ResolveNodeResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for ResolveNodeResponse<'a> {
        type Command = ResolveNodeCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Returns attributes for the specified node.\n\n# Command `DOM.getAttributes`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::GetAttributesCommand`](struct.GetAttributesCommand.html)  \n*Response Struct:* [`cdp::proto::dom::GetAttributesResponse`](struct.GetAttributesResponse.html)"]
    pub struct GetAttributesCommand {
        #[serde(rename = "nodeId")]
        #[doc = "Id of the node to retrieve attibutes for."]
        pub node_id: ::proto::dom::NodeId,
    }
    impl ::traits::SerializeCdpCommand for GetAttributesCommand {
        fn command_name(&self) -> &str {
            "DOM.getAttributes"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for GetAttributesCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.getAttributes" {
                Ok(
                    <GetAttributesCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Returns attributes for the specified node.\n\n# Command `DOM.getAttributes`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::GetAttributesCommand`](struct.GetAttributesCommand.html)  \n*Response Struct:* [`cdp::proto::dom::GetAttributesResponse`](struct.GetAttributesResponse.html)"]
    pub struct GetAttributesResponse<'a> {
        #[serde(rename = "attributes")]
        #[doc = "An interleaved array of node attribute names and values."]
        pub attributes: Vec<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for GetAttributesCommand {
        type Response = GetAttributesResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for GetAttributesResponse<'a> {
        type Command = GetAttributesCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Creates a deep copy of the specified node and places it into the target container before the given anchor.\n\n# Command `DOM.copyTo`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::CopyToCommand`](struct.CopyToCommand.html)  \n*Response Struct:* [`cdp::proto::dom::CopyToResponse`](struct.CopyToResponse.html)"]
    pub struct CopyToCommand {
        #[serde(rename = "nodeId")]
        #[doc = "Id of the node to copy."]
        pub node_id: ::proto::dom::NodeId,
        #[serde(rename = "targetNodeId")]
        #[doc = "Id of the element to drop the copy into."]
        pub target_node_id: ::proto::dom::NodeId,
        #[serde(rename = "insertBeforeNodeId", skip_serializing_if = "Option::is_none")]
        #[doc = "Drop the copy before this node \\(if absent, the copy becomes the last child of <code>targetNodeId</code>\\)."]
        pub insert_before_node_id: Option<::proto::dom::NodeId>,
    }
    impl ::traits::SerializeCdpCommand for CopyToCommand {
        fn command_name(&self) -> &str {
            "DOM.copyTo"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for CopyToCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.copyTo" {
                Ok(
                    <CopyToCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Creates a deep copy of the specified node and places it into the target container before the given anchor.\n\n# Command `DOM.copyTo`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::CopyToCommand`](struct.CopyToCommand.html)  \n*Response Struct:* [`cdp::proto::dom::CopyToResponse`](struct.CopyToResponse.html)"]
    pub struct CopyToResponse {
        #[serde(rename = "nodeId")]
        #[doc = "Id of the node clone."]
        pub node_id: ::proto::dom::NodeId,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for CopyToCommand {
        type Response = CopyToResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for CopyToResponse {
        type Command = CopyToCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Moves node into the new container, places it before the given anchor.\n\n# Command `DOM.moveTo`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::MoveToCommand`](struct.MoveToCommand.html)  \n*Response Struct:* [`cdp::proto::dom::MoveToResponse`](struct.MoveToResponse.html)"]
    pub struct MoveToCommand {
        #[serde(rename = "nodeId")]
        #[doc = "Id of the node to move."]
        pub node_id: ::proto::dom::NodeId,
        #[serde(rename = "targetNodeId")]
        #[doc = "Id of the element to drop the moved node into."]
        pub target_node_id: ::proto::dom::NodeId,
        #[serde(rename = "insertBeforeNodeId", skip_serializing_if = "Option::is_none")]
        #[doc = "Drop node before this one \\(if absent, the moved node becomes the last child of <code>targetNodeId</code>\\)."]
        pub insert_before_node_id: Option<::proto::dom::NodeId>,
    }
    impl ::traits::SerializeCdpCommand for MoveToCommand {
        fn command_name(&self) -> &str {
            "DOM.moveTo"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for MoveToCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.moveTo" {
                Ok(
                    <MoveToCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Moves node into the new container, places it before the given anchor.\n\n# Command `DOM.moveTo`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::MoveToCommand`](struct.MoveToCommand.html)  \n*Response Struct:* [`cdp::proto::dom::MoveToResponse`](struct.MoveToResponse.html)"]
    pub struct MoveToResponse {
        #[serde(rename = "nodeId")]
        #[doc = "New id of the moved node."]
        pub node_id: ::proto::dom::NodeId,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for MoveToCommand {
        type Response = MoveToResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for MoveToResponse {
        type Command = MoveToCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Undoes the last performed action.\n\n# Command `DOM.undo`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::UndoCommand`](struct.UndoCommand.html)  \n*Response Struct:* [`cdp::proto::dom::UndoResponse`](struct.UndoResponse.html)"]
    pub struct UndoCommand;
    impl ::serde::Serialize for UndoCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for UndoCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| UndoCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for UndoCommand {
        fn command_name(&self) -> &str {
            "DOM.undo"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for UndoCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.undo" {
                Ok(
                    <UndoCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Undoes the last performed action.\n\n# Command `DOM.undo`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::UndoCommand`](struct.UndoCommand.html)  \n*Response Struct:* [`cdp::proto::dom::UndoResponse`](struct.UndoResponse.html)"]
    pub struct UndoResponse;
    impl ::serde::Serialize for UndoResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for UndoResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| UndoResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for UndoCommand {
        type Response = UndoResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for UndoResponse {
        type Command = UndoCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Re-does the last undone action.\n\n# Command `DOM.redo`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::RedoCommand`](struct.RedoCommand.html)  \n*Response Struct:* [`cdp::proto::dom::RedoResponse`](struct.RedoResponse.html)"]
    pub struct RedoCommand;
    impl ::serde::Serialize for RedoCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for RedoCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| RedoCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for RedoCommand {
        fn command_name(&self) -> &str {
            "DOM.redo"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for RedoCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.redo" {
                Ok(
                    <RedoCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Re-does the last undone action.\n\n# Command `DOM.redo`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::RedoCommand`](struct.RedoCommand.html)  \n*Response Struct:* [`cdp::proto::dom::RedoResponse`](struct.RedoResponse.html)"]
    pub struct RedoResponse;
    impl ::serde::Serialize for RedoResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for RedoResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| RedoResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for RedoCommand {
        type Response = RedoResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for RedoResponse {
        type Command = RedoCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Marks last undoable state.\n\n# Command `DOM.markUndoableState`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::MarkUndoableStateCommand`](struct.MarkUndoableStateCommand.html)  \n*Response Struct:* [`cdp::proto::dom::MarkUndoableStateResponse`](struct.MarkUndoableStateResponse.html)"]
    pub struct MarkUndoableStateCommand;
    impl ::serde::Serialize for MarkUndoableStateCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for MarkUndoableStateCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| MarkUndoableStateCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for MarkUndoableStateCommand {
        fn command_name(&self) -> &str {
            "DOM.markUndoableState"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for MarkUndoableStateCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.markUndoableState" {
                Ok ( < MarkUndoableStateCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Marks last undoable state.\n\n# Command `DOM.markUndoableState`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::MarkUndoableStateCommand`](struct.MarkUndoableStateCommand.html)  \n*Response Struct:* [`cdp::proto::dom::MarkUndoableStateResponse`](struct.MarkUndoableStateResponse.html)"]
    pub struct MarkUndoableStateResponse;
    impl ::serde::Serialize for MarkUndoableStateResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for MarkUndoableStateResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| MarkUndoableStateResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for MarkUndoableStateCommand {
        type Response = MarkUndoableStateResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for MarkUndoableStateResponse {
        type Command = MarkUndoableStateCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Focuses the given element.\n\n# Command `DOM.focus`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::FocusCommand`](struct.FocusCommand.html)  \n*Response Struct:* [`cdp::proto::dom::FocusResponse`](struct.FocusResponse.html)"]
    pub struct FocusCommand<'a> {
        #[serde(rename = "nodeId", skip_serializing_if = "Option::is_none")]
        #[doc = "Identifier of the node."]
        pub node_id: Option<::proto::dom::NodeId>,
        #[serde(rename = "backendNodeId", skip_serializing_if = "Option::is_none")]
        #[doc = "Identifier of the backend node."]
        pub backend_node_id: Option<::proto::dom::BackendNodeId>,
        #[serde(rename = "objectId", skip_serializing_if = "Option::is_none")]
        #[doc = "JavaScript object id of the node wrapper."]
        pub object_id: Option<::proto::runtime::RemoteObjectId<'a>>,
    }
    impl<'a> ::traits::SerializeCdpCommand for FocusCommand<'a> {
        fn command_name(&self) -> &str {
            "DOM.focus"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for FocusCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.focus" {
                Ok(
                    <FocusCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Focuses the given element.\n\n# Command `DOM.focus`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::FocusCommand`](struct.FocusCommand.html)  \n*Response Struct:* [`cdp::proto::dom::FocusResponse`](struct.FocusResponse.html)"]
    pub struct FocusResponse;
    impl ::serde::Serialize for FocusResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for FocusResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| FocusResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for FocusCommand<'a> {
        type Response = FocusResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for FocusResponse {
        type Command = FocusCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Sets files for the given file input element.\n\n# Command `DOM.setFileInputFiles`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::SetFileInputFilesCommand`](struct.SetFileInputFilesCommand.html)  \n*Response Struct:* [`cdp::proto::dom::SetFileInputFilesResponse`](struct.SetFileInputFilesResponse.html)"]
    pub struct SetFileInputFilesCommand<'a> {
        #[serde(rename = "files")]
        #[doc = "Array of file paths to set."]
        pub files: Vec<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "nodeId", skip_serializing_if = "Option::is_none")]
        #[doc = "Identifier of the node."]
        pub node_id: Option<::proto::dom::NodeId>,
        #[serde(rename = "backendNodeId", skip_serializing_if = "Option::is_none")]
        #[doc = "Identifier of the backend node."]
        pub backend_node_id: Option<::proto::dom::BackendNodeId>,
        #[serde(rename = "objectId", skip_serializing_if = "Option::is_none")]
        #[doc = "JavaScript object id of the node wrapper."]
        pub object_id: Option<::proto::runtime::RemoteObjectId<'a>>,
    }
    impl<'a> ::traits::SerializeCdpCommand for SetFileInputFilesCommand<'a> {
        fn command_name(&self) -> &str {
            "DOM.setFileInputFiles"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for SetFileInputFilesCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.setFileInputFiles" {
                Ok ( < SetFileInputFilesCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Sets files for the given file input element.\n\n# Command `DOM.setFileInputFiles`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::SetFileInputFilesCommand`](struct.SetFileInputFilesCommand.html)  \n*Response Struct:* [`cdp::proto::dom::SetFileInputFilesResponse`](struct.SetFileInputFilesResponse.html)"]
    pub struct SetFileInputFilesResponse;
    impl ::serde::Serialize for SetFileInputFilesResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetFileInputFilesResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetFileInputFilesResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetFileInputFilesCommand<'a> {
        type Response = SetFileInputFilesResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetFileInputFilesResponse {
        type Command = SetFileInputFilesCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns boxes for the currently selected nodes.\n\n# Command `DOM.getBoxModel`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::GetBoxModelCommand`](struct.GetBoxModelCommand.html)  \n*Response Struct:* [`cdp::proto::dom::GetBoxModelResponse`](struct.GetBoxModelResponse.html)"]
    pub struct GetBoxModelCommand<'a> {
        #[serde(rename = "nodeId", skip_serializing_if = "Option::is_none")]
        #[doc = "Identifier of the node."]
        pub node_id: Option<::proto::dom::NodeId>,
        #[serde(rename = "backendNodeId", skip_serializing_if = "Option::is_none")]
        #[doc = "Identifier of the backend node."]
        pub backend_node_id: Option<::proto::dom::BackendNodeId>,
        #[serde(rename = "objectId", skip_serializing_if = "Option::is_none")]
        #[doc = "JavaScript object id of the node wrapper."]
        pub object_id: Option<::proto::runtime::RemoteObjectId<'a>>,
    }
    impl<'a> ::traits::SerializeCdpCommand for GetBoxModelCommand<'a> {
        fn command_name(&self) -> &str {
            "DOM.getBoxModel"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for GetBoxModelCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.getBoxModel" {
                Ok(
                    <GetBoxModelCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns boxes for the currently selected nodes.\n\n# Command `DOM.getBoxModel`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::GetBoxModelCommand`](struct.GetBoxModelCommand.html)  \n*Response Struct:* [`cdp::proto::dom::GetBoxModelResponse`](struct.GetBoxModelResponse.html)"]
    pub struct GetBoxModelResponse {
        #[serde(rename = "model")]
        #[doc = "Box model for the node."]
        pub model: ::proto::dom::BoxModel,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for GetBoxModelCommand<'a> {
        type Response = GetBoxModelResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for GetBoxModelResponse {
        type Command = GetBoxModelCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns node id at given location.\n\n# Command `DOM.getNodeForLocation`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::GetNodeForLocationCommand`](struct.GetNodeForLocationCommand.html)  \n*Response Struct:* [`cdp::proto::dom::GetNodeForLocationResponse`](struct.GetNodeForLocationResponse.html)"]
    pub struct GetNodeForLocationCommand {
        #[serde(rename = "x")]
        #[doc = "X coordinate."]
        pub x: i32,
        #[serde(rename = "y")]
        #[doc = "Y coordinate."]
        pub y: i32,
        #[serde(rename = "includeUserAgentShadowDOM", skip_serializing_if = "Option::is_none")]
        #[doc = "False to skip to the nearest non-UA shadow root ancestor \\(default: false\\)."]
        pub include_user_agent_shadow_dom: Option<bool>,
    }
    impl ::traits::SerializeCdpCommand for GetNodeForLocationCommand {
        fn command_name(&self) -> &str {
            "DOM.getNodeForLocation"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for GetNodeForLocationCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.getNodeForLocation" {
                Ok ( < GetNodeForLocationCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns node id at given location.\n\n# Command `DOM.getNodeForLocation`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::GetNodeForLocationCommand`](struct.GetNodeForLocationCommand.html)  \n*Response Struct:* [`cdp::proto::dom::GetNodeForLocationResponse`](struct.GetNodeForLocationResponse.html)"]
    pub struct GetNodeForLocationResponse {
        #[serde(rename = "nodeId")]
        #[doc = "Id of the node at given coordinates."]
        pub node_id: ::proto::dom::NodeId,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for GetNodeForLocationCommand {
        type Response = GetNodeForLocationResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for GetNodeForLocationResponse {
        type Command = GetNodeForLocationCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns the id of the nearest ancestor that is a relayout boundary.\n\n# Command `DOM.getRelayoutBoundary`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::GetRelayoutBoundaryCommand`](struct.GetRelayoutBoundaryCommand.html)  \n*Response Struct:* [`cdp::proto::dom::GetRelayoutBoundaryResponse`](struct.GetRelayoutBoundaryResponse.html)"]
    pub struct GetRelayoutBoundaryCommand {
        #[serde(rename = "nodeId")]
        #[doc = "Id of the node."]
        pub node_id: ::proto::dom::NodeId,
    }
    impl ::traits::SerializeCdpCommand for GetRelayoutBoundaryCommand {
        fn command_name(&self) -> &str {
            "DOM.getRelayoutBoundary"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for GetRelayoutBoundaryCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.getRelayoutBoundary" {
                Ok ( < GetRelayoutBoundaryCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns the id of the nearest ancestor that is a relayout boundary.\n\n# Command `DOM.getRelayoutBoundary`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Command Struct:* [`cdp::proto::dom::GetRelayoutBoundaryCommand`](struct.GetRelayoutBoundaryCommand.html)  \n*Response Struct:* [`cdp::proto::dom::GetRelayoutBoundaryResponse`](struct.GetRelayoutBoundaryResponse.html)"]
    pub struct GetRelayoutBoundaryResponse {
        #[serde(rename = "nodeId")]
        #[doc = "Relayout boundary node id for the given node."]
        pub node_id: ::proto::dom::NodeId,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for GetRelayoutBoundaryCommand {
        type Response = GetRelayoutBoundaryResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for GetRelayoutBoundaryResponse {
        type Command = GetRelayoutBoundaryCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Fired when <code>Document</code> has been totally updated. Node ids are no longer valid.\n\n# Event `DOM.documentUpdated`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Event Struct:* [`cdp::proto::dom::DocumentUpdatedEvent`](struct.DocumentUpdatedEvent.html)"]
    pub struct DocumentUpdatedEvent;
    impl ::serde::Serialize for DocumentUpdatedEvent {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DocumentUpdatedEvent {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DocumentUpdatedEvent)
        }
    }
    impl ::traits::SerializeCdpEvent for DocumentUpdatedEvent {
        fn event_name(&self) -> &str {
            "DOM.documentUpdated"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpEvent<'de> for DocumentUpdatedEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.documentUpdated" {
                Ok(
                    <DocumentUpdatedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Fired when backend wants to provide client with the missing DOM structure. This happens upon most of the calls requesting node ids.\n\n# Event `DOM.setChildNodes`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Event Struct:* [`cdp::proto::dom::SetChildNodesEvent`](struct.SetChildNodesEvent.html)"]
    pub struct SetChildNodesEvent<'a> {
        #[serde(rename = "parentId")]
        #[doc = "Parent node id to populate with children."]
        pub parent_id: ::proto::dom::NodeId,
        #[serde(rename = "nodes")]
        #[doc = "Child nodes array."]
        pub nodes: Vec<::proto::dom::Node<'a>>,
    }
    impl<'a> ::traits::SerializeCdpEvent for SetChildNodesEvent<'a> {
        fn event_name(&self) -> &str {
            "DOM.setChildNodes"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for SetChildNodesEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.setChildNodes" {
                Ok(
                    <SetChildNodesEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Fired when <code>Element</code>'s attribute is modified.\n\n# Event `DOM.attributeModified`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Event Struct:* [`cdp::proto::dom::AttributeModifiedEvent`](struct.AttributeModifiedEvent.html)"]
    pub struct AttributeModifiedEvent<'a> {
        #[serde(rename = "nodeId")]
        #[doc = "Id of the node that has changed."]
        pub node_id: ::proto::dom::NodeId,
        #[serde(rename = "name")]
        #[doc = "Attribute name."]
        pub name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "value")]
        #[doc = "Attribute value."]
        pub value: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpEvent for AttributeModifiedEvent<'a> {
        fn event_name(&self) -> &str {
            "DOM.attributeModified"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for AttributeModifiedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.attributeModified" {
                Ok(
                    <AttributeModifiedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Fired when <code>Element</code>'s attribute is removed.\n\n# Event `DOM.attributeRemoved`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Event Struct:* [`cdp::proto::dom::AttributeRemovedEvent`](struct.AttributeRemovedEvent.html)"]
    pub struct AttributeRemovedEvent<'a> {
        #[serde(rename = "nodeId")]
        #[doc = "Id of the node that has changed."]
        pub node_id: ::proto::dom::NodeId,
        #[serde(rename = "name")]
        #[doc = "A ttribute name."]
        pub name: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpEvent for AttributeRemovedEvent<'a> {
        fn event_name(&self) -> &str {
            "DOM.attributeRemoved"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for AttributeRemovedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.attributeRemoved" {
                Ok(
                    <AttributeRemovedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Fired when <code>Element</code>'s inline style is modified via a CSS property modification.\n\n# Event `DOM.inlineStyleInvalidated`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Event Struct:* [`cdp::proto::dom::InlineStyleInvalidatedEvent`](struct.InlineStyleInvalidatedEvent.html)"]
    pub struct InlineStyleInvalidatedEvent {
        #[serde(rename = "nodeIds")]
        #[doc = "Ids of the nodes for which the inline styles have been invalidated."]
        pub node_ids: Vec<::proto::dom::NodeId>,
    }
    impl ::traits::SerializeCdpEvent for InlineStyleInvalidatedEvent {
        fn event_name(&self) -> &str {
            "DOM.inlineStyleInvalidated"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpEvent<'de> for InlineStyleInvalidatedEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.inlineStyleInvalidated" {
                Ok ( < InlineStyleInvalidatedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Mirrors <code>DOMCharacterDataModified</code> event.\n\n# Event `DOM.characterDataModified`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Event Struct:* [`cdp::proto::dom::CharacterDataModifiedEvent`](struct.CharacterDataModifiedEvent.html)"]
    pub struct CharacterDataModifiedEvent<'a> {
        #[serde(rename = "nodeId")]
        #[doc = "Id of the node that has changed."]
        pub node_id: ::proto::dom::NodeId,
        #[serde(rename = "characterData")]
        #[doc = "New text value."]
        pub character_data: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpEvent for CharacterDataModifiedEvent<'a> {
        fn event_name(&self) -> &str {
            "DOM.characterDataModified"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for CharacterDataModifiedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.characterDataModified" {
                Ok ( < CharacterDataModifiedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Fired when <code>Container</code>'s child node count has changed.\n\n# Event `DOM.childNodeCountUpdated`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Event Struct:* [`cdp::proto::dom::ChildNodeCountUpdatedEvent`](struct.ChildNodeCountUpdatedEvent.html)"]
    pub struct ChildNodeCountUpdatedEvent {
        #[serde(rename = "nodeId")]
        #[doc = "Id of the node that has changed."]
        pub node_id: ::proto::dom::NodeId,
        #[serde(rename = "childNodeCount")]
        #[doc = "New node count."]
        pub child_node_count: i32,
    }
    impl ::traits::SerializeCdpEvent for ChildNodeCountUpdatedEvent {
        fn event_name(&self) -> &str {
            "DOM.childNodeCountUpdated"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpEvent<'de> for ChildNodeCountUpdatedEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.childNodeCountUpdated" {
                Ok ( < ChildNodeCountUpdatedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Mirrors <code>DOMNodeInserted</code> event.\n\n# Event `DOM.childNodeInserted`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Event Struct:* [`cdp::proto::dom::ChildNodeInsertedEvent`](struct.ChildNodeInsertedEvent.html)"]
    pub struct ChildNodeInsertedEvent<'a> {
        #[serde(rename = "parentNodeId")]
        #[doc = "Id of the node that has changed."]
        pub parent_node_id: ::proto::dom::NodeId,
        #[serde(rename = "previousNodeId")]
        #[doc = "If of the previous siblint."]
        pub previous_node_id: ::proto::dom::NodeId,
        #[serde(rename = "node")]
        #[doc = "Inserted node data."]
        pub node: ::proto::dom::Node<'a>,
    }
    impl<'a> ::traits::SerializeCdpEvent for ChildNodeInsertedEvent<'a> {
        fn event_name(&self) -> &str {
            "DOM.childNodeInserted"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for ChildNodeInsertedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.childNodeInserted" {
                Ok(
                    <ChildNodeInsertedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Mirrors <code>DOMNodeRemoved</code> event.\n\n# Event `DOM.childNodeRemoved`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Event Struct:* [`cdp::proto::dom::ChildNodeRemovedEvent`](struct.ChildNodeRemovedEvent.html)"]
    pub struct ChildNodeRemovedEvent {
        #[serde(rename = "parentNodeId")]
        #[doc = "Parent id."]
        pub parent_node_id: ::proto::dom::NodeId,
        #[serde(rename = "nodeId")]
        #[doc = "Id of the node that has been removed."]
        pub node_id: ::proto::dom::NodeId,
    }
    impl ::traits::SerializeCdpEvent for ChildNodeRemovedEvent {
        fn event_name(&self) -> &str {
            "DOM.childNodeRemoved"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpEvent<'de> for ChildNodeRemovedEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.childNodeRemoved" {
                Ok(
                    <ChildNodeRemovedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Called when shadow root is pushed into the element.\n\n# Event `DOM.shadowRootPushed`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Event Struct:* [`cdp::proto::dom::ShadowRootPushedEvent`](struct.ShadowRootPushedEvent.html)"]
    pub struct ShadowRootPushedEvent<'a> {
        #[serde(rename = "hostId")]
        #[doc = "Host element id."]
        pub host_id: ::proto::dom::NodeId,
        #[serde(rename = "root")]
        #[doc = "Shadow root."]
        pub root: ::proto::dom::Node<'a>,
    }
    impl<'a> ::traits::SerializeCdpEvent for ShadowRootPushedEvent<'a> {
        fn event_name(&self) -> &str {
            "DOM.shadowRootPushed"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for ShadowRootPushedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.shadowRootPushed" {
                Ok(
                    <ShadowRootPushedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Called when shadow root is popped from the element.\n\n# Event `DOM.shadowRootPopped`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Event Struct:* [`cdp::proto::dom::ShadowRootPoppedEvent`](struct.ShadowRootPoppedEvent.html)"]
    pub struct ShadowRootPoppedEvent {
        #[serde(rename = "hostId")]
        #[doc = "Host element id."]
        pub host_id: ::proto::dom::NodeId,
        #[serde(rename = "rootId")]
        #[doc = "Shadow root id."]
        pub root_id: ::proto::dom::NodeId,
    }
    impl ::traits::SerializeCdpEvent for ShadowRootPoppedEvent {
        fn event_name(&self) -> &str {
            "DOM.shadowRootPopped"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpEvent<'de> for ShadowRootPoppedEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.shadowRootPopped" {
                Ok(
                    <ShadowRootPoppedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Called when a pseudo element is added to an element.\n\n# Event `DOM.pseudoElementAdded`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Event Struct:* [`cdp::proto::dom::PseudoElementAddedEvent`](struct.PseudoElementAddedEvent.html)"]
    pub struct PseudoElementAddedEvent<'a> {
        #[serde(rename = "parentId")]
        #[doc = "Pseudo element's parent element id."]
        pub parent_id: ::proto::dom::NodeId,
        #[serde(rename = "pseudoElement")]
        #[doc = "The added pseudo element."]
        pub pseudo_element: ::proto::dom::Node<'a>,
    }
    impl<'a> ::traits::SerializeCdpEvent for PseudoElementAddedEvent<'a> {
        fn event_name(&self) -> &str {
            "DOM.pseudoElementAdded"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for PseudoElementAddedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.pseudoElementAdded" {
                Ok ( < PseudoElementAddedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Called when a pseudo element is removed from an element.\n\n# Event `DOM.pseudoElementRemoved`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Event Struct:* [`cdp::proto::dom::PseudoElementRemovedEvent`](struct.PseudoElementRemovedEvent.html)"]
    pub struct PseudoElementRemovedEvent {
        #[serde(rename = "parentId")]
        #[doc = "Pseudo element's parent element id."]
        pub parent_id: ::proto::dom::NodeId,
        #[serde(rename = "pseudoElementId")]
        #[doc = "The removed pseudo element id."]
        pub pseudo_element_id: ::proto::dom::NodeId,
    }
    impl ::traits::SerializeCdpEvent for PseudoElementRemovedEvent {
        fn event_name(&self) -> &str {
            "DOM.pseudoElementRemoved"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpEvent<'de> for PseudoElementRemovedEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.pseudoElementRemoved" {
                Ok ( < PseudoElementRemovedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Called when distrubution is changed.\n\n# Event `DOM.distributedNodesUpdated`\n\n*Domain Module:* [`cdp::proto::dom`](index.html)  \n*Event Struct:* [`cdp::proto::dom::DistributedNodesUpdatedEvent`](struct.DistributedNodesUpdatedEvent.html)"]
    pub struct DistributedNodesUpdatedEvent<'a> {
        #[serde(rename = "insertionPointId")]
        #[doc = "Insertion point where distrubuted nodes were updated."]
        pub insertion_point_id: ::proto::dom::NodeId,
        #[serde(rename = "distributedNodes")]
        #[doc = "Distributed nodes for given insertion point."]
        pub distributed_nodes: Vec<::proto::dom::BackendNode<'a>>,
    }
    impl<'a> ::traits::SerializeCdpEvent for DistributedNodesUpdatedEvent<'a> {
        fn event_name(&self) -> &str {
            "DOM.distributedNodesUpdated"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for DistributedNodesUpdatedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.distributedNodesUpdated" {
                Ok ( < DistributedNodesUpdatedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[doc = "Unique DOM node identifier."]
    pub type NodeId = i32;
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Unique DOM node identifier used to reference a node that may not have been pushed to the front-end."]
    pub type BackendNodeId = i32;
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Backend node with a friendly name."]
    pub struct BackendNode<'a> {
        #[serde(rename = "nodeType")]
        #[doc = "<code>Node</code>'s nodeType."]
        pub node_type: i32,
        #[serde(rename = "nodeName")]
        #[doc = "<code>Node</code>'s nodeName."]
        pub node_name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "backendNodeId")]
        pub backend_node_id: ::proto::dom::BackendNodeId,
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "Pseudo element type."]
    pub enum PseudoType {
        #[serde(rename = "first-line")]
        #[doc = "Represented as `\"first-line\"`."]
        FirstLine,
        #[serde(rename = "first-letter")]
        #[doc = "Represented as `\"first-letter\"`."]
        FirstLetter,
        #[serde(rename = "before")]
        #[doc = "Represented as `\"before\"`."]
        Before,
        #[serde(rename = "after")]
        #[doc = "Represented as `\"after\"`."]
        After,
        #[serde(rename = "backdrop")]
        #[doc = "Represented as `\"backdrop\"`."]
        Backdrop,
        #[serde(rename = "selection")]
        #[doc = "Represented as `\"selection\"`."]
        Selection,
        #[serde(rename = "first-line-inherited")]
        #[doc = "Represented as `\"first-line-inherited\"`."]
        FirstLineInherited,
        #[serde(rename = "scrollbar")]
        #[doc = "Represented as `\"scrollbar\"`."]
        Scrollbar,
        #[serde(rename = "scrollbar-thumb")]
        #[doc = "Represented as `\"scrollbar-thumb\"`."]
        ScrollbarThumb,
        #[serde(rename = "scrollbar-button")]
        #[doc = "Represented as `\"scrollbar-button\"`."]
        ScrollbarButton,
        #[serde(rename = "scrollbar-track")]
        #[doc = "Represented as `\"scrollbar-track\"`."]
        ScrollbarTrack,
        #[serde(rename = "scrollbar-track-piece")]
        #[doc = "Represented as `\"scrollbar-track-piece\"`."]
        ScrollbarTrackPiece,
        #[serde(rename = "scrollbar-corner")]
        #[doc = "Represented as `\"scrollbar-corner\"`."]
        ScrollbarCorner,
        #[serde(rename = "resizer")]
        #[doc = "Represented as `\"resizer\"`."]
        Resizer,
        #[serde(rename = "input-list-button")]
        #[doc = "Represented as `\"input-list-button\"`."]
        InputListButton,
    }
    impl PseudoType {
        pub const ENUM_VALUES: &'static [PseudoType] = &[
            PseudoType::FirstLine,
            PseudoType::FirstLetter,
            PseudoType::Before,
            PseudoType::After,
            PseudoType::Backdrop,
            PseudoType::Selection,
            PseudoType::FirstLineInherited,
            PseudoType::Scrollbar,
            PseudoType::ScrollbarThumb,
            PseudoType::ScrollbarButton,
            PseudoType::ScrollbarTrack,
            PseudoType::ScrollbarTrackPiece,
            PseudoType::ScrollbarCorner,
            PseudoType::Resizer,
            PseudoType::InputListButton,
        ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "first-line",
            "first-letter",
            "before",
            "after",
            "backdrop",
            "selection",
            "first-line-inherited",
            "scrollbar",
            "scrollbar-thumb",
            "scrollbar-button",
            "scrollbar-track",
            "scrollbar-track-piece",
            "scrollbar-corner",
            "resizer",
            "input-list-button",
        ];
    }
    impl ::std::str::FromStr for PseudoType {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "first-line" => Ok(PseudoType::FirstLine),
                "first-letter" => Ok(PseudoType::FirstLetter),
                "before" => Ok(PseudoType::Before),
                "after" => Ok(PseudoType::After),
                "backdrop" => Ok(PseudoType::Backdrop),
                "selection" => Ok(PseudoType::Selection),
                "first-line-inherited" => Ok(PseudoType::FirstLineInherited),
                "scrollbar" => Ok(PseudoType::Scrollbar),
                "scrollbar-thumb" => Ok(PseudoType::ScrollbarThumb),
                "scrollbar-button" => Ok(PseudoType::ScrollbarButton),
                "scrollbar-track" => Ok(PseudoType::ScrollbarTrack),
                "scrollbar-track-piece" => Ok(PseudoType::ScrollbarTrackPiece),
                "scrollbar-corner" => Ok(PseudoType::ScrollbarCorner),
                "resizer" => Ok(PseudoType::Resizer),
                "input-list-button" => Ok(PseudoType::InputListButton),
                _ => Err(::proto::ParseEnumError {
                    expected: PseudoType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for PseudoType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    PseudoType::FirstLine => "first-line",
                    PseudoType::FirstLetter => "first-letter",
                    PseudoType::Before => "before",
                    PseudoType::After => "after",
                    PseudoType::Backdrop => "backdrop",
                    PseudoType::Selection => "selection",
                    PseudoType::FirstLineInherited => "first-line-inherited",
                    PseudoType::Scrollbar => "scrollbar",
                    PseudoType::ScrollbarThumb => "scrollbar-thumb",
                    PseudoType::ScrollbarButton => "scrollbar-button",
                    PseudoType::ScrollbarTrack => "scrollbar-track",
                    PseudoType::ScrollbarTrackPiece => "scrollbar-track-piece",
                    PseudoType::ScrollbarCorner => "scrollbar-corner",
                    PseudoType::Resizer => "resizer",
                    PseudoType::InputListButton => "input-list-button",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "Shadow root type."]
    pub enum ShadowRootType {
        #[serde(rename = "user-agent")]
        #[doc = "Represented as `\"user-agent\"`."]
        UserAgent,
        #[serde(rename = "open")]
        #[doc = "Represented as `\"open\"`."]
        Open,
        #[serde(rename = "closed")]
        #[doc = "Represented as `\"closed\"`."]
        Closed,
    }
    impl ShadowRootType {
        pub const ENUM_VALUES: &'static [ShadowRootType] = &[
            ShadowRootType::UserAgent,
            ShadowRootType::Open,
            ShadowRootType::Closed,
        ];
        pub const STR_VALUES: &'static [&'static str] = &["user-agent", "open", "closed"];
    }
    impl ::std::str::FromStr for ShadowRootType {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "user-agent" => Ok(ShadowRootType::UserAgent),
                "open" => Ok(ShadowRootType::Open),
                "closed" => Ok(ShadowRootType::Closed),
                _ => Err(::proto::ParseEnumError {
                    expected: ShadowRootType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for ShadowRootType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    ShadowRootType::UserAgent => "user-agent",
                    ShadowRootType::Open => "open",
                    ShadowRootType::Closed => "closed",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "DOM interaction is implemented in terms of mirror objects that represent the actual DOM nodes. DOMNode is a base node mirror type."]
    pub struct Node<'a> {
        #[serde(rename = "nodeId")]
        #[doc = "Node identifier that is passed into the rest of the DOM messages as the <code>nodeId</code>. Backend will only push node with given <code>id</code> once. It is aware of all requested nodes and will only fire DOM events for nodes known to the client."]
        pub node_id: ::proto::dom::NodeId,
        #[serde(rename = "parentId", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> The id of the parent node if any."]
        pub parent_id: Option<::proto::dom::NodeId>,
        #[serde(rename = "backendNodeId")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> The BackendNodeId for this node."]
        pub backend_node_id: ::proto::dom::BackendNodeId,
        #[serde(rename = "nodeType")]
        #[doc = "<code>Node</code>'s nodeType."]
        pub node_type: i32,
        #[serde(rename = "nodeName")]
        #[doc = "<code>Node</code>'s nodeName."]
        pub node_name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "localName")]
        #[doc = "<code>Node</code>'s localName."]
        pub local_name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "nodeValue")]
        #[doc = "<code>Node</code>'s nodeValue."]
        pub node_value: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "childNodeCount", skip_serializing_if = "Option::is_none")]
        #[doc = "Child count for <code>Container</code> nodes."]
        pub child_node_count: Option<i32>,
        #[serde(rename = "children", skip_serializing_if = "Option::is_none")]
        #[doc = "Child nodes of this node when requested with children."]
        pub children: Option<Vec<Box<::proto::dom::Node<'a>>>>,
        #[serde(rename = "attributes", skip_serializing_if = "Option::is_none")]
        #[doc = "Attributes of the <code>Element</code> node in the form of flat array <code>\\[name1, value1, name2, value2\\]</code>."]
        pub attributes: Option<Vec<::std::borrow::Cow<'a, str>>>,
        #[serde(rename = "documentURL", skip_serializing_if = "Option::is_none")]
        #[doc = "Document URL that <code>Document</code> or <code>FrameOwner</code> node points to."]
        pub document_url: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "baseURL", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Base URL that <code>Document</code> or <code>FrameOwner</code> node uses for URL completion."]
        pub base_url: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "publicId", skip_serializing_if = "Option::is_none")]
        #[doc = "<code>DocumentType</code>'s publicId."]
        pub public_id: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "systemId", skip_serializing_if = "Option::is_none")]
        #[doc = "<code>DocumentType</code>'s systemId."]
        pub system_id: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "internalSubset", skip_serializing_if = "Option::is_none")]
        #[doc = "<code>DocumentType</code>'s internalSubset."]
        pub internal_subset: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "xmlVersion", skip_serializing_if = "Option::is_none")]
        #[doc = "<code>Document</code>'s XML version in case of XML documents."]
        pub xml_version: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "name", skip_serializing_if = "Option::is_none")]
        #[doc = "<code>Attr</code>'s name."]
        pub name: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "value", skip_serializing_if = "Option::is_none")]
        #[doc = "<code>Attr</code>'s value."]
        pub value: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "pseudoType", skip_serializing_if = "Option::is_none")]
        #[doc = "Pseudo element type for this node."]
        pub pseudo_type: Option<::proto::dom::PseudoType>,
        #[serde(rename = "shadowRootType", skip_serializing_if = "Option::is_none")]
        #[doc = "Shadow root type."]
        pub shadow_root_type: Option<::proto::dom::ShadowRootType>,
        #[serde(rename = "frameId", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Frame ID for frame owner elements."]
        pub frame_id: Option<::proto::page::FrameId<'a>>,
        #[serde(rename = "contentDocument", skip_serializing_if = "Option::is_none")]
        #[doc = "Content document for frame owner elements."]
        pub content_document: Option<Box<::proto::dom::Node<'a>>>,
        #[serde(rename = "shadowRoots", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Shadow root list for given element host."]
        pub shadow_roots: Option<Vec<Box<::proto::dom::Node<'a>>>>,
        #[serde(rename = "templateContent", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Content document fragment for template elements."]
        pub template_content: Option<Box<::proto::dom::Node<'a>>>,
        #[serde(rename = "pseudoElements", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Pseudo elements associated with this node."]
        pub pseudo_elements: Option<Vec<Box<::proto::dom::Node<'a>>>>,
        #[serde(rename = "importedDocument", skip_serializing_if = "Option::is_none")]
        #[doc = "Import document for the HTMLImport links."]
        pub imported_document: Option<Box<::proto::dom::Node<'a>>>,
        #[serde(rename = "distributedNodes", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Distributed nodes for given insertion point."]
        pub distributed_nodes: Option<Vec<::proto::dom::BackendNode<'a>>>,
        #[serde(rename = "isSVG", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Whether the node is SVG."]
        pub is_svg: Option<bool>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "A structure holding an RGBA color."]
    pub struct Rgba {
        #[serde(rename = "r")]
        #[doc = "The red component, in the \\[0-255\\] range."]
        pub r: i32,
        #[serde(rename = "g")]
        #[doc = "The green component, in the \\[0-255\\] range."]
        pub g: i32,
        #[serde(rename = "b")]
        #[doc = "The blue component, in the \\[0-255\\] range."]
        pub b: i32,
        #[serde(rename = "a", skip_serializing_if = "Option::is_none")]
        #[doc = "The alpha component, in the \\[0-1\\] range \\(default: 1\\)."]
        pub a: Option<f64>,
    }
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> An array of quad vertices, x immediately followed by y for each point, points clock-wise."]
    pub type Quad = [f64; 8usize];
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Box model."]
    pub struct BoxModel {
        #[serde(rename = "content")]
        #[doc = "Content box"]
        pub content: ::proto::dom::Quad,
        #[serde(rename = "padding")]
        #[doc = "Padding box"]
        pub padding: ::proto::dom::Quad,
        #[serde(rename = "border")]
        #[doc = "Border box"]
        pub border: ::proto::dom::Quad,
        #[serde(rename = "margin")]
        #[doc = "Margin box"]
        pub margin: ::proto::dom::Quad,
        #[serde(rename = "width")]
        #[doc = "Node width"]
        pub width: i32,
        #[serde(rename = "height")]
        #[doc = "Node height"]
        pub height: i32,
        #[serde(rename = "shapeOutside", skip_serializing_if = "Option::is_none")]
        #[doc = "Shape outside coordinates"]
        pub shape_outside: Option<::proto::dom::ShapeOutsideInfo>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> CSS Shape Outside details."]
    pub struct ShapeOutsideInfo {
        #[serde(rename = "bounds")]
        #[doc = "Shape bounds"]
        pub bounds: ::proto::dom::Quad,
        #[serde(rename = "shape")]
        #[doc = "Shape coordinate details"]
        pub shape: Vec<::serde_json::Value>,
        #[serde(rename = "marginShape")]
        #[doc = "Margin shape bounds"]
        pub margin_shape: Vec<::serde_json::Value>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Rectangle."]
    pub struct Rect {
        #[serde(rename = "x")]
        #[doc = "X coordinate"]
        pub x: f64,
        #[serde(rename = "y")]
        #[doc = "Y coordinate"]
        pub y: f64,
        #[serde(rename = "width")]
        #[doc = "Rectangle width"]
        pub width: f64,
        #[serde(rename = "height")]
        #[doc = "Rectangle height"]
        pub height: f64,
    }
}
#[doc = "<span class=\"stab unstable\">[Experimental]</span> This domain exposes CSS read/write operations. All CSS objects \\(stylesheets, rules, and styles\\) have an associated <code>id</code> used in subsequent operations on the related object. Each object type has a specific <code>id</code> structure, and those are not interchangeable between objects of different kinds. CSS objects can be loaded using the <code>get\\*ForNode\\(\\)</code> calls \\(which accept a DOM node id\\). A client can also keep track of stylesheets via the <code>styleSheetAdded</code>/<code>styleSheetRemoved</code> events and subsequently load the required stylesheet contents using the <code>getStyleSheet\\[Text\\]\\(\\)</code> methods.\n\n# CSS\n\n## Commands\n\n- [`CSS.enable`](struct.EnableCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Enables the CSS agent for the given page. Clients should not assume that the CSS agent has been enabled until the result of this command is received.\n- [`CSS.disable`](struct.DisableCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Disables the CSS agent for the given page.\n- [`CSS.getMatchedStylesForNode`](struct.GetMatchedStylesForNodeCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns requested styles for a DOM node identified by <code>nodeId</code>.\n- [`CSS.getInlineStylesForNode`](struct.GetInlineStylesForNodeCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns the styles defined inline \\(explicitly in the \"style\" attribute and implicitly, using DOM attributes\\) for a DOM node identified by <code>nodeId</code>.\n- [`CSS.getComputedStyleForNode`](struct.GetComputedStyleForNodeCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns the computed style for a DOM node identified by <code>nodeId</code>.\n- [`CSS.getPlatformFontsForNode`](struct.GetPlatformFontsForNodeCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Requests information about platform fonts which we used to render child TextNodes in the given node.\n- [`CSS.getStyleSheetText`](struct.GetStyleSheetTextCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns the current textual content and the URL for a stylesheet.\n- [`CSS.collectClassNames`](struct.CollectClassNamesCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns all class names from specified stylesheet.\n- [`CSS.setStyleSheetText`](struct.SetStyleSheetTextCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Sets the new stylesheet text.\n- [`CSS.setRuleSelector`](struct.SetRuleSelectorCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Modifies the rule selector.\n- [`CSS.setKeyframeKey`](struct.SetKeyframeKeyCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Modifies the keyframe rule key text.\n- [`CSS.setStyleTexts`](struct.SetStyleTextsCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Applies specified style edits one after another in the given order.\n- [`CSS.setMediaText`](struct.SetMediaTextCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Modifies the rule selector.\n- [`CSS.createStyleSheet`](struct.CreateStyleSheetCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Creates a new special \"via-inspector\" stylesheet in the frame with given <code>frameId</code>.\n- [`CSS.addRule`](struct.AddRuleCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Inserts a new rule with the given <code>ruleText</code> in a stylesheet with given <code>styleSheetId</code>, at the position specified by <code>location</code>.\n- [`CSS.forcePseudoState`](struct.ForcePseudoStateCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Ensures that the given node will have specified pseudo-classes whenever its style is computed by the browser.\n- [`CSS.getMediaQueries`](struct.GetMediaQueriesCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns all media queries parsed by the rendering engine.\n- [`CSS.setEffectivePropertyValueForNode`](struct.SetEffectivePropertyValueForNodeCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Find a rule with the given active property for the given node and set the new value for this property\n- [`CSS.getBackgroundColors`](struct.GetBackgroundColorsCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`CSS.startRuleUsageTracking`](struct.StartRuleUsageTrackingCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Enables the selector recording.\n- [`CSS.takeCoverageDelta`](struct.TakeCoverageDeltaCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Obtain list of rules that became used since last call to this method \\(or since start of coverage instrumentation\\)\n- [`CSS.stopRuleUsageTracking`](struct.StopRuleUsageTrackingCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  The list of rules with an indication of whether these were used\n\n## Events\n\n- [`CSS.mediaQueryResultChanged`](struct.MediaQueryResultChangedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Fires whenever a MediaQuery result changes \\(for example, after a browser window has been resized.\\) The current implementation considers only viewport-dependent media features.\n- [`CSS.fontsUpdated`](struct.FontsUpdatedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Fires whenever a web font gets loaded.\n- [`CSS.styleSheetChanged`](struct.StyleSheetChangedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Fired whenever a stylesheet is changed as a result of the client operation.\n- [`CSS.styleSheetAdded`](struct.StyleSheetAddedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Fired whenever an active document stylesheet is added.\n- [`CSS.styleSheetRemoved`](struct.StyleSheetRemovedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Fired whenever an active document stylesheet is removed.\n\n##Types\n\n- [`StyleSheetId`](type.StyleSheetId.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`StyleSheetOrigin`](enum.StyleSheetOrigin.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Stylesheet type: \"injected\" for stylesheets injected via extension, \"user-agent\" for user-agent stylesheets, \"inspector\" for stylesheets created by the inspector \\(i.e. those holding the \"via inspector\" rules\\), \"regular\" for regular stylesheets.\n- [`PseudoElementMatches`](struct.PseudoElementMatches.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  CSS rule collection for a single pseudo style.\n- [`InheritedStyleEntry`](struct.InheritedStyleEntry.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Inherited CSS rule collection from ancestor node.\n- [`RuleMatch`](struct.RuleMatch.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Match data for a CSS rule.\n- [`Value`](struct.Value.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Data for a simple selector \\(these are delimited by commas in a selector list\\).\n- [`SelectorList`](struct.SelectorList.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Selector list data.\n- [`CSSStyleSheetHeader`](struct.CssStyleSheetHeader.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  CSS stylesheet metainformation.\n- [`CSSRule`](struct.CssRule.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  CSS rule representation.\n- [`RuleUsage`](struct.RuleUsage.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  CSS coverage information.\n- [`SourceRange`](struct.SourceRange.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Text range within a resource. All numbers are zero-based.\n- [`ShorthandEntry`](struct.ShorthandEntry.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`CSSComputedStyleProperty`](struct.CssComputedStyleProperty.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`CSSStyle`](struct.CssStyle.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  CSS style representation.\n- [`CSSProperty`](struct.CssProperty.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  CSS property declaration data.\n- [`CSSMedia`](struct.CssMedia.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  CSS media rule descriptor.\n- [`MediaQuery`](struct.MediaQuery.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Media query descriptor.\n- [`MediaQueryExpression`](struct.MediaQueryExpression.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Media query expression descriptor.\n- [`PlatformFontUsage`](struct.PlatformFontUsage.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Information about amount of glyphs that were rendered with given font.\n- [`CSSKeyframesRule`](struct.CssKeyframesRule.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  CSS keyframes rule representation.\n- [`CSSKeyframeRule`](struct.CssKeyframeRule.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  CSS keyframe rule representation.\n- [`StyleDeclarationEdit`](struct.StyleDeclarationEdit.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  A descriptor of operation to mutate style declaration text.\n- [`InlineTextBox`](struct.InlineTextBox.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Details of post layout rendered text positions. The exact layout should not be regarded as stable and may change between versions.\n"]
pub mod css {
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables the CSS agent for the given page. Clients should not assume that the CSS agent has been enabled until the result of this command is received.\n\n# Command `CSS.enable`\n\n*Domain Module:* [`cdp::proto::css`](index.html)  \n*Command Struct:* [`cdp::proto::css::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::proto::css::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableCommand;
    impl ::serde::Serialize for EnableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for EnableCommand {
        fn command_name(&self) -> &str {
            "CSS.enable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for EnableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CSS.enable" {
                Ok(
                    <EnableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables the CSS agent for the given page. Clients should not assume that the CSS agent has been enabled until the result of this command is received.\n\n# Command `CSS.enable`\n\n*Domain Module:* [`cdp::proto::css`](index.html)  \n*Command Struct:* [`cdp::proto::css::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::proto::css::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableResponse;
    impl ::serde::Serialize for EnableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for EnableCommand {
        type Response = EnableResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for EnableResponse {
        type Command = EnableCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Disables the CSS agent for the given page.\n\n# Command `CSS.disable`\n\n*Domain Module:* [`cdp::proto::css`](index.html)  \n*Command Struct:* [`cdp::proto::css::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::proto::css::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableCommand;
    impl ::serde::Serialize for DisableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for DisableCommand {
        fn command_name(&self) -> &str {
            "CSS.disable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for DisableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CSS.disable" {
                Ok(
                    <DisableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Disables the CSS agent for the given page.\n\n# Command `CSS.disable`\n\n*Domain Module:* [`cdp::proto::css`](index.html)  \n*Command Struct:* [`cdp::proto::css::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::proto::css::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableResponse;
    impl ::serde::Serialize for DisableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for DisableCommand {
        type Response = DisableResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for DisableResponse {
        type Command = DisableCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns requested styles for a DOM node identified by <code>nodeId</code>.\n\n# Command `CSS.getMatchedStylesForNode`\n\n*Domain Module:* [`cdp::proto::css`](index.html)  \n*Command Struct:* [`cdp::proto::css::GetMatchedStylesForNodeCommand`](struct.GetMatchedStylesForNodeCommand.html)  \n*Response Struct:* [`cdp::proto::css::GetMatchedStylesForNodeResponse`](struct.GetMatchedStylesForNodeResponse.html)"]
    pub struct GetMatchedStylesForNodeCommand {
        #[serde(rename = "nodeId")]
        pub node_id: ::proto::dom::NodeId,
    }
    impl ::traits::SerializeCdpCommand for GetMatchedStylesForNodeCommand {
        fn command_name(&self) -> &str {
            "CSS.getMatchedStylesForNode"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for GetMatchedStylesForNodeCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CSS.getMatchedStylesForNode" {
                Ok ( < GetMatchedStylesForNodeCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns requested styles for a DOM node identified by <code>nodeId</code>.\n\n# Command `CSS.getMatchedStylesForNode`\n\n*Domain Module:* [`cdp::proto::css`](index.html)  \n*Command Struct:* [`cdp::proto::css::GetMatchedStylesForNodeCommand`](struct.GetMatchedStylesForNodeCommand.html)  \n*Response Struct:* [`cdp::proto::css::GetMatchedStylesForNodeResponse`](struct.GetMatchedStylesForNodeResponse.html)"]
    pub struct GetMatchedStylesForNodeResponse<'a> {
        #[serde(rename = "inlineStyle", skip_serializing_if = "Option::is_none")]
        #[doc = "Inline style for the specified DOM node."]
        pub inline_style: Option<::proto::css::CssStyle<'a>>,
        #[serde(rename = "attributesStyle", skip_serializing_if = "Option::is_none")]
        #[doc = "Attribute-defined element style \\(e.g. resulting from \"width=20 height=100%\"\\)."]
        pub attributes_style: Option<::proto::css::CssStyle<'a>>,
        #[serde(rename = "matchedCSSRules", skip_serializing_if = "Option::is_none")]
        #[doc = "CSS rules matching this node, from all applicable stylesheets."]
        pub matched_css_rules: Option<Vec<::proto::css::RuleMatch<'a>>>,
        #[serde(rename = "pseudoElements", skip_serializing_if = "Option::is_none")]
        #[doc = "Pseudo style matches for this node."]
        pub pseudo_elements: Option<Vec<::proto::css::PseudoElementMatches<'a>>>,
        #[serde(rename = "inherited", skip_serializing_if = "Option::is_none")]
        #[doc = "A chain of inherited styles \\(from the immediate node parent up to the DOM tree root\\)."]
        pub inherited: Option<Vec<::proto::css::InheritedStyleEntry<'a>>>,
        #[serde(rename = "cssKeyframesRules", skip_serializing_if = "Option::is_none")]
        #[doc = "A list of CSS keyframed animations matching this node."]
        pub css_keyframes_rules: Option<Vec<::proto::css::CssKeyframesRule<'a>>>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for GetMatchedStylesForNodeCommand {
        type Response = GetMatchedStylesForNodeResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for GetMatchedStylesForNodeResponse<'a> {
        type Command = GetMatchedStylesForNodeCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns the styles defined inline \\(explicitly in the \"style\" attribute and implicitly, using DOM attributes\\) for a DOM node identified by <code>nodeId</code>.\n\n# Command `CSS.getInlineStylesForNode`\n\n*Domain Module:* [`cdp::proto::css`](index.html)  \n*Command Struct:* [`cdp::proto::css::GetInlineStylesForNodeCommand`](struct.GetInlineStylesForNodeCommand.html)  \n*Response Struct:* [`cdp::proto::css::GetInlineStylesForNodeResponse`](struct.GetInlineStylesForNodeResponse.html)"]
    pub struct GetInlineStylesForNodeCommand {
        #[serde(rename = "nodeId")]
        pub node_id: ::proto::dom::NodeId,
    }
    impl ::traits::SerializeCdpCommand for GetInlineStylesForNodeCommand {
        fn command_name(&self) -> &str {
            "CSS.getInlineStylesForNode"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for GetInlineStylesForNodeCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CSS.getInlineStylesForNode" {
                Ok ( < GetInlineStylesForNodeCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns the styles defined inline \\(explicitly in the \"style\" attribute and implicitly, using DOM attributes\\) for a DOM node identified by <code>nodeId</code>.\n\n# Command `CSS.getInlineStylesForNode`\n\n*Domain Module:* [`cdp::proto::css`](index.html)  \n*Command Struct:* [`cdp::proto::css::GetInlineStylesForNodeCommand`](struct.GetInlineStylesForNodeCommand.html)  \n*Response Struct:* [`cdp::proto::css::GetInlineStylesForNodeResponse`](struct.GetInlineStylesForNodeResponse.html)"]
    pub struct GetInlineStylesForNodeResponse<'a> {
        #[serde(rename = "inlineStyle", skip_serializing_if = "Option::is_none")]
        #[doc = "Inline style for the specified DOM node."]
        pub inline_style: Option<::proto::css::CssStyle<'a>>,
        #[serde(rename = "attributesStyle", skip_serializing_if = "Option::is_none")]
        #[doc = "Attribute-defined element style \\(e.g. resulting from \"width=20 height=100%\"\\)."]
        pub attributes_style: Option<::proto::css::CssStyle<'a>>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for GetInlineStylesForNodeCommand {
        type Response = GetInlineStylesForNodeResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for GetInlineStylesForNodeResponse<'a> {
        type Command = GetInlineStylesForNodeCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns the computed style for a DOM node identified by <code>nodeId</code>.\n\n# Command `CSS.getComputedStyleForNode`\n\n*Domain Module:* [`cdp::proto::css`](index.html)  \n*Command Struct:* [`cdp::proto::css::GetComputedStyleForNodeCommand`](struct.GetComputedStyleForNodeCommand.html)  \n*Response Struct:* [`cdp::proto::css::GetComputedStyleForNodeResponse`](struct.GetComputedStyleForNodeResponse.html)"]
    pub struct GetComputedStyleForNodeCommand {
        #[serde(rename = "nodeId")]
        pub node_id: ::proto::dom::NodeId,
    }
    impl ::traits::SerializeCdpCommand for GetComputedStyleForNodeCommand {
        fn command_name(&self) -> &str {
            "CSS.getComputedStyleForNode"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for GetComputedStyleForNodeCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CSS.getComputedStyleForNode" {
                Ok ( < GetComputedStyleForNodeCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns the computed style for a DOM node identified by <code>nodeId</code>.\n\n# Command `CSS.getComputedStyleForNode`\n\n*Domain Module:* [`cdp::proto::css`](index.html)  \n*Command Struct:* [`cdp::proto::css::GetComputedStyleForNodeCommand`](struct.GetComputedStyleForNodeCommand.html)  \n*Response Struct:* [`cdp::proto::css::GetComputedStyleForNodeResponse`](struct.GetComputedStyleForNodeResponse.html)"]
    pub struct GetComputedStyleForNodeResponse<'a> {
        #[serde(rename = "computedStyle")]
        #[doc = "Computed style for the specified DOM node."]
        pub computed_style: Vec<::proto::css::CssComputedStyleProperty<'a>>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for GetComputedStyleForNodeCommand {
        type Response = GetComputedStyleForNodeResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for GetComputedStyleForNodeResponse<'a> {
        type Command = GetComputedStyleForNodeCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Requests information about platform fonts which we used to render child TextNodes in the given node.\n\n# Command `CSS.getPlatformFontsForNode`\n\n*Domain Module:* [`cdp::proto::css`](index.html)  \n*Command Struct:* [`cdp::proto::css::GetPlatformFontsForNodeCommand`](struct.GetPlatformFontsForNodeCommand.html)  \n*Response Struct:* [`cdp::proto::css::GetPlatformFontsForNodeResponse`](struct.GetPlatformFontsForNodeResponse.html)"]
    pub struct GetPlatformFontsForNodeCommand {
        #[serde(rename = "nodeId")]
        pub node_id: ::proto::dom::NodeId,
    }
    impl ::traits::SerializeCdpCommand for GetPlatformFontsForNodeCommand {
        fn command_name(&self) -> &str {
            "CSS.getPlatformFontsForNode"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for GetPlatformFontsForNodeCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CSS.getPlatformFontsForNode" {
                Ok ( < GetPlatformFontsForNodeCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Requests information about platform fonts which we used to render child TextNodes in the given node.\n\n# Command `CSS.getPlatformFontsForNode`\n\n*Domain Module:* [`cdp::proto::css`](index.html)  \n*Command Struct:* [`cdp::proto::css::GetPlatformFontsForNodeCommand`](struct.GetPlatformFontsForNodeCommand.html)  \n*Response Struct:* [`cdp::proto::css::GetPlatformFontsForNodeResponse`](struct.GetPlatformFontsForNodeResponse.html)"]
    pub struct GetPlatformFontsForNodeResponse<'a> {
        #[serde(rename = "fonts")]
        #[doc = "Usage statistics for every employed platform font."]
        pub fonts: Vec<::proto::css::PlatformFontUsage<'a>>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for GetPlatformFontsForNodeCommand {
        type Response = GetPlatformFontsForNodeResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for GetPlatformFontsForNodeResponse<'a> {
        type Command = GetPlatformFontsForNodeCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns the current textual content and the URL for a stylesheet.\n\n# Command `CSS.getStyleSheetText`\n\n*Domain Module:* [`cdp::proto::css`](index.html)  \n*Command Struct:* [`cdp::proto::css::GetStyleSheetTextCommand`](struct.GetStyleSheetTextCommand.html)  \n*Response Struct:* [`cdp::proto::css::GetStyleSheetTextResponse`](struct.GetStyleSheetTextResponse.html)"]
    pub struct GetStyleSheetTextCommand<'a> {
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: ::proto::css::StyleSheetId<'a>,
    }
    impl<'a> ::traits::SerializeCdpCommand for GetStyleSheetTextCommand<'a> {
        fn command_name(&self) -> &str {
            "CSS.getStyleSheetText"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for GetStyleSheetTextCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CSS.getStyleSheetText" {
                Ok ( < GetStyleSheetTextCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns the current textual content and the URL for a stylesheet.\n\n# Command `CSS.getStyleSheetText`\n\n*Domain Module:* [`cdp::proto::css`](index.html)  \n*Command Struct:* [`cdp::proto::css::GetStyleSheetTextCommand`](struct.GetStyleSheetTextCommand.html)  \n*Response Struct:* [`cdp::proto::css::GetStyleSheetTextResponse`](struct.GetStyleSheetTextResponse.html)"]
    pub struct GetStyleSheetTextResponse<'a> {
        #[serde(rename = "text")]
        #[doc = "The stylesheet text."]
        pub text: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for GetStyleSheetTextCommand<'a> {
        type Response = GetStyleSheetTextResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for GetStyleSheetTextResponse<'a> {
        type Command = GetStyleSheetTextCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns all class names from specified stylesheet.\n\n# Command `CSS.collectClassNames`\n\n*Domain Module:* [`cdp::proto::css`](index.html)  \n*Command Struct:* [`cdp::proto::css::CollectClassNamesCommand`](struct.CollectClassNamesCommand.html)  \n*Response Struct:* [`cdp::proto::css::CollectClassNamesResponse`](struct.CollectClassNamesResponse.html)"]
    pub struct CollectClassNamesCommand<'a> {
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: ::proto::css::StyleSheetId<'a>,
    }
    impl<'a> ::traits::SerializeCdpCommand for CollectClassNamesCommand<'a> {
        fn command_name(&self) -> &str {
            "CSS.collectClassNames"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for CollectClassNamesCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CSS.collectClassNames" {
                Ok ( < CollectClassNamesCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns all class names from specified stylesheet.\n\n# Command `CSS.collectClassNames`\n\n*Domain Module:* [`cdp::proto::css`](index.html)  \n*Command Struct:* [`cdp::proto::css::CollectClassNamesCommand`](struct.CollectClassNamesCommand.html)  \n*Response Struct:* [`cdp::proto::css::CollectClassNamesResponse`](struct.CollectClassNamesResponse.html)"]
    pub struct CollectClassNamesResponse<'a> {
        #[serde(rename = "classNames")]
        #[doc = "Class name list."]
        pub class_names: Vec<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for CollectClassNamesCommand<'a> {
        type Response = CollectClassNamesResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for CollectClassNamesResponse<'a> {
        type Command = CollectClassNamesCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Sets the new stylesheet text.\n\n# Command `CSS.setStyleSheetText`\n\n*Domain Module:* [`cdp::proto::css`](index.html)  \n*Command Struct:* [`cdp::proto::css::SetStyleSheetTextCommand`](struct.SetStyleSheetTextCommand.html)  \n*Response Struct:* [`cdp::proto::css::SetStyleSheetTextResponse`](struct.SetStyleSheetTextResponse.html)"]
    pub struct SetStyleSheetTextCommand<'a> {
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: ::proto::css::StyleSheetId<'a>,
        #[serde(rename = "text")]
        pub text: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpCommand for SetStyleSheetTextCommand<'a> {
        fn command_name(&self) -> &str {
            "CSS.setStyleSheetText"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for SetStyleSheetTextCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CSS.setStyleSheetText" {
                Ok ( < SetStyleSheetTextCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Sets the new stylesheet text.\n\n# Command `CSS.setStyleSheetText`\n\n*Domain Module:* [`cdp::proto::css`](index.html)  \n*Command Struct:* [`cdp::proto::css::SetStyleSheetTextCommand`](struct.SetStyleSheetTextCommand.html)  \n*Response Struct:* [`cdp::proto::css::SetStyleSheetTextResponse`](struct.SetStyleSheetTextResponse.html)"]
    pub struct SetStyleSheetTextResponse<'a> {
        #[serde(rename = "sourceMapURL", skip_serializing_if = "Option::is_none")]
        #[doc = "URL of source map associated with script \\(if any\\)."]
        pub source_map_url: Option<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetStyleSheetTextCommand<'a> {
        type Response = SetStyleSheetTextResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetStyleSheetTextResponse<'a> {
        type Command = SetStyleSheetTextCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Modifies the rule selector.\n\n# Command `CSS.setRuleSelector`\n\n*Domain Module:* [`cdp::proto::css`](index.html)  \n*Command Struct:* [`cdp::proto::css::SetRuleSelectorCommand`](struct.SetRuleSelectorCommand.html)  \n*Response Struct:* [`cdp::proto::css::SetRuleSelectorResponse`](struct.SetRuleSelectorResponse.html)"]
    pub struct SetRuleSelectorCommand<'a> {
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: ::proto::css::StyleSheetId<'a>,
        #[serde(rename = "range")]
        pub range: ::proto::css::SourceRange,
        #[serde(rename = "selector")]
        pub selector: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpCommand for SetRuleSelectorCommand<'a> {
        fn command_name(&self) -> &str {
            "CSS.setRuleSelector"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for SetRuleSelectorCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CSS.setRuleSelector" {
                Ok(
                    <SetRuleSelectorCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Modifies the rule selector.\n\n# Command `CSS.setRuleSelector`\n\n*Domain Module:* [`cdp::proto::css`](index.html)  \n*Command Struct:* [`cdp::proto::css::SetRuleSelectorCommand`](struct.SetRuleSelectorCommand.html)  \n*Response Struct:* [`cdp::proto::css::SetRuleSelectorResponse`](struct.SetRuleSelectorResponse.html)"]
    pub struct SetRuleSelectorResponse<'a> {
        #[serde(rename = "selectorList")]
        #[doc = "The resulting selector list after modification."]
        pub selector_list: ::proto::css::SelectorList<'a>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetRuleSelectorCommand<'a> {
        type Response = SetRuleSelectorResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetRuleSelectorResponse<'a> {
        type Command = SetRuleSelectorCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Modifies the keyframe rule key text.\n\n# Command `CSS.setKeyframeKey`\n\n*Domain Module:* [`cdp::proto::css`](index.html)  \n*Command Struct:* [`cdp::proto::css::SetKeyframeKeyCommand`](struct.SetKeyframeKeyCommand.html)  \n*Response Struct:* [`cdp::proto::css::SetKeyframeKeyResponse`](struct.SetKeyframeKeyResponse.html)"]
    pub struct SetKeyframeKeyCommand<'a> {
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: ::proto::css::StyleSheetId<'a>,
        #[serde(rename = "range")]
        pub range: ::proto::css::SourceRange,
        #[serde(rename = "keyText")]
        pub key_text: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpCommand for SetKeyframeKeyCommand<'a> {
        fn command_name(&self) -> &str {
            "CSS.setKeyframeKey"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for SetKeyframeKeyCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CSS.setKeyframeKey" {
                Ok(
                    <SetKeyframeKeyCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Modifies the keyframe rule key text.\n\n# Command `CSS.setKeyframeKey`\n\n*Domain Module:* [`cdp::proto::css`](index.html)  \n*Command Struct:* [`cdp::proto::css::SetKeyframeKeyCommand`](struct.SetKeyframeKeyCommand.html)  \n*Response Struct:* [`cdp::proto::css::SetKeyframeKeyResponse`](struct.SetKeyframeKeyResponse.html)"]
    pub struct SetKeyframeKeyResponse<'a> {
        #[serde(rename = "keyText")]
        #[doc = "The resulting key text after modification."]
        pub key_text: ::proto::css::Value<'a>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetKeyframeKeyCommand<'a> {
        type Response = SetKeyframeKeyResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetKeyframeKeyResponse<'a> {
        type Command = SetKeyframeKeyCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Applies specified style edits one after another in the given order.\n\n# Command `CSS.setStyleTexts`\n\n*Domain Module:* [`cdp::proto::css`](index.html)  \n*Command Struct:* [`cdp::proto::css::SetStyleTextsCommand`](struct.SetStyleTextsCommand.html)  \n*Response Struct:* [`cdp::proto::css::SetStyleTextsResponse`](struct.SetStyleTextsResponse.html)"]
    pub struct SetStyleTextsCommand<'a> {
        #[serde(rename = "edits")]
        pub edits: Vec<::proto::css::StyleDeclarationEdit<'a>>,
    }
    impl<'a> ::traits::SerializeCdpCommand for SetStyleTextsCommand<'a> {
        fn command_name(&self) -> &str {
            "CSS.setStyleTexts"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for SetStyleTextsCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CSS.setStyleTexts" {
                Ok(
                    <SetStyleTextsCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Applies specified style edits one after another in the given order.\n\n# Command `CSS.setStyleTexts`\n\n*Domain Module:* [`cdp::proto::css`](index.html)  \n*Command Struct:* [`cdp::proto::css::SetStyleTextsCommand`](struct.SetStyleTextsCommand.html)  \n*Response Struct:* [`cdp::proto::css::SetStyleTextsResponse`](struct.SetStyleTextsResponse.html)"]
    pub struct SetStyleTextsResponse<'a> {
        #[serde(rename = "styles")]
        #[doc = "The resulting styles after modification."]
        pub styles: Vec<::proto::css::CssStyle<'a>>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetStyleTextsCommand<'a> {
        type Response = SetStyleTextsResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetStyleTextsResponse<'a> {
        type Command = SetStyleTextsCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Modifies the rule selector.\n\n# Command `CSS.setMediaText`\n\n*Domain Module:* [`cdp::proto::css`](index.html)  \n*Command Struct:* [`cdp::proto::css::SetMediaTextCommand`](struct.SetMediaTextCommand.html)  \n*Response Struct:* [`cdp::proto::css::SetMediaTextResponse`](struct.SetMediaTextResponse.html)"]
    pub struct SetMediaTextCommand<'a> {
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: ::proto::css::StyleSheetId<'a>,
        #[serde(rename = "range")]
        pub range: ::proto::css::SourceRange,
        #[serde(rename = "text")]
        pub text: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpCommand for SetMediaTextCommand<'a> {
        fn command_name(&self) -> &str {
            "CSS.setMediaText"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for SetMediaTextCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CSS.setMediaText" {
                Ok(
                    <SetMediaTextCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Modifies the rule selector.\n\n# Command `CSS.setMediaText`\n\n*Domain Module:* [`cdp::proto::css`](index.html)  \n*Command Struct:* [`cdp::proto::css::SetMediaTextCommand`](struct.SetMediaTextCommand.html)  \n*Response Struct:* [`cdp::proto::css::SetMediaTextResponse`](struct.SetMediaTextResponse.html)"]
    pub struct SetMediaTextResponse<'a> {
        #[serde(rename = "media")]
        #[doc = "The resulting CSS media rule after modification."]
        pub media: ::proto::css::CssMedia<'a>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetMediaTextCommand<'a> {
        type Response = SetMediaTextResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetMediaTextResponse<'a> {
        type Command = SetMediaTextCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Creates a new special \"via-inspector\" stylesheet in the frame with given <code>frameId</code>.\n\n# Command `CSS.createStyleSheet`\n\n*Domain Module:* [`cdp::proto::css`](index.html)  \n*Command Struct:* [`cdp::proto::css::CreateStyleSheetCommand`](struct.CreateStyleSheetCommand.html)  \n*Response Struct:* [`cdp::proto::css::CreateStyleSheetResponse`](struct.CreateStyleSheetResponse.html)"]
    pub struct CreateStyleSheetCommand<'a> {
        #[serde(rename = "frameId")]
        #[doc = "Identifier of the frame where \"via-inspector\" stylesheet should be created."]
        pub frame_id: ::proto::page::FrameId<'a>,
    }
    impl<'a> ::traits::SerializeCdpCommand for CreateStyleSheetCommand<'a> {
        fn command_name(&self) -> &str {
            "CSS.createStyleSheet"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for CreateStyleSheetCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CSS.createStyleSheet" {
                Ok ( < CreateStyleSheetCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Creates a new special \"via-inspector\" stylesheet in the frame with given <code>frameId</code>.\n\n# Command `CSS.createStyleSheet`\n\n*Domain Module:* [`cdp::proto::css`](index.html)  \n*Command Struct:* [`cdp::proto::css::CreateStyleSheetCommand`](struct.CreateStyleSheetCommand.html)  \n*Response Struct:* [`cdp::proto::css::CreateStyleSheetResponse`](struct.CreateStyleSheetResponse.html)"]
    pub struct CreateStyleSheetResponse<'a> {
        #[serde(rename = "styleSheetId")]
        #[doc = "Identifier of the created \"via-inspector\" stylesheet."]
        pub style_sheet_id: ::proto::css::StyleSheetId<'a>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for CreateStyleSheetCommand<'a> {
        type Response = CreateStyleSheetResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for CreateStyleSheetResponse<'a> {
        type Command = CreateStyleSheetCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Inserts a new rule with the given <code>ruleText</code> in a stylesheet with given <code>styleSheetId</code>, at the position specified by <code>location</code>.\n\n# Command `CSS.addRule`\n\n*Domain Module:* [`cdp::proto::css`](index.html)  \n*Command Struct:* [`cdp::proto::css::AddRuleCommand`](struct.AddRuleCommand.html)  \n*Response Struct:* [`cdp::proto::css::AddRuleResponse`](struct.AddRuleResponse.html)"]
    pub struct AddRuleCommand<'a> {
        #[serde(rename = "styleSheetId")]
        #[doc = "The css style sheet identifier where a new rule should be inserted."]
        pub style_sheet_id: ::proto::css::StyleSheetId<'a>,
        #[serde(rename = "ruleText")]
        #[doc = "The text of a new rule."]
        pub rule_text: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "location")]
        #[doc = "Text position of a new rule in the target style sheet."]
        pub location: ::proto::css::SourceRange,
    }
    impl<'a> ::traits::SerializeCdpCommand for AddRuleCommand<'a> {
        fn command_name(&self) -> &str {
            "CSS.addRule"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for AddRuleCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CSS.addRule" {
                Ok(
                    <AddRuleCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Inserts a new rule with the given <code>ruleText</code> in a stylesheet with given <code>styleSheetId</code>, at the position specified by <code>location</code>.\n\n# Command `CSS.addRule`\n\n*Domain Module:* [`cdp::proto::css`](index.html)  \n*Command Struct:* [`cdp::proto::css::AddRuleCommand`](struct.AddRuleCommand.html)  \n*Response Struct:* [`cdp::proto::css::AddRuleResponse`](struct.AddRuleResponse.html)"]
    pub struct AddRuleResponse<'a> {
        #[serde(rename = "rule")]
        #[doc = "The newly created rule."]
        pub rule: ::proto::css::CssRule<'a>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for AddRuleCommand<'a> {
        type Response = AddRuleResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for AddRuleResponse<'a> {
        type Command = AddRuleCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\nUsed in the type of [`cdp::proto::css::ForcePseudoStateCommand::forced_pseudo_classes`](struct.ForcePseudoStateCommand.html#structfield.forced_pseudo_classes)."]
    pub enum ForcePseudoStateCommandForcedPseudoClasses {
        #[serde(rename = "active")]
        #[doc = "Represented as `\"active\"`."]
        Active,
        #[serde(rename = "focus")]
        #[doc = "Represented as `\"focus\"`."]
        Focus,
        #[serde(rename = "hover")]
        #[doc = "Represented as `\"hover\"`."]
        Hover,
        #[serde(rename = "visited")]
        #[doc = "Represented as `\"visited\"`."]
        Visited,
    }
    impl ForcePseudoStateCommandForcedPseudoClasses {
        pub const ENUM_VALUES: &'static [ForcePseudoStateCommandForcedPseudoClasses] =
            &[
                ForcePseudoStateCommandForcedPseudoClasses::Active,
                ForcePseudoStateCommandForcedPseudoClasses::Focus,
                ForcePseudoStateCommandForcedPseudoClasses::Hover,
                ForcePseudoStateCommandForcedPseudoClasses::Visited,
            ];
        pub const STR_VALUES: &'static [&'static str] = &["active", "focus", "hover", "visited"];
    }
    impl ::std::str::FromStr for ForcePseudoStateCommandForcedPseudoClasses {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "active" => Ok(ForcePseudoStateCommandForcedPseudoClasses::Active),
                "focus" => Ok(ForcePseudoStateCommandForcedPseudoClasses::Focus),
                "hover" => Ok(ForcePseudoStateCommandForcedPseudoClasses::Hover),
                "visited" => Ok(ForcePseudoStateCommandForcedPseudoClasses::Visited),
                _ => Err(::proto::ParseEnumError {
                    expected: ForcePseudoStateCommandForcedPseudoClasses::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for ForcePseudoStateCommandForcedPseudoClasses {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    ForcePseudoStateCommandForcedPseudoClasses::Active => "active",
                    ForcePseudoStateCommandForcedPseudoClasses::Focus => "focus",
                    ForcePseudoStateCommandForcedPseudoClasses::Hover => "hover",
                    ForcePseudoStateCommandForcedPseudoClasses::Visited => "visited",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Ensures that the given node will have specified pseudo-classes whenever its style is computed by the browser.\n\n# Command `CSS.forcePseudoState`\n\n*Domain Module:* [`cdp::proto::css`](index.html)  \n*Command Struct:* [`cdp::proto::css::ForcePseudoStateCommand`](struct.ForcePseudoStateCommand.html)  \n*Response Struct:* [`cdp::proto::css::ForcePseudoStateResponse`](struct.ForcePseudoStateResponse.html)"]
    pub struct ForcePseudoStateCommand {
        #[serde(rename = "nodeId")]
        #[doc = "The element id for which to force the pseudo state."]
        pub node_id: ::proto::dom::NodeId,
        #[serde(rename = "forcedPseudoClasses")]
        #[doc = "Element pseudo classes to force when computing the element's style."]
        pub forced_pseudo_classes:
            Vec<::proto::css::ForcePseudoStateCommandForcedPseudoClasses>,
    }
    impl ::traits::SerializeCdpCommand for ForcePseudoStateCommand {
        fn command_name(&self) -> &str {
            "CSS.forcePseudoState"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for ForcePseudoStateCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CSS.forcePseudoState" {
                Ok ( < ForcePseudoStateCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Ensures that the given node will have specified pseudo-classes whenever its style is computed by the browser.\n\n# Command `CSS.forcePseudoState`\n\n*Domain Module:* [`cdp::proto::css`](index.html)  \n*Command Struct:* [`cdp::proto::css::ForcePseudoStateCommand`](struct.ForcePseudoStateCommand.html)  \n*Response Struct:* [`cdp::proto::css::ForcePseudoStateResponse`](struct.ForcePseudoStateResponse.html)"]
    pub struct ForcePseudoStateResponse;
    impl ::serde::Serialize for ForcePseudoStateResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ForcePseudoStateResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ForcePseudoStateResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for ForcePseudoStateCommand {
        type Response = ForcePseudoStateResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for ForcePseudoStateResponse {
        type Command = ForcePseudoStateCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns all media queries parsed by the rendering engine.\n\n# Command `CSS.getMediaQueries`\n\n*Domain Module:* [`cdp::proto::css`](index.html)  \n*Command Struct:* [`cdp::proto::css::GetMediaQueriesCommand`](struct.GetMediaQueriesCommand.html)  \n*Response Struct:* [`cdp::proto::css::GetMediaQueriesResponse`](struct.GetMediaQueriesResponse.html)"]
    pub struct GetMediaQueriesCommand;
    impl ::serde::Serialize for GetMediaQueriesCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetMediaQueriesCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| GetMediaQueriesCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for GetMediaQueriesCommand {
        fn command_name(&self) -> &str {
            "CSS.getMediaQueries"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for GetMediaQueriesCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CSS.getMediaQueries" {
                Ok(
                    <GetMediaQueriesCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns all media queries parsed by the rendering engine.\n\n# Command `CSS.getMediaQueries`\n\n*Domain Module:* [`cdp::proto::css`](index.html)  \n*Command Struct:* [`cdp::proto::css::GetMediaQueriesCommand`](struct.GetMediaQueriesCommand.html)  \n*Response Struct:* [`cdp::proto::css::GetMediaQueriesResponse`](struct.GetMediaQueriesResponse.html)"]
    pub struct GetMediaQueriesResponse<'a> {
        #[serde(rename = "medias")]
        pub medias: Vec<::proto::css::CssMedia<'a>>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for GetMediaQueriesCommand {
        type Response = GetMediaQueriesResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for GetMediaQueriesResponse<'a> {
        type Command = GetMediaQueriesCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Find a rule with the given active property for the given node and set the new value for this property\n\n# Command `CSS.setEffectivePropertyValueForNode`\n\n*Domain Module:* [`cdp::proto::css`](index.html)  \n*Command Struct:* [`cdp::proto::css::SetEffectivePropertyValueForNodeCommand`](struct.SetEffectivePropertyValueForNodeCommand.html)  \n*Response Struct:* [`cdp::proto::css::SetEffectivePropertyValueForNodeResponse`](struct.SetEffectivePropertyValueForNodeResponse.html)"]
    pub struct SetEffectivePropertyValueForNodeCommand<'a> {
        #[serde(rename = "nodeId")]
        #[doc = "The element id for which to set property."]
        pub node_id: ::proto::dom::NodeId,
        #[serde(rename = "propertyName")]
        pub property_name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "value")]
        pub value: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpCommand for SetEffectivePropertyValueForNodeCommand<'a> {
        fn command_name(&self) -> &str {
            "CSS.setEffectivePropertyValueForNode"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for SetEffectivePropertyValueForNodeCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CSS.setEffectivePropertyValueForNode" {
                Ok ( < SetEffectivePropertyValueForNodeCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Find a rule with the given active property for the given node and set the new value for this property\n\n# Command `CSS.setEffectivePropertyValueForNode`\n\n*Domain Module:* [`cdp::proto::css`](index.html)  \n*Command Struct:* [`cdp::proto::css::SetEffectivePropertyValueForNodeCommand`](struct.SetEffectivePropertyValueForNodeCommand.html)  \n*Response Struct:* [`cdp::proto::css::SetEffectivePropertyValueForNodeResponse`](struct.SetEffectivePropertyValueForNodeResponse.html)"]
    pub struct SetEffectivePropertyValueForNodeResponse;
    impl ::serde::Serialize for SetEffectivePropertyValueForNodeResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetEffectivePropertyValueForNodeResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetEffectivePropertyValueForNodeResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetEffectivePropertyValueForNodeCommand<'a> {
        type Response = SetEffectivePropertyValueForNodeResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetEffectivePropertyValueForNodeResponse {
        type Command = SetEffectivePropertyValueForNodeCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `CSS.getBackgroundColors`\n\n*Domain Module:* [`cdp::proto::css`](index.html)  \n*Command Struct:* [`cdp::proto::css::GetBackgroundColorsCommand`](struct.GetBackgroundColorsCommand.html)  \n*Response Struct:* [`cdp::proto::css::GetBackgroundColorsResponse`](struct.GetBackgroundColorsResponse.html)"]
    pub struct GetBackgroundColorsCommand {
        #[serde(rename = "nodeId")]
        #[doc = "Id of the node to get background colors for."]
        pub node_id: ::proto::dom::NodeId,
    }
    impl ::traits::SerializeCdpCommand for GetBackgroundColorsCommand {
        fn command_name(&self) -> &str {
            "CSS.getBackgroundColors"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for GetBackgroundColorsCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CSS.getBackgroundColors" {
                Ok ( < GetBackgroundColorsCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `CSS.getBackgroundColors`\n\n*Domain Module:* [`cdp::proto::css`](index.html)  \n*Command Struct:* [`cdp::proto::css::GetBackgroundColorsCommand`](struct.GetBackgroundColorsCommand.html)  \n*Response Struct:* [`cdp::proto::css::GetBackgroundColorsResponse`](struct.GetBackgroundColorsResponse.html)"]
    pub struct GetBackgroundColorsResponse<'a> {
        #[serde(rename = "backgroundColors", skip_serializing_if = "Option::is_none")]
        #[doc = "The range of background colors behind this element, if it contains any visible text. If no visible text is present, this will be undefined. In the case of a flat background color, this will consist of simply that color. In the case of a gradient, this will consist of each of the color stops. For anything more complicated, this will be an empty array. Images will be ignored \\(as if the image had failed to load\\)."]
        pub background_colors: Option<Vec<::std::borrow::Cow<'a, str>>>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for GetBackgroundColorsCommand {
        type Response = GetBackgroundColorsResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for GetBackgroundColorsResponse<'a> {
        type Command = GetBackgroundColorsCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables the selector recording.\n\n# Command `CSS.startRuleUsageTracking`\n\n*Domain Module:* [`cdp::proto::css`](index.html)  \n*Command Struct:* [`cdp::proto::css::StartRuleUsageTrackingCommand`](struct.StartRuleUsageTrackingCommand.html)  \n*Response Struct:* [`cdp::proto::css::StartRuleUsageTrackingResponse`](struct.StartRuleUsageTrackingResponse.html)"]
    pub struct StartRuleUsageTrackingCommand;
    impl ::serde::Serialize for StartRuleUsageTrackingCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StartRuleUsageTrackingCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StartRuleUsageTrackingCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for StartRuleUsageTrackingCommand {
        fn command_name(&self) -> &str {
            "CSS.startRuleUsageTracking"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for StartRuleUsageTrackingCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CSS.startRuleUsageTracking" {
                Ok ( < StartRuleUsageTrackingCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables the selector recording.\n\n# Command `CSS.startRuleUsageTracking`\n\n*Domain Module:* [`cdp::proto::css`](index.html)  \n*Command Struct:* [`cdp::proto::css::StartRuleUsageTrackingCommand`](struct.StartRuleUsageTrackingCommand.html)  \n*Response Struct:* [`cdp::proto::css::StartRuleUsageTrackingResponse`](struct.StartRuleUsageTrackingResponse.html)"]
    pub struct StartRuleUsageTrackingResponse;
    impl ::serde::Serialize for StartRuleUsageTrackingResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StartRuleUsageTrackingResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StartRuleUsageTrackingResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for StartRuleUsageTrackingCommand {
        type Response = StartRuleUsageTrackingResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for StartRuleUsageTrackingResponse {
        type Command = StartRuleUsageTrackingCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Obtain list of rules that became used since last call to this method \\(or since start of coverage instrumentation\\)\n\n# Command `CSS.takeCoverageDelta`\n\n*Domain Module:* [`cdp::proto::css`](index.html)  \n*Command Struct:* [`cdp::proto::css::TakeCoverageDeltaCommand`](struct.TakeCoverageDeltaCommand.html)  \n*Response Struct:* [`cdp::proto::css::TakeCoverageDeltaResponse`](struct.TakeCoverageDeltaResponse.html)"]
    pub struct TakeCoverageDeltaCommand;
    impl ::serde::Serialize for TakeCoverageDeltaCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for TakeCoverageDeltaCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| TakeCoverageDeltaCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for TakeCoverageDeltaCommand {
        fn command_name(&self) -> &str {
            "CSS.takeCoverageDelta"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for TakeCoverageDeltaCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CSS.takeCoverageDelta" {
                Ok ( < TakeCoverageDeltaCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Obtain list of rules that became used since last call to this method \\(or since start of coverage instrumentation\\)\n\n# Command `CSS.takeCoverageDelta`\n\n*Domain Module:* [`cdp::proto::css`](index.html)  \n*Command Struct:* [`cdp::proto::css::TakeCoverageDeltaCommand`](struct.TakeCoverageDeltaCommand.html)  \n*Response Struct:* [`cdp::proto::css::TakeCoverageDeltaResponse`](struct.TakeCoverageDeltaResponse.html)"]
    pub struct TakeCoverageDeltaResponse<'a> {
        #[serde(rename = "coverage")]
        pub coverage: Vec<::proto::css::RuleUsage<'a>>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for TakeCoverageDeltaCommand {
        type Response = TakeCoverageDeltaResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for TakeCoverageDeltaResponse<'a> {
        type Command = TakeCoverageDeltaCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> The list of rules with an indication of whether these were used\n\n# Command `CSS.stopRuleUsageTracking`\n\n*Domain Module:* [`cdp::proto::css`](index.html)  \n*Command Struct:* [`cdp::proto::css::StopRuleUsageTrackingCommand`](struct.StopRuleUsageTrackingCommand.html)  \n*Response Struct:* [`cdp::proto::css::StopRuleUsageTrackingResponse`](struct.StopRuleUsageTrackingResponse.html)"]
    pub struct StopRuleUsageTrackingCommand;
    impl ::serde::Serialize for StopRuleUsageTrackingCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StopRuleUsageTrackingCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StopRuleUsageTrackingCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for StopRuleUsageTrackingCommand {
        fn command_name(&self) -> &str {
            "CSS.stopRuleUsageTracking"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for StopRuleUsageTrackingCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CSS.stopRuleUsageTracking" {
                Ok ( < StopRuleUsageTrackingCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> The list of rules with an indication of whether these were used\n\n# Command `CSS.stopRuleUsageTracking`\n\n*Domain Module:* [`cdp::proto::css`](index.html)  \n*Command Struct:* [`cdp::proto::css::StopRuleUsageTrackingCommand`](struct.StopRuleUsageTrackingCommand.html)  \n*Response Struct:* [`cdp::proto::css::StopRuleUsageTrackingResponse`](struct.StopRuleUsageTrackingResponse.html)"]
    pub struct StopRuleUsageTrackingResponse<'a> {
        #[serde(rename = "ruleUsage")]
        pub rule_usage: Vec<::proto::css::RuleUsage<'a>>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for StopRuleUsageTrackingCommand {
        type Response = StopRuleUsageTrackingResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for StopRuleUsageTrackingResponse<'a> {
        type Command = StopRuleUsageTrackingCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Fires whenever a MediaQuery result changes \\(for example, after a browser window has been resized.\\) The current implementation considers only viewport-dependent media features.\n\n# Event `CSS.mediaQueryResultChanged`\n\n*Domain Module:* [`cdp::proto::css`](index.html)  \n*Event Struct:* [`cdp::proto::css::MediaQueryResultChangedEvent`](struct.MediaQueryResultChangedEvent.html)"]
    pub struct MediaQueryResultChangedEvent;
    impl ::serde::Serialize for MediaQueryResultChangedEvent {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for MediaQueryResultChangedEvent {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| MediaQueryResultChangedEvent)
        }
    }
    impl ::traits::SerializeCdpEvent for MediaQueryResultChangedEvent {
        fn event_name(&self) -> &str {
            "CSS.mediaQueryResultChanged"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpEvent<'de> for MediaQueryResultChangedEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CSS.mediaQueryResultChanged" {
                Ok ( < MediaQueryResultChangedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Fires whenever a web font gets loaded.\n\n# Event `CSS.fontsUpdated`\n\n*Domain Module:* [`cdp::proto::css`](index.html)  \n*Event Struct:* [`cdp::proto::css::FontsUpdatedEvent`](struct.FontsUpdatedEvent.html)"]
    pub struct FontsUpdatedEvent;
    impl ::serde::Serialize for FontsUpdatedEvent {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for FontsUpdatedEvent {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| FontsUpdatedEvent)
        }
    }
    impl ::traits::SerializeCdpEvent for FontsUpdatedEvent {
        fn event_name(&self) -> &str {
            "CSS.fontsUpdated"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpEvent<'de> for FontsUpdatedEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CSS.fontsUpdated" {
                Ok(
                    <FontsUpdatedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Fired whenever a stylesheet is changed as a result of the client operation.\n\n# Event `CSS.styleSheetChanged`\n\n*Domain Module:* [`cdp::proto::css`](index.html)  \n*Event Struct:* [`cdp::proto::css::StyleSheetChangedEvent`](struct.StyleSheetChangedEvent.html)"]
    pub struct StyleSheetChangedEvent<'a> {
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: ::proto::css::StyleSheetId<'a>,
    }
    impl<'a> ::traits::SerializeCdpEvent for StyleSheetChangedEvent<'a> {
        fn event_name(&self) -> &str {
            "CSS.styleSheetChanged"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for StyleSheetChangedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CSS.styleSheetChanged" {
                Ok(
                    <StyleSheetChangedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Fired whenever an active document stylesheet is added.\n\n# Event `CSS.styleSheetAdded`\n\n*Domain Module:* [`cdp::proto::css`](index.html)  \n*Event Struct:* [`cdp::proto::css::StyleSheetAddedEvent`](struct.StyleSheetAddedEvent.html)"]
    pub struct StyleSheetAddedEvent<'a> {
        #[serde(rename = "header")]
        #[doc = "Added stylesheet metainfo."]
        pub header: ::proto::css::CssStyleSheetHeader<'a>,
    }
    impl<'a> ::traits::SerializeCdpEvent for StyleSheetAddedEvent<'a> {
        fn event_name(&self) -> &str {
            "CSS.styleSheetAdded"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for StyleSheetAddedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CSS.styleSheetAdded" {
                Ok(
                    <StyleSheetAddedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Fired whenever an active document stylesheet is removed.\n\n# Event `CSS.styleSheetRemoved`\n\n*Domain Module:* [`cdp::proto::css`](index.html)  \n*Event Struct:* [`cdp::proto::css::StyleSheetRemovedEvent`](struct.StyleSheetRemovedEvent.html)"]
    pub struct StyleSheetRemovedEvent<'a> {
        #[serde(rename = "styleSheetId")]
        #[doc = "Identifier of the removed stylesheet."]
        pub style_sheet_id: ::proto::css::StyleSheetId<'a>,
    }
    impl<'a> ::traits::SerializeCdpEvent for StyleSheetRemovedEvent<'a> {
        fn event_name(&self) -> &str {
            "CSS.styleSheetRemoved"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for StyleSheetRemovedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CSS.styleSheetRemoved" {
                Ok(
                    <StyleSheetRemovedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>"]
    pub type StyleSheetId<'a> = ::std::borrow::Cow<'a, str>;
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Stylesheet type: \"injected\" for stylesheets injected via extension, \"user-agent\" for user-agent stylesheets, \"inspector\" for stylesheets created by the inspector \\(i.e. those holding the \"via inspector\" rules\\), \"regular\" for regular stylesheets."]
    pub enum StyleSheetOrigin {
        #[serde(rename = "injected")]
        #[doc = "Represented as `\"injected\"`."]
        Injected,
        #[serde(rename = "user-agent")]
        #[doc = "Represented as `\"user-agent\"`."]
        UserAgent,
        #[serde(rename = "inspector")]
        #[doc = "Represented as `\"inspector\"`."]
        Inspector,
        #[serde(rename = "regular")]
        #[doc = "Represented as `\"regular\"`."]
        Regular,
    }
    impl StyleSheetOrigin {
        pub const ENUM_VALUES: &'static [StyleSheetOrigin] = &[
            StyleSheetOrigin::Injected,
            StyleSheetOrigin::UserAgent,
            StyleSheetOrigin::Inspector,
            StyleSheetOrigin::Regular,
        ];
        pub const STR_VALUES: &'static [&'static str] =
            &["injected", "user-agent", "inspector", "regular"];
    }
    impl ::std::str::FromStr for StyleSheetOrigin {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "injected" => Ok(StyleSheetOrigin::Injected),
                "user-agent" => Ok(StyleSheetOrigin::UserAgent),
                "inspector" => Ok(StyleSheetOrigin::Inspector),
                "regular" => Ok(StyleSheetOrigin::Regular),
                _ => Err(::proto::ParseEnumError {
                    expected: StyleSheetOrigin::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for StyleSheetOrigin {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    StyleSheetOrigin::Injected => "injected",
                    StyleSheetOrigin::UserAgent => "user-agent",
                    StyleSheetOrigin::Inspector => "inspector",
                    StyleSheetOrigin::Regular => "regular",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> CSS rule collection for a single pseudo style."]
    pub struct PseudoElementMatches<'a> {
        #[serde(rename = "pseudoType")]
        #[doc = "Pseudo element type."]
        pub pseudo_type: ::proto::dom::PseudoType,
        #[serde(rename = "matches")]
        #[doc = "Matches of CSS rules applicable to the pseudo style."]
        pub matches: Vec<::proto::css::RuleMatch<'a>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Inherited CSS rule collection from ancestor node."]
    pub struct InheritedStyleEntry<'a> {
        #[serde(rename = "inlineStyle", skip_serializing_if = "Option::is_none")]
        #[doc = "The ancestor node's inline style, if any, in the style inheritance chain."]
        pub inline_style: Option<::proto::css::CssStyle<'a>>,
        #[serde(rename = "matchedCSSRules")]
        #[doc = "Matches of CSS rules matching the ancestor node in the style inheritance chain."]
        pub matched_css_rules: Vec<::proto::css::RuleMatch<'a>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Match data for a CSS rule."]
    pub struct RuleMatch<'a> {
        #[serde(rename = "rule")]
        #[doc = "CSS rule in the match."]
        pub rule: ::proto::css::CssRule<'a>,
        #[serde(rename = "matchingSelectors")]
        #[doc = "Matching selector indices in the rule's selectorList selectors \\(0-based\\)."]
        pub matching_selectors: Vec<i32>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Data for a simple selector \\(these are delimited by commas in a selector list\\)."]
    pub struct Value<'a> {
        #[serde(rename = "text")]
        #[doc = "Value text."]
        pub text: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "range", skip_serializing_if = "Option::is_none")]
        #[doc = "Value range in the underlying resource \\(if available\\)."]
        pub range: Option<::proto::css::SourceRange>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Selector list data."]
    pub struct SelectorList<'a> {
        #[serde(rename = "selectors")]
        #[doc = "Selectors in the list."]
        pub selectors: Vec<::proto::css::Value<'a>>,
        #[serde(rename = "text")]
        #[doc = "Rule selector text."]
        pub text: ::std::borrow::Cow<'a, str>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> CSS stylesheet metainformation."]
    pub struct CssStyleSheetHeader<'a> {
        #[serde(rename = "styleSheetId")]
        #[doc = "The stylesheet identifier."]
        pub style_sheet_id: ::proto::css::StyleSheetId<'a>,
        #[serde(rename = "frameId")]
        #[doc = "Owner frame identifier."]
        pub frame_id: ::proto::page::FrameId<'a>,
        #[serde(rename = "sourceURL")]
        #[doc = "Stylesheet resource URL."]
        pub source_url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "sourceMapURL", skip_serializing_if = "Option::is_none")]
        #[doc = "URL of source map associated with the stylesheet \\(if any\\)."]
        pub source_map_url: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "origin")]
        #[doc = "Stylesheet origin."]
        pub origin: ::proto::css::StyleSheetOrigin,
        #[serde(rename = "title")]
        #[doc = "Stylesheet title."]
        pub title: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "ownerNode", skip_serializing_if = "Option::is_none")]
        #[doc = "The backend id for the owner node of the stylesheet."]
        pub owner_node: Option<::proto::dom::BackendNodeId>,
        #[serde(rename = "disabled")]
        #[doc = "Denotes whether the stylesheet is disabled."]
        pub disabled: bool,
        #[serde(rename = "hasSourceURL", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether the sourceURL field value comes from the sourceURL comment."]
        pub has_source_url: Option<bool>,
        #[serde(rename = "isInline")]
        #[doc = "Whether this stylesheet is created for STYLE tag by parser. This flag is not set for document.written STYLE tags."]
        pub is_inline: bool,
        #[serde(rename = "startLine")]
        #[doc = "Line offset of the stylesheet within the resource \\(zero based\\)."]
        pub start_line: f64,
        #[serde(rename = "startColumn")]
        #[doc = "Column offset of the stylesheet within the resource \\(zero based\\)."]
        pub start_column: f64,
        #[serde(rename = "length")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Size of the content \\(in characters\\)."]
        pub length: f64,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> CSS rule representation."]
    pub struct CssRule<'a> {
        #[serde(rename = "styleSheetId", skip_serializing_if = "Option::is_none")]
        #[doc = "The css style sheet identifier \\(absent for user agent stylesheet and user-specified stylesheet rules\\) this rule came from."]
        pub style_sheet_id: Option<::proto::css::StyleSheetId<'a>>,
        #[serde(rename = "selectorList")]
        #[doc = "Rule selector data."]
        pub selector_list: ::proto::css::SelectorList<'a>,
        #[serde(rename = "origin")]
        #[doc = "Parent stylesheet's origin."]
        pub origin: ::proto::css::StyleSheetOrigin,
        #[serde(rename = "style")]
        #[doc = "Associated style declaration."]
        pub style: ::proto::css::CssStyle<'a>,
        #[serde(rename = "media", skip_serializing_if = "Option::is_none")]
        #[doc = "Media list array \\(for rules involving media queries\\). The array enumerates media queries starting with the innermost one, going outwards."]
        pub media: Option<Vec<::proto::css::CssMedia<'a>>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> CSS coverage information."]
    pub struct RuleUsage<'a> {
        #[serde(rename = "styleSheetId")]
        #[doc = "The css style sheet identifier \\(absent for user agent stylesheet and user-specified stylesheet rules\\) this rule came from."]
        pub style_sheet_id: ::proto::css::StyleSheetId<'a>,
        #[serde(rename = "startOffset")]
        #[doc = "Offset of the start of the rule \\(including selector\\) from the beginning of the stylesheet."]
        pub start_offset: f64,
        #[serde(rename = "endOffset")]
        #[doc = "Offset of the end of the rule body from the beginning of the stylesheet."]
        pub end_offset: f64,
        #[serde(rename = "used")]
        #[doc = "Indicates whether the rule was actually used by some element in the page."]
        pub used: bool,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Text range within a resource. All numbers are zero-based."]
    pub struct SourceRange {
        #[serde(rename = "startLine")]
        #[doc = "Start line of range."]
        pub start_line: i32,
        #[serde(rename = "startColumn")]
        #[doc = "Start column of range \\(inclusive\\)."]
        pub start_column: i32,
        #[serde(rename = "endLine")]
        #[doc = "End line of range"]
        pub end_line: i32,
        #[serde(rename = "endColumn")]
        #[doc = "End column of range \\(exclusive\\)."]
        pub end_column: i32,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>"]
    pub struct ShorthandEntry<'a> {
        #[serde(rename = "name")]
        #[doc = "Shorthand name."]
        pub name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "value")]
        #[doc = "Shorthand value."]
        pub value: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "important", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether the property has \"!important\" annotation \\(implies <code>false</code> if absent\\)."]
        pub important: Option<bool>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>"]
    pub struct CssComputedStyleProperty<'a> {
        #[serde(rename = "name")]
        #[doc = "Computed style property name."]
        pub name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "value")]
        #[doc = "Computed style property value."]
        pub value: ::std::borrow::Cow<'a, str>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> CSS style representation."]
    pub struct CssStyle<'a> {
        #[serde(rename = "styleSheetId", skip_serializing_if = "Option::is_none")]
        #[doc = "The css style sheet identifier \\(absent for user agent stylesheet and user-specified stylesheet rules\\) this rule came from."]
        pub style_sheet_id: Option<::proto::css::StyleSheetId<'a>>,
        #[serde(rename = "cssProperties")]
        #[doc = "CSS properties in the style."]
        pub css_properties: Vec<::proto::css::CssProperty<'a>>,
        #[serde(rename = "shorthandEntries")]
        #[doc = "Computed values for all shorthands found in the style."]
        pub shorthand_entries: Vec<::proto::css::ShorthandEntry<'a>>,
        #[serde(rename = "cssText", skip_serializing_if = "Option::is_none")]
        #[doc = "Style declaration text \\(if available\\)."]
        pub css_text: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "range", skip_serializing_if = "Option::is_none")]
        #[doc = "Style declaration range in the enclosing stylesheet \\(if available\\)."]
        pub range: Option<::proto::css::SourceRange>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> CSS property declaration data."]
    pub struct CssProperty<'a> {
        #[serde(rename = "name")]
        #[doc = "The property name."]
        pub name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "value")]
        #[doc = "The property value."]
        pub value: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "important", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether the property has \"!important\" annotation \\(implies <code>false</code> if absent\\)."]
        pub important: Option<bool>,
        #[serde(rename = "implicit", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether the property is implicit \\(implies <code>false</code> if absent\\)."]
        pub implicit: Option<bool>,
        #[serde(rename = "text", skip_serializing_if = "Option::is_none")]
        #[doc = "The full property text as specified in the style."]
        pub text: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "parsedOk", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether the property is understood by the browser \\(implies <code>true</code> if absent\\)."]
        pub parsed_ok: Option<bool>,
        #[serde(rename = "disabled", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether the property is disabled by the user \\(present for source-based properties only\\)."]
        pub disabled: Option<bool>,
        #[serde(rename = "range", skip_serializing_if = "Option::is_none")]
        #[doc = "The entire property range in the enclosing style declaration \\(if available\\)."]
        pub range: Option<::proto::css::SourceRange>,
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\nUsed in the type of [`cdp::proto::css::CssMedia::source`](struct.CssMedia.html#structfield.source)."]
    pub enum CssMediaSource {
        #[serde(rename = "mediaRule")]
        #[doc = "Represented as `\"mediaRule\"`."]
        MediaRule,
        #[serde(rename = "importRule")]
        #[doc = "Represented as `\"importRule\"`."]
        ImportRule,
        #[serde(rename = "linkedSheet")]
        #[doc = "Represented as `\"linkedSheet\"`."]
        LinkedSheet,
        #[serde(rename = "inlineSheet")]
        #[doc = "Represented as `\"inlineSheet\"`."]
        InlineSheet,
    }
    impl CssMediaSource {
        pub const ENUM_VALUES: &'static [CssMediaSource] = &[
            CssMediaSource::MediaRule,
            CssMediaSource::ImportRule,
            CssMediaSource::LinkedSheet,
            CssMediaSource::InlineSheet,
        ];
        pub const STR_VALUES: &'static [&'static str] =
            &["mediaRule", "importRule", "linkedSheet", "inlineSheet"];
    }
    impl ::std::str::FromStr for CssMediaSource {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "mediaRule" => Ok(CssMediaSource::MediaRule),
                "importRule" => Ok(CssMediaSource::ImportRule),
                "linkedSheet" => Ok(CssMediaSource::LinkedSheet),
                "inlineSheet" => Ok(CssMediaSource::InlineSheet),
                _ => Err(::proto::ParseEnumError {
                    expected: CssMediaSource::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for CssMediaSource {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    CssMediaSource::MediaRule => "mediaRule",
                    CssMediaSource::ImportRule => "importRule",
                    CssMediaSource::LinkedSheet => "linkedSheet",
                    CssMediaSource::InlineSheet => "inlineSheet",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> CSS media rule descriptor."]
    pub struct CssMedia<'a> {
        #[serde(rename = "text")]
        #[doc = "Media query text."]
        pub text: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "source")]
        #[doc = "Source of the media query: \"mediaRule\" if specified by a @media rule, \"importRule\" if specified by an @import rule, \"linkedSheet\" if specified by a \"media\" attribute in a linked stylesheet's LINK tag, \"inlineSheet\" if specified by a \"media\" attribute in an inline stylesheet's STYLE tag."]
        pub source: ::proto::css::CssMediaSource,
        #[serde(rename = "sourceURL", skip_serializing_if = "Option::is_none")]
        #[doc = "URL of the document containing the media query description."]
        pub source_url: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "range", skip_serializing_if = "Option::is_none")]
        #[doc = "The associated rule \\(@media or @import\\) header range in the enclosing stylesheet \\(if available\\)."]
        pub range: Option<::proto::css::SourceRange>,
        #[serde(rename = "styleSheetId", skip_serializing_if = "Option::is_none")]
        #[doc = "Identifier of the stylesheet containing this object \\(if exists\\)."]
        pub style_sheet_id: Option<::proto::css::StyleSheetId<'a>>,
        #[serde(rename = "mediaList", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Array of media queries."]
        pub media_list: Option<Vec<::proto::css::MediaQuery<'a>>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Media query descriptor."]
    pub struct MediaQuery<'a> {
        #[serde(rename = "expressions")]
        #[doc = "Array of media query expressions."]
        pub expressions: Vec<::proto::css::MediaQueryExpression<'a>>,
        #[serde(rename = "active")]
        #[doc = "Whether the media query condition is satisfied."]
        pub active: bool,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Media query expression descriptor."]
    pub struct MediaQueryExpression<'a> {
        #[serde(rename = "value")]
        #[doc = "Media query expression value."]
        pub value: f64,
        #[serde(rename = "unit")]
        #[doc = "Media query expression units."]
        pub unit: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "feature")]
        #[doc = "Media query expression feature."]
        pub feature: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "valueRange", skip_serializing_if = "Option::is_none")]
        #[doc = "The associated range of the value text in the enclosing stylesheet \\(if available\\)."]
        pub value_range: Option<::proto::css::SourceRange>,
        #[serde(rename = "computedLength", skip_serializing_if = "Option::is_none")]
        #[doc = "Computed length of media query expression \\(if applicable\\)."]
        pub computed_length: Option<f64>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Information about amount of glyphs that were rendered with given font."]
    pub struct PlatformFontUsage<'a> {
        #[serde(rename = "familyName")]
        #[doc = "Font's family name reported by platform."]
        pub family_name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "isCustomFont")]
        #[doc = "Indicates if the font was downloaded or resolved locally."]
        pub is_custom_font: bool,
        #[serde(rename = "glyphCount")]
        #[doc = "Amount of glyphs that were rendered with this font."]
        pub glyph_count: f64,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> CSS keyframes rule representation."]
    pub struct CssKeyframesRule<'a> {
        #[serde(rename = "animationName")]
        #[doc = "Animation name."]
        pub animation_name: ::proto::css::Value<'a>,
        #[serde(rename = "keyframes")]
        #[doc = "List of keyframes."]
        pub keyframes: Vec<::proto::css::CssKeyframeRule<'a>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> CSS keyframe rule representation."]
    pub struct CssKeyframeRule<'a> {
        #[serde(rename = "styleSheetId", skip_serializing_if = "Option::is_none")]
        #[doc = "The css style sheet identifier \\(absent for user agent stylesheet and user-specified stylesheet rules\\) this rule came from."]
        pub style_sheet_id: Option<::proto::css::StyleSheetId<'a>>,
        #[serde(rename = "origin")]
        #[doc = "Parent stylesheet's origin."]
        pub origin: ::proto::css::StyleSheetOrigin,
        #[serde(rename = "keyText")]
        #[doc = "Associated key text."]
        pub key_text: ::proto::css::Value<'a>,
        #[serde(rename = "style")]
        #[doc = "Associated style declaration."]
        pub style: ::proto::css::CssStyle<'a>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> A descriptor of operation to mutate style declaration text."]
    pub struct StyleDeclarationEdit<'a> {
        #[serde(rename = "styleSheetId")]
        #[doc = "The css style sheet identifier."]
        pub style_sheet_id: ::proto::css::StyleSheetId<'a>,
        #[serde(rename = "range")]
        #[doc = "The range of the style text in the enclosing stylesheet."]
        pub range: ::proto::css::SourceRange,
        #[serde(rename = "text")]
        #[doc = "New style text."]
        pub text: ::std::borrow::Cow<'a, str>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Details of post layout rendered text positions. The exact layout should not be regarded as stable and may change between versions."]
    pub struct InlineTextBox {
        #[serde(rename = "boundingBox")]
        #[doc = "The absolute position bounding box."]
        pub bounding_box: ::proto::dom::Rect,
        #[serde(rename = "startCharacterIndex")]
        #[doc = "The starting index in characters, for this post layout textbox substring."]
        pub start_character_index: i32,
        #[serde(rename = "numCharacters")]
        #[doc = "The number of characters in this post layout textbox substring."]
        pub num_characters: i32,
    }
}
#[doc = "<span class=\"stab unstable\">[Experimental]</span> This domain facilitates obtaining document snapshots with DOM, layout, and style information.\n\n# DOMSnapshot\n\n## Commands\n\n- [`DOMSnapshot.getSnapshot`](struct.GetSnapshotCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns a document snapshot, including the full DOM tree of the root node \\(including iframes, template contents, and imported documents\\) in a flattened array, as well as layout and white-listed computed style information for the nodes. Shadow DOM in the returned DOM tree is flattened. \n\n##Types\n\n- [`DOMNode`](struct.DomNode.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  A Node in the DOM tree.\n- [`LayoutTreeNode`](struct.LayoutTreeNode.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Details of an element in the DOM tree with a LayoutObject.\n- [`ComputedStyle`](struct.ComputedStyle.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  A subset of the full ComputedStyle as defined by the request whitelist.\n- [`NameValue`](struct.NameValue.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  A name/value pair.\n"]
pub mod dom_snapshot {
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns a document snapshot, including the full DOM tree of the root node \\(including iframes, template contents, and imported documents\\) in a flattened array, as well as layout and white-listed computed style information for the nodes. Shadow DOM in the returned DOM tree is flattened. \n\n# Command `DOMSnapshot.getSnapshot`\n\n*Domain Module:* [`cdp::proto::dom_snapshot`](index.html)  \n*Command Struct:* [`cdp::proto::dom_snapshot::GetSnapshotCommand`](struct.GetSnapshotCommand.html)  \n*Response Struct:* [`cdp::proto::dom_snapshot::GetSnapshotResponse`](struct.GetSnapshotResponse.html)"]
    pub struct GetSnapshotCommand<'a> {
        #[serde(rename = "computedStyleWhitelist")]
        #[doc = "Whitelist of computed styles to return."]
        pub computed_style_whitelist: Vec<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::traits::SerializeCdpCommand for GetSnapshotCommand<'a> {
        fn command_name(&self) -> &str {
            "DOMSnapshot.getSnapshot"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for GetSnapshotCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOMSnapshot.getSnapshot" {
                Ok(
                    <GetSnapshotCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns a document snapshot, including the full DOM tree of the root node \\(including iframes, template contents, and imported documents\\) in a flattened array, as well as layout and white-listed computed style information for the nodes. Shadow DOM in the returned DOM tree is flattened. \n\n# Command `DOMSnapshot.getSnapshot`\n\n*Domain Module:* [`cdp::proto::dom_snapshot`](index.html)  \n*Command Struct:* [`cdp::proto::dom_snapshot::GetSnapshotCommand`](struct.GetSnapshotCommand.html)  \n*Response Struct:* [`cdp::proto::dom_snapshot::GetSnapshotResponse`](struct.GetSnapshotResponse.html)"]
    pub struct GetSnapshotResponse<'a> {
        #[serde(rename = "domNodes")]
        #[doc = "The nodes in the DOM tree. The DOMNode at index 0 corresponds to the root document."]
        pub dom_nodes: Vec<::proto::dom_snapshot::DomNode<'a>>,
        #[serde(rename = "layoutTreeNodes")]
        #[doc = "The nodes in the layout tree."]
        pub layout_tree_nodes: Vec<::proto::dom_snapshot::LayoutTreeNode<'a>>,
        #[serde(rename = "computedStyles")]
        #[doc = "Whitelisted ComputedStyle properties for each node in the layout tree."]
        pub computed_styles: Vec<::proto::dom_snapshot::ComputedStyle<'a>>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for GetSnapshotCommand<'a> {
        type Response = GetSnapshotResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for GetSnapshotResponse<'a> {
        type Command = GetSnapshotCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> A Node in the DOM tree."]
    pub struct DomNode<'a> {
        #[serde(rename = "nodeType")]
        #[doc = "<code>Node</code>'s nodeType."]
        pub node_type: i32,
        #[serde(rename = "nodeName")]
        #[doc = "<code>Node</code>'s nodeName."]
        pub node_name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "nodeValue")]
        #[doc = "<code>Node</code>'s nodeValue."]
        pub node_value: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "textValue", skip_serializing_if = "Option::is_none")]
        #[doc = "Only set for textarea elements, contains the text value."]
        pub text_value: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "inputValue", skip_serializing_if = "Option::is_none")]
        #[doc = "Only set for input elements, contains the input's associated text value."]
        pub input_value: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "inputChecked", skip_serializing_if = "Option::is_none")]
        #[doc = "Only set for radio and checkbox input elements, indicates if the element has been checked"]
        pub input_checked: Option<bool>,
        #[serde(rename = "optionSelected", skip_serializing_if = "Option::is_none")]
        #[doc = "Only set for option elements, indicates if the element has been selected"]
        pub option_selected: Option<bool>,
        #[serde(rename = "backendNodeId")]
        #[doc = "<code>Node</code>'s id, corresponds to DOM.Node.backendNodeId."]
        pub backend_node_id: ::proto::dom::BackendNodeId,
        #[serde(rename = "childNodeIndexes", skip_serializing_if = "Option::is_none")]
        #[doc = "The indexes of the node's child nodes in the <code>domNodes</code> array returned by <code>getSnapshot</code>, if any."]
        pub child_node_indexes: Option<Vec<i32>>,
        #[serde(rename = "attributes", skip_serializing_if = "Option::is_none")]
        #[doc = "Attributes of an <code>Element</code> node."]
        pub attributes: Option<Vec<::proto::dom_snapshot::NameValue<'a>>>,
        #[serde(rename = "pseudoElementIndexes", skip_serializing_if = "Option::is_none")]
        #[doc = "Indexes of pseudo elements associated with this node in the <code>domNodes</code> array returned by <code>getSnapshot</code>, if any."]
        pub pseudo_element_indexes: Option<Vec<i32>>,
        #[serde(rename = "layoutNodeIndex", skip_serializing_if = "Option::is_none")]
        #[doc = "The index of the node's related layout tree node in the <code>layoutTreeNodes</code> array returned by <code>getSnapshot</code>, if any."]
        pub layout_node_index: Option<i32>,
        #[serde(rename = "documentURL", skip_serializing_if = "Option::is_none")]
        #[doc = "Document URL that <code>Document</code> or <code>FrameOwner</code> node points to."]
        pub document_url: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "baseURL", skip_serializing_if = "Option::is_none")]
        #[doc = "Base URL that <code>Document</code> or <code>FrameOwner</code> node uses for URL completion."]
        pub base_url: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "contentLanguage", skip_serializing_if = "Option::is_none")]
        #[doc = "Only set for documents, contains the document's content language."]
        pub content_language: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "publicId", skip_serializing_if = "Option::is_none")]
        #[doc = "<code>DocumentType</code> node's publicId."]
        pub public_id: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "systemId", skip_serializing_if = "Option::is_none")]
        #[doc = "<code>DocumentType</code> node's systemId."]
        pub system_id: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "frameId", skip_serializing_if = "Option::is_none")]
        #[doc = "Frame ID for frame owner elements."]
        pub frame_id: Option<::proto::page::FrameId<'a>>,
        #[serde(rename = "contentDocumentIndex", skip_serializing_if = "Option::is_none")]
        #[doc = "The index of a frame owner element's content document in the <code>domNodes</code> array returned by <code>getSnapshot</code>, if any."]
        pub content_document_index: Option<i32>,
        #[serde(rename = "importedDocumentIndex", skip_serializing_if = "Option::is_none")]
        #[doc = "Index of the imported document's node of a link element in the <code>domNodes</code> array returned by <code>getSnapshot</code>, if any."]
        pub imported_document_index: Option<i32>,
        #[serde(rename = "templateContentIndex", skip_serializing_if = "Option::is_none")]
        #[doc = "Index of the content node of a template element in the <code>domNodes</code> array returned by <code>getSnapshot</code>."]
        pub template_content_index: Option<i32>,
        #[serde(rename = "pseudoType", skip_serializing_if = "Option::is_none")]
        #[doc = "Type of a pseudo element node."]
        pub pseudo_type: Option<::proto::dom::PseudoType>,
        #[serde(rename = "isClickable", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether this DOM node responds to mouse clicks. This includes nodes that have had click event listeners attached via JavaScript as well as anchor tags that naturally navigate when clicked."]
        pub is_clickable: Option<bool>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Details of an element in the DOM tree with a LayoutObject."]
    pub struct LayoutTreeNode<'a> {
        #[serde(rename = "domNodeIndex")]
        #[doc = "The index of the related DOM node in the <code>domNodes</code> array returned by <code>getSnapshot</code>."]
        pub dom_node_index: i32,
        #[serde(rename = "boundingBox")]
        #[doc = "The absolute position bounding box."]
        pub bounding_box: ::proto::dom::Rect,
        #[serde(rename = "layoutText", skip_serializing_if = "Option::is_none")]
        #[doc = "Contents of the LayoutText, if any."]
        pub layout_text: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "inlineTextNodes", skip_serializing_if = "Option::is_none")]
        #[doc = "The post-layout inline text nodes, if any."]
        pub inline_text_nodes: Option<Vec<::proto::css::InlineTextBox>>,
        #[serde(rename = "styleIndex", skip_serializing_if = "Option::is_none")]
        #[doc = "Index into the <code>computedStyles</code> array returned by <code>getSnapshot</code>."]
        pub style_index: Option<i32>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> A subset of the full ComputedStyle as defined by the request whitelist."]
    pub struct ComputedStyle<'a> {
        #[serde(rename = "properties")]
        #[doc = "Name/value pairs of computed style properties."]
        pub properties: Vec<::proto::dom_snapshot::NameValue<'a>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> A name/value pair."]
    pub struct NameValue<'a> {
        #[serde(rename = "name")]
        #[doc = "Attribute/property name."]
        pub name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "value")]
        #[doc = "Attribute/property value."]
        pub value: ::std::borrow::Cow<'a, str>,
    }
}
#[doc = "<span class=\"stab unstable\">[Experimental]</span> Input/Output operations for streams produced by DevTools.\n\n# IO\n\n## Commands\n\n- [`IO.read`](struct.ReadCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Read a chunk of the stream\n- [`IO.close`](struct.CloseCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Close the stream, discard any temporary backing storage.\n\n##Types\n\n- [`StreamHandle`](type.StreamHandle.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n"]
pub mod io {
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Read a chunk of the stream\n\n# Command `IO.read`\n\n*Domain Module:* [`cdp::proto::io`](index.html)  \n*Command Struct:* [`cdp::proto::io::ReadCommand`](struct.ReadCommand.html)  \n*Response Struct:* [`cdp::proto::io::ReadResponse`](struct.ReadResponse.html)"]
    pub struct ReadCommand<'a> {
        #[serde(rename = "handle")]
        #[doc = "Handle of the stream to read."]
        pub handle: ::proto::io::StreamHandle<'a>,
        #[serde(rename = "offset", skip_serializing_if = "Option::is_none")]
        #[doc = "Seek to the specified offset before reading \\(if not specificed, proceed with offset following the last read\\)."]
        pub offset: Option<i32>,
        #[serde(rename = "size", skip_serializing_if = "Option::is_none")]
        #[doc = "Maximum number of bytes to read \\(left upon the agent discretion if not specified\\)."]
        pub size: Option<i32>,
    }
    impl<'a> ::traits::SerializeCdpCommand for ReadCommand<'a> {
        fn command_name(&self) -> &str {
            "IO.read"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for ReadCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "IO.read" {
                Ok(
                    <ReadCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Read a chunk of the stream\n\n# Command `IO.read`\n\n*Domain Module:* [`cdp::proto::io`](index.html)  \n*Command Struct:* [`cdp::proto::io::ReadCommand`](struct.ReadCommand.html)  \n*Response Struct:* [`cdp::proto::io::ReadResponse`](struct.ReadResponse.html)"]
    pub struct ReadResponse<'a> {
        #[serde(rename = "data")]
        #[doc = "Data that were read."]
        pub data: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "eof")]
        #[doc = "Set if the end-of-file condition occured while reading."]
        pub eof: bool,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for ReadCommand<'a> {
        type Response = ReadResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for ReadResponse<'a> {
        type Command = ReadCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Close the stream, discard any temporary backing storage.\n\n# Command `IO.close`\n\n*Domain Module:* [`cdp::proto::io`](index.html)  \n*Command Struct:* [`cdp::proto::io::CloseCommand`](struct.CloseCommand.html)  \n*Response Struct:* [`cdp::proto::io::CloseResponse`](struct.CloseResponse.html)"]
    pub struct CloseCommand<'a> {
        #[serde(rename = "handle")]
        #[doc = "Handle of the stream to close."]
        pub handle: ::proto::io::StreamHandle<'a>,
    }
    impl<'a> ::traits::SerializeCdpCommand for CloseCommand<'a> {
        fn command_name(&self) -> &str {
            "IO.close"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for CloseCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "IO.close" {
                Ok(
                    <CloseCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Close the stream, discard any temporary backing storage.\n\n# Command `IO.close`\n\n*Domain Module:* [`cdp::proto::io`](index.html)  \n*Command Struct:* [`cdp::proto::io::CloseCommand`](struct.CloseCommand.html)  \n*Response Struct:* [`cdp::proto::io::CloseResponse`](struct.CloseResponse.html)"]
    pub struct CloseResponse;
    impl ::serde::Serialize for CloseResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CloseResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| CloseResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for CloseCommand<'a> {
        type Response = CloseResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for CloseResponse {
        type Command = CloseCommand<'a>;
    }
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>"]
    pub type StreamHandle<'a> = ::std::borrow::Cow<'a, str>;
}
#[doc = "DOM debugging allows setting breakpoints on particular DOM operations and events. JavaScript execution will stop on these operations as if there was a regular breakpoint set.\n\n# DOMDebugger\n\n## Commands\n\n- [`DOMDebugger.setDOMBreakpoint`](struct.SetDomBreakpointCommand.html)\n\n  Sets breakpoint on particular operation with DOM.\n- [`DOMDebugger.removeDOMBreakpoint`](struct.RemoveDomBreakpointCommand.html)\n\n  Removes DOM breakpoint that was set using <code>setDOMBreakpoint</code>.\n- [`DOMDebugger.setEventListenerBreakpoint`](struct.SetEventListenerBreakpointCommand.html)\n\n  Sets breakpoint on particular DOM event.\n- [`DOMDebugger.removeEventListenerBreakpoint`](struct.RemoveEventListenerBreakpointCommand.html)\n\n  Removes breakpoint on particular DOM event.\n- [`DOMDebugger.setInstrumentationBreakpoint`](struct.SetInstrumentationBreakpointCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Sets breakpoint on particular native event.\n- [`DOMDebugger.removeInstrumentationBreakpoint`](struct.RemoveInstrumentationBreakpointCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Removes breakpoint on particular native event.\n- [`DOMDebugger.setXHRBreakpoint`](struct.SetXhrBreakpointCommand.html)\n\n  Sets breakpoint on XMLHttpRequest.\n- [`DOMDebugger.removeXHRBreakpoint`](struct.RemoveXhrBreakpointCommand.html)\n\n  Removes breakpoint from XMLHttpRequest.\n- [`DOMDebugger.getEventListeners`](struct.GetEventListenersCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns event listeners of the given object.\n\n##Types\n\n- [`DOMBreakpointType`](enum.DomBreakpointType.html)\n\n  DOM breakpoint type.\n- [`EventListener`](struct.EventListener.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Object event listener.\n"]
pub mod dom_debugger {
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Sets breakpoint on particular operation with DOM.\n\n# Command `DOMDebugger.setDOMBreakpoint`\n\n*Domain Module:* [`cdp::proto::dom_debugger`](index.html)  \n*Command Struct:* [`cdp::proto::dom_debugger::SetDomBreakpointCommand`](struct.SetDomBreakpointCommand.html)  \n*Response Struct:* [`cdp::proto::dom_debugger::SetDomBreakpointResponse`](struct.SetDomBreakpointResponse.html)"]
    pub struct SetDomBreakpointCommand {
        #[serde(rename = "nodeId")]
        #[doc = "Identifier of the node to set breakpoint on."]
        pub node_id: ::proto::dom::NodeId,
        #[serde(rename = "type")]
        #[doc = "Type of the operation to stop upon."]
        pub ty: ::proto::dom_debugger::DomBreakpointType,
    }
    impl ::traits::SerializeCdpCommand for SetDomBreakpointCommand {
        fn command_name(&self) -> &str {
            "DOMDebugger.setDOMBreakpoint"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for SetDomBreakpointCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOMDebugger.setDOMBreakpoint" {
                Ok ( < SetDomBreakpointCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Sets breakpoint on particular operation with DOM.\n\n# Command `DOMDebugger.setDOMBreakpoint`\n\n*Domain Module:* [`cdp::proto::dom_debugger`](index.html)  \n*Command Struct:* [`cdp::proto::dom_debugger::SetDomBreakpointCommand`](struct.SetDomBreakpointCommand.html)  \n*Response Struct:* [`cdp::proto::dom_debugger::SetDomBreakpointResponse`](struct.SetDomBreakpointResponse.html)"]
    pub struct SetDomBreakpointResponse;
    impl ::serde::Serialize for SetDomBreakpointResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetDomBreakpointResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetDomBreakpointResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetDomBreakpointCommand {
        type Response = SetDomBreakpointResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetDomBreakpointResponse {
        type Command = SetDomBreakpointCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Removes DOM breakpoint that was set using <code>setDOMBreakpoint</code>.\n\n# Command `DOMDebugger.removeDOMBreakpoint`\n\n*Domain Module:* [`cdp::proto::dom_debugger`](index.html)  \n*Command Struct:* [`cdp::proto::dom_debugger::RemoveDomBreakpointCommand`](struct.RemoveDomBreakpointCommand.html)  \n*Response Struct:* [`cdp::proto::dom_debugger::RemoveDomBreakpointResponse`](struct.RemoveDomBreakpointResponse.html)"]
    pub struct RemoveDomBreakpointCommand {
        #[serde(rename = "nodeId")]
        #[doc = "Identifier of the node to remove breakpoint from."]
        pub node_id: ::proto::dom::NodeId,
        #[serde(rename = "type")]
        #[doc = "Type of the breakpoint to remove."]
        pub ty: ::proto::dom_debugger::DomBreakpointType,
    }
    impl ::traits::SerializeCdpCommand for RemoveDomBreakpointCommand {
        fn command_name(&self) -> &str {
            "DOMDebugger.removeDOMBreakpoint"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for RemoveDomBreakpointCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOMDebugger.removeDOMBreakpoint" {
                Ok ( < RemoveDomBreakpointCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Removes DOM breakpoint that was set using <code>setDOMBreakpoint</code>.\n\n# Command `DOMDebugger.removeDOMBreakpoint`\n\n*Domain Module:* [`cdp::proto::dom_debugger`](index.html)  \n*Command Struct:* [`cdp::proto::dom_debugger::RemoveDomBreakpointCommand`](struct.RemoveDomBreakpointCommand.html)  \n*Response Struct:* [`cdp::proto::dom_debugger::RemoveDomBreakpointResponse`](struct.RemoveDomBreakpointResponse.html)"]
    pub struct RemoveDomBreakpointResponse;
    impl ::serde::Serialize for RemoveDomBreakpointResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for RemoveDomBreakpointResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| RemoveDomBreakpointResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for RemoveDomBreakpointCommand {
        type Response = RemoveDomBreakpointResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for RemoveDomBreakpointResponse {
        type Command = RemoveDomBreakpointCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Sets breakpoint on particular DOM event.\n\n# Command `DOMDebugger.setEventListenerBreakpoint`\n\n*Domain Module:* [`cdp::proto::dom_debugger`](index.html)  \n*Command Struct:* [`cdp::proto::dom_debugger::SetEventListenerBreakpointCommand`](struct.SetEventListenerBreakpointCommand.html)  \n*Response Struct:* [`cdp::proto::dom_debugger::SetEventListenerBreakpointResponse`](struct.SetEventListenerBreakpointResponse.html)"]
    pub struct SetEventListenerBreakpointCommand<'a> {
        #[serde(rename = "eventName")]
        #[doc = "DOM Event name to stop on \\(any DOM event will do\\)."]
        pub event_name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "targetName", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> EventTarget interface name to stop on. If equal to <code>\"\\*\"</code> or not provided, will stop on any EventTarget."]
        pub target_name: Option<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::traits::SerializeCdpCommand for SetEventListenerBreakpointCommand<'a> {
        fn command_name(&self) -> &str {
            "DOMDebugger.setEventListenerBreakpoint"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for SetEventListenerBreakpointCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOMDebugger.setEventListenerBreakpoint" {
                Ok ( < SetEventListenerBreakpointCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Sets breakpoint on particular DOM event.\n\n# Command `DOMDebugger.setEventListenerBreakpoint`\n\n*Domain Module:* [`cdp::proto::dom_debugger`](index.html)  \n*Command Struct:* [`cdp::proto::dom_debugger::SetEventListenerBreakpointCommand`](struct.SetEventListenerBreakpointCommand.html)  \n*Response Struct:* [`cdp::proto::dom_debugger::SetEventListenerBreakpointResponse`](struct.SetEventListenerBreakpointResponse.html)"]
    pub struct SetEventListenerBreakpointResponse;
    impl ::serde::Serialize for SetEventListenerBreakpointResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetEventListenerBreakpointResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetEventListenerBreakpointResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetEventListenerBreakpointCommand<'a> {
        type Response = SetEventListenerBreakpointResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetEventListenerBreakpointResponse {
        type Command = SetEventListenerBreakpointCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Removes breakpoint on particular DOM event.\n\n# Command `DOMDebugger.removeEventListenerBreakpoint`\n\n*Domain Module:* [`cdp::proto::dom_debugger`](index.html)  \n*Command Struct:* [`cdp::proto::dom_debugger::RemoveEventListenerBreakpointCommand`](struct.RemoveEventListenerBreakpointCommand.html)  \n*Response Struct:* [`cdp::proto::dom_debugger::RemoveEventListenerBreakpointResponse`](struct.RemoveEventListenerBreakpointResponse.html)"]
    pub struct RemoveEventListenerBreakpointCommand<'a> {
        #[serde(rename = "eventName")]
        #[doc = "Event name."]
        pub event_name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "targetName", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> EventTarget interface name."]
        pub target_name: Option<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::traits::SerializeCdpCommand for RemoveEventListenerBreakpointCommand<'a> {
        fn command_name(&self) -> &str {
            "DOMDebugger.removeEventListenerBreakpoint"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for RemoveEventListenerBreakpointCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOMDebugger.removeEventListenerBreakpoint" {
                Ok ( < RemoveEventListenerBreakpointCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Removes breakpoint on particular DOM event.\n\n# Command `DOMDebugger.removeEventListenerBreakpoint`\n\n*Domain Module:* [`cdp::proto::dom_debugger`](index.html)  \n*Command Struct:* [`cdp::proto::dom_debugger::RemoveEventListenerBreakpointCommand`](struct.RemoveEventListenerBreakpointCommand.html)  \n*Response Struct:* [`cdp::proto::dom_debugger::RemoveEventListenerBreakpointResponse`](struct.RemoveEventListenerBreakpointResponse.html)"]
    pub struct RemoveEventListenerBreakpointResponse;
    impl ::serde::Serialize for RemoveEventListenerBreakpointResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for RemoveEventListenerBreakpointResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| RemoveEventListenerBreakpointResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for RemoveEventListenerBreakpointCommand<'a> {
        type Response = RemoveEventListenerBreakpointResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for RemoveEventListenerBreakpointResponse {
        type Command = RemoveEventListenerBreakpointCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Sets breakpoint on particular native event.\n\n# Command `DOMDebugger.setInstrumentationBreakpoint`\n\n*Domain Module:* [`cdp::proto::dom_debugger`](index.html)  \n*Command Struct:* [`cdp::proto::dom_debugger::SetInstrumentationBreakpointCommand`](struct.SetInstrumentationBreakpointCommand.html)  \n*Response Struct:* [`cdp::proto::dom_debugger::SetInstrumentationBreakpointResponse`](struct.SetInstrumentationBreakpointResponse.html)"]
    pub struct SetInstrumentationBreakpointCommand<'a> {
        #[serde(rename = "eventName")]
        #[doc = "Instrumentation name to stop on."]
        pub event_name: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpCommand for SetInstrumentationBreakpointCommand<'a> {
        fn command_name(&self) -> &str {
            "DOMDebugger.setInstrumentationBreakpoint"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for SetInstrumentationBreakpointCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOMDebugger.setInstrumentationBreakpoint" {
                Ok ( < SetInstrumentationBreakpointCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Sets breakpoint on particular native event.\n\n# Command `DOMDebugger.setInstrumentationBreakpoint`\n\n*Domain Module:* [`cdp::proto::dom_debugger`](index.html)  \n*Command Struct:* [`cdp::proto::dom_debugger::SetInstrumentationBreakpointCommand`](struct.SetInstrumentationBreakpointCommand.html)  \n*Response Struct:* [`cdp::proto::dom_debugger::SetInstrumentationBreakpointResponse`](struct.SetInstrumentationBreakpointResponse.html)"]
    pub struct SetInstrumentationBreakpointResponse;
    impl ::serde::Serialize for SetInstrumentationBreakpointResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetInstrumentationBreakpointResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetInstrumentationBreakpointResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetInstrumentationBreakpointCommand<'a> {
        type Response = SetInstrumentationBreakpointResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetInstrumentationBreakpointResponse {
        type Command = SetInstrumentationBreakpointCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Removes breakpoint on particular native event.\n\n# Command `DOMDebugger.removeInstrumentationBreakpoint`\n\n*Domain Module:* [`cdp::proto::dom_debugger`](index.html)  \n*Command Struct:* [`cdp::proto::dom_debugger::RemoveInstrumentationBreakpointCommand`](struct.RemoveInstrumentationBreakpointCommand.html)  \n*Response Struct:* [`cdp::proto::dom_debugger::RemoveInstrumentationBreakpointResponse`](struct.RemoveInstrumentationBreakpointResponse.html)"]
    pub struct RemoveInstrumentationBreakpointCommand<'a> {
        #[serde(rename = "eventName")]
        #[doc = "Instrumentation name to stop on."]
        pub event_name: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpCommand for RemoveInstrumentationBreakpointCommand<'a> {
        fn command_name(&self) -> &str {
            "DOMDebugger.removeInstrumentationBreakpoint"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for RemoveInstrumentationBreakpointCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOMDebugger.removeInstrumentationBreakpoint" {
                Ok ( < RemoveInstrumentationBreakpointCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Removes breakpoint on particular native event.\n\n# Command `DOMDebugger.removeInstrumentationBreakpoint`\n\n*Domain Module:* [`cdp::proto::dom_debugger`](index.html)  \n*Command Struct:* [`cdp::proto::dom_debugger::RemoveInstrumentationBreakpointCommand`](struct.RemoveInstrumentationBreakpointCommand.html)  \n*Response Struct:* [`cdp::proto::dom_debugger::RemoveInstrumentationBreakpointResponse`](struct.RemoveInstrumentationBreakpointResponse.html)"]
    pub struct RemoveInstrumentationBreakpointResponse;
    impl ::serde::Serialize for RemoveInstrumentationBreakpointResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for RemoveInstrumentationBreakpointResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| RemoveInstrumentationBreakpointResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for RemoveInstrumentationBreakpointCommand<'a> {
        type Response = RemoveInstrumentationBreakpointResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for RemoveInstrumentationBreakpointResponse {
        type Command = RemoveInstrumentationBreakpointCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Sets breakpoint on XMLHttpRequest.\n\n# Command `DOMDebugger.setXHRBreakpoint`\n\n*Domain Module:* [`cdp::proto::dom_debugger`](index.html)  \n*Command Struct:* [`cdp::proto::dom_debugger::SetXhrBreakpointCommand`](struct.SetXhrBreakpointCommand.html)  \n*Response Struct:* [`cdp::proto::dom_debugger::SetXhrBreakpointResponse`](struct.SetXhrBreakpointResponse.html)"]
    pub struct SetXhrBreakpointCommand<'a> {
        #[serde(rename = "url")]
        #[doc = "Resource URL substring. All XHRs having this substring in the URL will get stopped upon."]
        pub url: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpCommand for SetXhrBreakpointCommand<'a> {
        fn command_name(&self) -> &str {
            "DOMDebugger.setXHRBreakpoint"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for SetXhrBreakpointCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOMDebugger.setXHRBreakpoint" {
                Ok ( < SetXhrBreakpointCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Sets breakpoint on XMLHttpRequest.\n\n# Command `DOMDebugger.setXHRBreakpoint`\n\n*Domain Module:* [`cdp::proto::dom_debugger`](index.html)  \n*Command Struct:* [`cdp::proto::dom_debugger::SetXhrBreakpointCommand`](struct.SetXhrBreakpointCommand.html)  \n*Response Struct:* [`cdp::proto::dom_debugger::SetXhrBreakpointResponse`](struct.SetXhrBreakpointResponse.html)"]
    pub struct SetXhrBreakpointResponse;
    impl ::serde::Serialize for SetXhrBreakpointResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetXhrBreakpointResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetXhrBreakpointResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetXhrBreakpointCommand<'a> {
        type Response = SetXhrBreakpointResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetXhrBreakpointResponse {
        type Command = SetXhrBreakpointCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Removes breakpoint from XMLHttpRequest.\n\n# Command `DOMDebugger.removeXHRBreakpoint`\n\n*Domain Module:* [`cdp::proto::dom_debugger`](index.html)  \n*Command Struct:* [`cdp::proto::dom_debugger::RemoveXhrBreakpointCommand`](struct.RemoveXhrBreakpointCommand.html)  \n*Response Struct:* [`cdp::proto::dom_debugger::RemoveXhrBreakpointResponse`](struct.RemoveXhrBreakpointResponse.html)"]
    pub struct RemoveXhrBreakpointCommand<'a> {
        #[serde(rename = "url")]
        #[doc = "Resource URL substring."]
        pub url: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpCommand for RemoveXhrBreakpointCommand<'a> {
        fn command_name(&self) -> &str {
            "DOMDebugger.removeXHRBreakpoint"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for RemoveXhrBreakpointCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOMDebugger.removeXHRBreakpoint" {
                Ok ( < RemoveXhrBreakpointCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Removes breakpoint from XMLHttpRequest.\n\n# Command `DOMDebugger.removeXHRBreakpoint`\n\n*Domain Module:* [`cdp::proto::dom_debugger`](index.html)  \n*Command Struct:* [`cdp::proto::dom_debugger::RemoveXhrBreakpointCommand`](struct.RemoveXhrBreakpointCommand.html)  \n*Response Struct:* [`cdp::proto::dom_debugger::RemoveXhrBreakpointResponse`](struct.RemoveXhrBreakpointResponse.html)"]
    pub struct RemoveXhrBreakpointResponse;
    impl ::serde::Serialize for RemoveXhrBreakpointResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for RemoveXhrBreakpointResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| RemoveXhrBreakpointResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for RemoveXhrBreakpointCommand<'a> {
        type Response = RemoveXhrBreakpointResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for RemoveXhrBreakpointResponse {
        type Command = RemoveXhrBreakpointCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns event listeners of the given object.\n\n# Command `DOMDebugger.getEventListeners`\n\n*Domain Module:* [`cdp::proto::dom_debugger`](index.html)  \n*Command Struct:* [`cdp::proto::dom_debugger::GetEventListenersCommand`](struct.GetEventListenersCommand.html)  \n*Response Struct:* [`cdp::proto::dom_debugger::GetEventListenersResponse`](struct.GetEventListenersResponse.html)"]
    pub struct GetEventListenersCommand<'a> {
        #[serde(rename = "objectId")]
        #[doc = "Identifier of the object to return listeners for."]
        pub object_id: ::proto::runtime::RemoteObjectId<'a>,
        #[serde(rename = "depth", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> The maximum depth at which Node children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0."]
        pub depth: Option<i32>,
        #[serde(rename = "pierce", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Whether or not iframes and shadow roots should be traversed when returning the subtree \\(default is false\\). Reports listeners for all contexts if pierce is enabled."]
        pub pierce: Option<bool>,
    }
    impl<'a> ::traits::SerializeCdpCommand for GetEventListenersCommand<'a> {
        fn command_name(&self) -> &str {
            "DOMDebugger.getEventListeners"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for GetEventListenersCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOMDebugger.getEventListeners" {
                Ok ( < GetEventListenersCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns event listeners of the given object.\n\n# Command `DOMDebugger.getEventListeners`\n\n*Domain Module:* [`cdp::proto::dom_debugger`](index.html)  \n*Command Struct:* [`cdp::proto::dom_debugger::GetEventListenersCommand`](struct.GetEventListenersCommand.html)  \n*Response Struct:* [`cdp::proto::dom_debugger::GetEventListenersResponse`](struct.GetEventListenersResponse.html)"]
    pub struct GetEventListenersResponse<'a> {
        #[serde(rename = "listeners")]
        #[doc = "Array of relevant listeners."]
        pub listeners: Vec<::proto::dom_debugger::EventListener<'a>>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for GetEventListenersCommand<'a> {
        type Response = GetEventListenersResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for GetEventListenersResponse<'a> {
        type Command = GetEventListenersCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "DOM breakpoint type."]
    pub enum DomBreakpointType {
        #[serde(rename = "subtree-modified")]
        #[doc = "Represented as `\"subtree-modified\"`."]
        SubtreeModified,
        #[serde(rename = "attribute-modified")]
        #[doc = "Represented as `\"attribute-modified\"`."]
        AttributeModified,
        #[serde(rename = "node-removed")]
        #[doc = "Represented as `\"node-removed\"`."]
        NodeRemoved,
    }
    impl DomBreakpointType {
        pub const ENUM_VALUES: &'static [DomBreakpointType] = &[
            DomBreakpointType::SubtreeModified,
            DomBreakpointType::AttributeModified,
            DomBreakpointType::NodeRemoved,
        ];
        pub const STR_VALUES: &'static [&'static str] =
            &["subtree-modified", "attribute-modified", "node-removed"];
    }
    impl ::std::str::FromStr for DomBreakpointType {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "subtree-modified" => Ok(DomBreakpointType::SubtreeModified),
                "attribute-modified" => Ok(DomBreakpointType::AttributeModified),
                "node-removed" => Ok(DomBreakpointType::NodeRemoved),
                _ => Err(::proto::ParseEnumError {
                    expected: DomBreakpointType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for DomBreakpointType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    DomBreakpointType::SubtreeModified => "subtree-modified",
                    DomBreakpointType::AttributeModified => "attribute-modified",
                    DomBreakpointType::NodeRemoved => "node-removed",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Object event listener."]
    pub struct EventListener<'a> {
        #[serde(rename = "type")]
        #[doc = "<code>EventListener</code>'s type."]
        pub ty: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "useCapture")]
        #[doc = "<code>EventListener</code>'s useCapture."]
        pub use_capture: bool,
        #[serde(rename = "passive")]
        #[doc = "<code>EventListener</code>'s passive flag."]
        pub passive: bool,
        #[serde(rename = "once")]
        #[doc = "<code>EventListener</code>'s once flag."]
        pub once: bool,
        #[serde(rename = "scriptId")]
        #[doc = "Script id of the handler code."]
        pub script_id: ::proto::runtime::ScriptId<'a>,
        #[serde(rename = "lineNumber")]
        #[doc = "Line number in the script \\(0-based\\)."]
        pub line_number: i32,
        #[serde(rename = "columnNumber")]
        #[doc = "Column number in the script \\(0-based\\)."]
        pub column_number: i32,
        #[serde(rename = "handler", skip_serializing_if = "Option::is_none")]
        #[doc = "Event handler function value."]
        pub handler: Option<::proto::runtime::RemoteObject<'a>>,
        #[serde(rename = "originalHandler", skip_serializing_if = "Option::is_none")]
        #[doc = "Event original handler function value."]
        pub original_handler: Option<::proto::runtime::RemoteObject<'a>>,
        #[serde(rename = "backendNodeId", skip_serializing_if = "Option::is_none")]
        #[doc = "Node the listener is added to \\(if any\\)."]
        pub backend_node_id: Option<::proto::dom::BackendNodeId>,
    }
}
#[doc = "<span class=\"stab unstable\">[Experimental]</span> Supports additional targets discovery and allows to attach to them.\n\n# Target\n\n## Commands\n\n- [`Target.setDiscoverTargets`](struct.SetDiscoverTargetsCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Controls whether to discover available targets and notify via <code>targetCreated/targetInfoChanged/targetDestroyed</code> events.\n- [`Target.setAutoAttach`](struct.SetAutoAttachCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Controls whether to automatically attach to new targets which are considered to be related to this one. When turned on, attaches to all existing related targets as well. When turned off, automatically detaches from all currently attached targets.\n- [`Target.setAttachToFrames`](struct.SetAttachToFramesCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`Target.setRemoteLocations`](struct.SetRemoteLocationsCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Enables target discovery for the specified locations, when <code>setDiscoverTargets</code> was set to <code>true</code>.\n- [`Target.sendMessageToTarget`](struct.SendMessageToTargetCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Sends protocol message over session with given id.\n- [`Target.getTargetInfo`](struct.GetTargetInfoCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns information about a target.\n- [`Target.activateTarget`](struct.ActivateTargetCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Activates \\(focuses\\) the target.\n- [`Target.closeTarget`](struct.CloseTargetCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Closes the target. If the target is a page that gets closed too.\n- [`Target.attachToTarget`](struct.AttachToTargetCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Attaches to the target with given id.\n- [`Target.detachFromTarget`](struct.DetachFromTargetCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Detaches session with given id.\n- [`Target.createBrowserContext`](struct.CreateBrowserContextCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than one.\n- [`Target.disposeBrowserContext`](struct.DisposeBrowserContextCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Deletes a BrowserContext, will fail of any open page uses it.\n- [`Target.createTarget`](struct.CreateTargetCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Creates a new page.\n- [`Target.getTargets`](struct.GetTargetsCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Retrieves a list of available targets.\n\n## Events\n\n- [`Target.targetCreated`](struct.TargetCreatedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Issued when a possible inspection target is created.\n- [`Target.targetInfoChanged`](struct.TargetInfoChangedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Issued when some information about a target has changed. This only happens between <code>targetCreated</code> and <code>targetDestroyed</code>.\n- [`Target.targetDestroyed`](struct.TargetDestroyedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Issued when a target is destroyed.\n- [`Target.attachedToTarget`](struct.AttachedToTargetEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Issued when attached to target because of auto-attach or <code>attachToTarget</code> command.\n- [`Target.detachedFromTarget`](struct.DetachedFromTargetEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Issued when detached from target for any reason \\(including <code>detachFromTarget</code> command\\). Can be issued multiple times per target if multiple sessions have been attached to it.\n- [`Target.receivedMessageFromTarget`](struct.ReceivedMessageFromTargetEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Notifies about a new protocol message received from the session \\(as reported in <code>attachedToTarget</code> event\\).\n\n##Types\n\n- [`TargetID`](type.TargetId.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`SessionID`](type.SessionId.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Unique identifier of attached debugging session.\n- [`BrowserContextID`](type.BrowserContextId.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`TargetInfo`](struct.TargetInfo.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`RemoteLocation`](struct.RemoteLocation.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n"]
pub mod target {
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Controls whether to discover available targets and notify via <code>targetCreated/targetInfoChanged/targetDestroyed</code> events.\n\n# Command `Target.setDiscoverTargets`\n\n*Domain Module:* [`cdp::proto::target`](index.html)  \n*Command Struct:* [`cdp::proto::target::SetDiscoverTargetsCommand`](struct.SetDiscoverTargetsCommand.html)  \n*Response Struct:* [`cdp::proto::target::SetDiscoverTargetsResponse`](struct.SetDiscoverTargetsResponse.html)"]
    pub struct SetDiscoverTargetsCommand {
        #[serde(rename = "discover")]
        #[doc = "Whether to discover available targets."]
        pub discover: bool,
    }
    impl ::traits::SerializeCdpCommand for SetDiscoverTargetsCommand {
        fn command_name(&self) -> &str {
            "Target.setDiscoverTargets"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for SetDiscoverTargetsCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Target.setDiscoverTargets" {
                Ok ( < SetDiscoverTargetsCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Controls whether to discover available targets and notify via <code>targetCreated/targetInfoChanged/targetDestroyed</code> events.\n\n# Command `Target.setDiscoverTargets`\n\n*Domain Module:* [`cdp::proto::target`](index.html)  \n*Command Struct:* [`cdp::proto::target::SetDiscoverTargetsCommand`](struct.SetDiscoverTargetsCommand.html)  \n*Response Struct:* [`cdp::proto::target::SetDiscoverTargetsResponse`](struct.SetDiscoverTargetsResponse.html)"]
    pub struct SetDiscoverTargetsResponse;
    impl ::serde::Serialize for SetDiscoverTargetsResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetDiscoverTargetsResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetDiscoverTargetsResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetDiscoverTargetsCommand {
        type Response = SetDiscoverTargetsResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetDiscoverTargetsResponse {
        type Command = SetDiscoverTargetsCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Controls whether to automatically attach to new targets which are considered to be related to this one. When turned on, attaches to all existing related targets as well. When turned off, automatically detaches from all currently attached targets.\n\n# Command `Target.setAutoAttach`\n\n*Domain Module:* [`cdp::proto::target`](index.html)  \n*Command Struct:* [`cdp::proto::target::SetAutoAttachCommand`](struct.SetAutoAttachCommand.html)  \n*Response Struct:* [`cdp::proto::target::SetAutoAttachResponse`](struct.SetAutoAttachResponse.html)"]
    pub struct SetAutoAttachCommand {
        #[serde(rename = "autoAttach")]
        #[doc = "Whether to auto-attach to related targets."]
        pub auto_attach: bool,
        #[serde(rename = "waitForDebuggerOnStart")]
        #[doc = "Whether to pause new targets when attaching to them. Use <code>Runtime.runIfWaitingForDebugger</code> to run paused targets."]
        pub wait_for_debugger_on_start: bool,
    }
    impl ::traits::SerializeCdpCommand for SetAutoAttachCommand {
        fn command_name(&self) -> &str {
            "Target.setAutoAttach"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for SetAutoAttachCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Target.setAutoAttach" {
                Ok(
                    <SetAutoAttachCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Controls whether to automatically attach to new targets which are considered to be related to this one. When turned on, attaches to all existing related targets as well. When turned off, automatically detaches from all currently attached targets.\n\n# Command `Target.setAutoAttach`\n\n*Domain Module:* [`cdp::proto::target`](index.html)  \n*Command Struct:* [`cdp::proto::target::SetAutoAttachCommand`](struct.SetAutoAttachCommand.html)  \n*Response Struct:* [`cdp::proto::target::SetAutoAttachResponse`](struct.SetAutoAttachResponse.html)"]
    pub struct SetAutoAttachResponse;
    impl ::serde::Serialize for SetAutoAttachResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetAutoAttachResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetAutoAttachResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetAutoAttachCommand {
        type Response = SetAutoAttachResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetAutoAttachResponse {
        type Command = SetAutoAttachCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `Target.setAttachToFrames`\n\n*Domain Module:* [`cdp::proto::target`](index.html)  \n*Command Struct:* [`cdp::proto::target::SetAttachToFramesCommand`](struct.SetAttachToFramesCommand.html)  \n*Response Struct:* [`cdp::proto::target::SetAttachToFramesResponse`](struct.SetAttachToFramesResponse.html)"]
    pub struct SetAttachToFramesCommand {
        #[serde(rename = "value")]
        #[doc = "Whether to attach to frames."]
        pub value: bool,
    }
    impl ::traits::SerializeCdpCommand for SetAttachToFramesCommand {
        fn command_name(&self) -> &str {
            "Target.setAttachToFrames"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for SetAttachToFramesCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Target.setAttachToFrames" {
                Ok ( < SetAttachToFramesCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `Target.setAttachToFrames`\n\n*Domain Module:* [`cdp::proto::target`](index.html)  \n*Command Struct:* [`cdp::proto::target::SetAttachToFramesCommand`](struct.SetAttachToFramesCommand.html)  \n*Response Struct:* [`cdp::proto::target::SetAttachToFramesResponse`](struct.SetAttachToFramesResponse.html)"]
    pub struct SetAttachToFramesResponse;
    impl ::serde::Serialize for SetAttachToFramesResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetAttachToFramesResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetAttachToFramesResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetAttachToFramesCommand {
        type Response = SetAttachToFramesResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetAttachToFramesResponse {
        type Command = SetAttachToFramesCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables target discovery for the specified locations, when <code>setDiscoverTargets</code> was set to <code>true</code>.\n\n# Command `Target.setRemoteLocations`\n\n*Domain Module:* [`cdp::proto::target`](index.html)  \n*Command Struct:* [`cdp::proto::target::SetRemoteLocationsCommand`](struct.SetRemoteLocationsCommand.html)  \n*Response Struct:* [`cdp::proto::target::SetRemoteLocationsResponse`](struct.SetRemoteLocationsResponse.html)"]
    pub struct SetRemoteLocationsCommand<'a> {
        #[serde(rename = "locations")]
        #[doc = "List of remote locations."]
        pub locations: Vec<::proto::target::RemoteLocation<'a>>,
    }
    impl<'a> ::traits::SerializeCdpCommand for SetRemoteLocationsCommand<'a> {
        fn command_name(&self) -> &str {
            "Target.setRemoteLocations"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for SetRemoteLocationsCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Target.setRemoteLocations" {
                Ok ( < SetRemoteLocationsCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables target discovery for the specified locations, when <code>setDiscoverTargets</code> was set to <code>true</code>.\n\n# Command `Target.setRemoteLocations`\n\n*Domain Module:* [`cdp::proto::target`](index.html)  \n*Command Struct:* [`cdp::proto::target::SetRemoteLocationsCommand`](struct.SetRemoteLocationsCommand.html)  \n*Response Struct:* [`cdp::proto::target::SetRemoteLocationsResponse`](struct.SetRemoteLocationsResponse.html)"]
    pub struct SetRemoteLocationsResponse;
    impl ::serde::Serialize for SetRemoteLocationsResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetRemoteLocationsResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetRemoteLocationsResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetRemoteLocationsCommand<'a> {
        type Response = SetRemoteLocationsResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetRemoteLocationsResponse {
        type Command = SetRemoteLocationsCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Sends protocol message over session with given id.\n\n# Command `Target.sendMessageToTarget`\n\n*Domain Module:* [`cdp::proto::target`](index.html)  \n*Command Struct:* [`cdp::proto::target::SendMessageToTargetCommand`](struct.SendMessageToTargetCommand.html)  \n*Response Struct:* [`cdp::proto::target::SendMessageToTargetResponse`](struct.SendMessageToTargetResponse.html)"]
    pub struct SendMessageToTargetCommand<'a> {
        #[serde(rename = "message")]
        pub message: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "sessionId", skip_serializing_if = "Option::is_none")]
        #[doc = "Identifier of the session."]
        pub session_id: Option<::proto::target::SessionId<'a>>,
        #[serde(rename = "targetId", skip_serializing_if = "Option::is_none")]
        #[doc = "Deprecated."]
        #[deprecated]
        pub target_id: Option<::proto::target::TargetId<'a>>,
    }
    impl<'a> ::traits::SerializeCdpCommand for SendMessageToTargetCommand<'a> {
        fn command_name(&self) -> &str {
            "Target.sendMessageToTarget"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for SendMessageToTargetCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Target.sendMessageToTarget" {
                Ok ( < SendMessageToTargetCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Sends protocol message over session with given id.\n\n# Command `Target.sendMessageToTarget`\n\n*Domain Module:* [`cdp::proto::target`](index.html)  \n*Command Struct:* [`cdp::proto::target::SendMessageToTargetCommand`](struct.SendMessageToTargetCommand.html)  \n*Response Struct:* [`cdp::proto::target::SendMessageToTargetResponse`](struct.SendMessageToTargetResponse.html)"]
    pub struct SendMessageToTargetResponse;
    impl ::serde::Serialize for SendMessageToTargetResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SendMessageToTargetResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SendMessageToTargetResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SendMessageToTargetCommand<'a> {
        type Response = SendMessageToTargetResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SendMessageToTargetResponse {
        type Command = SendMessageToTargetCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns information about a target.\n\n# Command `Target.getTargetInfo`\n\n*Domain Module:* [`cdp::proto::target`](index.html)  \n*Command Struct:* [`cdp::proto::target::GetTargetInfoCommand`](struct.GetTargetInfoCommand.html)  \n*Response Struct:* [`cdp::proto::target::GetTargetInfoResponse`](struct.GetTargetInfoResponse.html)"]
    pub struct GetTargetInfoCommand<'a> {
        #[serde(rename = "targetId")]
        pub target_id: ::proto::target::TargetId<'a>,
    }
    impl<'a> ::traits::SerializeCdpCommand for GetTargetInfoCommand<'a> {
        fn command_name(&self) -> &str {
            "Target.getTargetInfo"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for GetTargetInfoCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Target.getTargetInfo" {
                Ok(
                    <GetTargetInfoCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns information about a target.\n\n# Command `Target.getTargetInfo`\n\n*Domain Module:* [`cdp::proto::target`](index.html)  \n*Command Struct:* [`cdp::proto::target::GetTargetInfoCommand`](struct.GetTargetInfoCommand.html)  \n*Response Struct:* [`cdp::proto::target::GetTargetInfoResponse`](struct.GetTargetInfoResponse.html)"]
    pub struct GetTargetInfoResponse<'a> {
        #[serde(rename = "targetInfo")]
        pub target_info: ::proto::target::TargetInfo<'a>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for GetTargetInfoCommand<'a> {
        type Response = GetTargetInfoResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for GetTargetInfoResponse<'a> {
        type Command = GetTargetInfoCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Activates \\(focuses\\) the target.\n\n# Command `Target.activateTarget`\n\n*Domain Module:* [`cdp::proto::target`](index.html)  \n*Command Struct:* [`cdp::proto::target::ActivateTargetCommand`](struct.ActivateTargetCommand.html)  \n*Response Struct:* [`cdp::proto::target::ActivateTargetResponse`](struct.ActivateTargetResponse.html)"]
    pub struct ActivateTargetCommand<'a> {
        #[serde(rename = "targetId")]
        pub target_id: ::proto::target::TargetId<'a>,
    }
    impl<'a> ::traits::SerializeCdpCommand for ActivateTargetCommand<'a> {
        fn command_name(&self) -> &str {
            "Target.activateTarget"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for ActivateTargetCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Target.activateTarget" {
                Ok(
                    <ActivateTargetCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Activates \\(focuses\\) the target.\n\n# Command `Target.activateTarget`\n\n*Domain Module:* [`cdp::proto::target`](index.html)  \n*Command Struct:* [`cdp::proto::target::ActivateTargetCommand`](struct.ActivateTargetCommand.html)  \n*Response Struct:* [`cdp::proto::target::ActivateTargetResponse`](struct.ActivateTargetResponse.html)"]
    pub struct ActivateTargetResponse;
    impl ::serde::Serialize for ActivateTargetResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ActivateTargetResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ActivateTargetResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for ActivateTargetCommand<'a> {
        type Response = ActivateTargetResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for ActivateTargetResponse {
        type Command = ActivateTargetCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Closes the target. If the target is a page that gets closed too.\n\n# Command `Target.closeTarget`\n\n*Domain Module:* [`cdp::proto::target`](index.html)  \n*Command Struct:* [`cdp::proto::target::CloseTargetCommand`](struct.CloseTargetCommand.html)  \n*Response Struct:* [`cdp::proto::target::CloseTargetResponse`](struct.CloseTargetResponse.html)"]
    pub struct CloseTargetCommand<'a> {
        #[serde(rename = "targetId")]
        pub target_id: ::proto::target::TargetId<'a>,
    }
    impl<'a> ::traits::SerializeCdpCommand for CloseTargetCommand<'a> {
        fn command_name(&self) -> &str {
            "Target.closeTarget"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for CloseTargetCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Target.closeTarget" {
                Ok(
                    <CloseTargetCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Closes the target. If the target is a page that gets closed too.\n\n# Command `Target.closeTarget`\n\n*Domain Module:* [`cdp::proto::target`](index.html)  \n*Command Struct:* [`cdp::proto::target::CloseTargetCommand`](struct.CloseTargetCommand.html)  \n*Response Struct:* [`cdp::proto::target::CloseTargetResponse`](struct.CloseTargetResponse.html)"]
    pub struct CloseTargetResponse {
        #[serde(rename = "success")]
        pub success: bool,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for CloseTargetCommand<'a> {
        type Response = CloseTargetResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for CloseTargetResponse {
        type Command = CloseTargetCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Attaches to the target with given id.\n\n# Command `Target.attachToTarget`\n\n*Domain Module:* [`cdp::proto::target`](index.html)  \n*Command Struct:* [`cdp::proto::target::AttachToTargetCommand`](struct.AttachToTargetCommand.html)  \n*Response Struct:* [`cdp::proto::target::AttachToTargetResponse`](struct.AttachToTargetResponse.html)"]
    pub struct AttachToTargetCommand<'a> {
        #[serde(rename = "targetId")]
        pub target_id: ::proto::target::TargetId<'a>,
    }
    impl<'a> ::traits::SerializeCdpCommand for AttachToTargetCommand<'a> {
        fn command_name(&self) -> &str {
            "Target.attachToTarget"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for AttachToTargetCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Target.attachToTarget" {
                Ok(
                    <AttachToTargetCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Attaches to the target with given id.\n\n# Command `Target.attachToTarget`\n\n*Domain Module:* [`cdp::proto::target`](index.html)  \n*Command Struct:* [`cdp::proto::target::AttachToTargetCommand`](struct.AttachToTargetCommand.html)  \n*Response Struct:* [`cdp::proto::target::AttachToTargetResponse`](struct.AttachToTargetResponse.html)"]
    pub struct AttachToTargetResponse<'a> {
        #[serde(rename = "sessionId")]
        #[doc = "Id assigned to the session."]
        pub session_id: ::proto::target::SessionId<'a>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for AttachToTargetCommand<'a> {
        type Response = AttachToTargetResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for AttachToTargetResponse<'a> {
        type Command = AttachToTargetCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Detaches session with given id.\n\n# Command `Target.detachFromTarget`\n\n*Domain Module:* [`cdp::proto::target`](index.html)  \n*Command Struct:* [`cdp::proto::target::DetachFromTargetCommand`](struct.DetachFromTargetCommand.html)  \n*Response Struct:* [`cdp::proto::target::DetachFromTargetResponse`](struct.DetachFromTargetResponse.html)"]
    pub struct DetachFromTargetCommand<'a> {
        #[serde(rename = "sessionId", skip_serializing_if = "Option::is_none")]
        #[doc = "Session to detach."]
        pub session_id: Option<::proto::target::SessionId<'a>>,
        #[serde(rename = "targetId", skip_serializing_if = "Option::is_none")]
        #[doc = "Deprecated."]
        #[deprecated]
        pub target_id: Option<::proto::target::TargetId<'a>>,
    }
    impl<'a> ::traits::SerializeCdpCommand for DetachFromTargetCommand<'a> {
        fn command_name(&self) -> &str {
            "Target.detachFromTarget"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for DetachFromTargetCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Target.detachFromTarget" {
                Ok ( < DetachFromTargetCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Detaches session with given id.\n\n# Command `Target.detachFromTarget`\n\n*Domain Module:* [`cdp::proto::target`](index.html)  \n*Command Struct:* [`cdp::proto::target::DetachFromTargetCommand`](struct.DetachFromTargetCommand.html)  \n*Response Struct:* [`cdp::proto::target::DetachFromTargetResponse`](struct.DetachFromTargetResponse.html)"]
    pub struct DetachFromTargetResponse;
    impl ::serde::Serialize for DetachFromTargetResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DetachFromTargetResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DetachFromTargetResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for DetachFromTargetCommand<'a> {
        type Response = DetachFromTargetResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for DetachFromTargetResponse {
        type Command = DetachFromTargetCommand<'a>;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than one.\n\n# Command `Target.createBrowserContext`\n\n*Domain Module:* [`cdp::proto::target`](index.html)  \n*Command Struct:* [`cdp::proto::target::CreateBrowserContextCommand`](struct.CreateBrowserContextCommand.html)  \n*Response Struct:* [`cdp::proto::target::CreateBrowserContextResponse`](struct.CreateBrowserContextResponse.html)"]
    pub struct CreateBrowserContextCommand;
    impl ::serde::Serialize for CreateBrowserContextCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CreateBrowserContextCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| CreateBrowserContextCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for CreateBrowserContextCommand {
        fn command_name(&self) -> &str {
            "Target.createBrowserContext"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for CreateBrowserContextCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Target.createBrowserContext" {
                Ok ( < CreateBrowserContextCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than one.\n\n# Command `Target.createBrowserContext`\n\n*Domain Module:* [`cdp::proto::target`](index.html)  \n*Command Struct:* [`cdp::proto::target::CreateBrowserContextCommand`](struct.CreateBrowserContextCommand.html)  \n*Response Struct:* [`cdp::proto::target::CreateBrowserContextResponse`](struct.CreateBrowserContextResponse.html)"]
    pub struct CreateBrowserContextResponse<'a> {
        #[serde(rename = "browserContextId")]
        #[doc = "The id of the context created."]
        pub browser_context_id: ::proto::target::BrowserContextId<'a>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for CreateBrowserContextCommand {
        type Response = CreateBrowserContextResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for CreateBrowserContextResponse<'a> {
        type Command = CreateBrowserContextCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Deletes a BrowserContext, will fail of any open page uses it.\n\n# Command `Target.disposeBrowserContext`\n\n*Domain Module:* [`cdp::proto::target`](index.html)  \n*Command Struct:* [`cdp::proto::target::DisposeBrowserContextCommand`](struct.DisposeBrowserContextCommand.html)  \n*Response Struct:* [`cdp::proto::target::DisposeBrowserContextResponse`](struct.DisposeBrowserContextResponse.html)"]
    pub struct DisposeBrowserContextCommand<'a> {
        #[serde(rename = "browserContextId")]
        pub browser_context_id: ::proto::target::BrowserContextId<'a>,
    }
    impl<'a> ::traits::SerializeCdpCommand for DisposeBrowserContextCommand<'a> {
        fn command_name(&self) -> &str {
            "Target.disposeBrowserContext"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for DisposeBrowserContextCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Target.disposeBrowserContext" {
                Ok ( < DisposeBrowserContextCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Deletes a BrowserContext, will fail of any open page uses it.\n\n# Command `Target.disposeBrowserContext`\n\n*Domain Module:* [`cdp::proto::target`](index.html)  \n*Command Struct:* [`cdp::proto::target::DisposeBrowserContextCommand`](struct.DisposeBrowserContextCommand.html)  \n*Response Struct:* [`cdp::proto::target::DisposeBrowserContextResponse`](struct.DisposeBrowserContextResponse.html)"]
    pub struct DisposeBrowserContextResponse {
        #[serde(rename = "success")]
        pub success: bool,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for DisposeBrowserContextCommand<'a> {
        type Response = DisposeBrowserContextResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for DisposeBrowserContextResponse {
        type Command = DisposeBrowserContextCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Creates a new page.\n\n# Command `Target.createTarget`\n\n*Domain Module:* [`cdp::proto::target`](index.html)  \n*Command Struct:* [`cdp::proto::target::CreateTargetCommand`](struct.CreateTargetCommand.html)  \n*Response Struct:* [`cdp::proto::target::CreateTargetResponse`](struct.CreateTargetResponse.html)"]
    pub struct CreateTargetCommand<'a> {
        #[serde(rename = "url")]
        #[doc = "The initial URL the page will be navigated to."]
        pub url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "width", skip_serializing_if = "Option::is_none")]
        #[doc = "Frame width in DIP \\(headless chrome only\\)."]
        pub width: Option<i32>,
        #[serde(rename = "height", skip_serializing_if = "Option::is_none")]
        #[doc = "Frame height in DIP \\(headless chrome only\\)."]
        pub height: Option<i32>,
        #[serde(rename = "browserContextId", skip_serializing_if = "Option::is_none")]
        #[doc = "The browser context to create the page in \\(headless chrome only\\)."]
        pub browser_context_id: Option<::proto::target::BrowserContextId<'a>>,
    }
    impl<'a> ::traits::SerializeCdpCommand for CreateTargetCommand<'a> {
        fn command_name(&self) -> &str {
            "Target.createTarget"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for CreateTargetCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Target.createTarget" {
                Ok(
                    <CreateTargetCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Creates a new page.\n\n# Command `Target.createTarget`\n\n*Domain Module:* [`cdp::proto::target`](index.html)  \n*Command Struct:* [`cdp::proto::target::CreateTargetCommand`](struct.CreateTargetCommand.html)  \n*Response Struct:* [`cdp::proto::target::CreateTargetResponse`](struct.CreateTargetResponse.html)"]
    pub struct CreateTargetResponse<'a> {
        #[serde(rename = "targetId")]
        #[doc = "The id of the page opened."]
        pub target_id: ::proto::target::TargetId<'a>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for CreateTargetCommand<'a> {
        type Response = CreateTargetResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for CreateTargetResponse<'a> {
        type Command = CreateTargetCommand<'a>;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Retrieves a list of available targets.\n\n# Command `Target.getTargets`\n\n*Domain Module:* [`cdp::proto::target`](index.html)  \n*Command Struct:* [`cdp::proto::target::GetTargetsCommand`](struct.GetTargetsCommand.html)  \n*Response Struct:* [`cdp::proto::target::GetTargetsResponse`](struct.GetTargetsResponse.html)"]
    pub struct GetTargetsCommand;
    impl ::serde::Serialize for GetTargetsCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetTargetsCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| GetTargetsCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for GetTargetsCommand {
        fn command_name(&self) -> &str {
            "Target.getTargets"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for GetTargetsCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Target.getTargets" {
                Ok(
                    <GetTargetsCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Retrieves a list of available targets.\n\n# Command `Target.getTargets`\n\n*Domain Module:* [`cdp::proto::target`](index.html)  \n*Command Struct:* [`cdp::proto::target::GetTargetsCommand`](struct.GetTargetsCommand.html)  \n*Response Struct:* [`cdp::proto::target::GetTargetsResponse`](struct.GetTargetsResponse.html)"]
    pub struct GetTargetsResponse<'a> {
        #[serde(rename = "targetInfos")]
        #[doc = "The list of targets."]
        pub target_infos: Vec<::proto::target::TargetInfo<'a>>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for GetTargetsCommand {
        type Response = GetTargetsResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for GetTargetsResponse<'a> {
        type Command = GetTargetsCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Issued when a possible inspection target is created.\n\n# Event `Target.targetCreated`\n\n*Domain Module:* [`cdp::proto::target`](index.html)  \n*Event Struct:* [`cdp::proto::target::TargetCreatedEvent`](struct.TargetCreatedEvent.html)"]
    pub struct TargetCreatedEvent<'a> {
        #[serde(rename = "targetInfo")]
        pub target_info: ::proto::target::TargetInfo<'a>,
    }
    impl<'a> ::traits::SerializeCdpEvent for TargetCreatedEvent<'a> {
        fn event_name(&self) -> &str {
            "Target.targetCreated"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for TargetCreatedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Target.targetCreated" {
                Ok(
                    <TargetCreatedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Issued when some information about a target has changed. This only happens between <code>targetCreated</code> and <code>targetDestroyed</code>.\n\n# Event `Target.targetInfoChanged`\n\n*Domain Module:* [`cdp::proto::target`](index.html)  \n*Event Struct:* [`cdp::proto::target::TargetInfoChangedEvent`](struct.TargetInfoChangedEvent.html)"]
    pub struct TargetInfoChangedEvent<'a> {
        #[serde(rename = "targetInfo")]
        pub target_info: ::proto::target::TargetInfo<'a>,
    }
    impl<'a> ::traits::SerializeCdpEvent for TargetInfoChangedEvent<'a> {
        fn event_name(&self) -> &str {
            "Target.targetInfoChanged"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for TargetInfoChangedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Target.targetInfoChanged" {
                Ok(
                    <TargetInfoChangedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Issued when a target is destroyed.\n\n# Event `Target.targetDestroyed`\n\n*Domain Module:* [`cdp::proto::target`](index.html)  \n*Event Struct:* [`cdp::proto::target::TargetDestroyedEvent`](struct.TargetDestroyedEvent.html)"]
    pub struct TargetDestroyedEvent<'a> {
        #[serde(rename = "targetId")]
        pub target_id: ::proto::target::TargetId<'a>,
    }
    impl<'a> ::traits::SerializeCdpEvent for TargetDestroyedEvent<'a> {
        fn event_name(&self) -> &str {
            "Target.targetDestroyed"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for TargetDestroyedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Target.targetDestroyed" {
                Ok(
                    <TargetDestroyedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Issued when attached to target because of auto-attach or <code>attachToTarget</code> command.\n\n# Event `Target.attachedToTarget`\n\n*Domain Module:* [`cdp::proto::target`](index.html)  \n*Event Struct:* [`cdp::proto::target::AttachedToTargetEvent`](struct.AttachedToTargetEvent.html)"]
    pub struct AttachedToTargetEvent<'a> {
        #[serde(rename = "sessionId")]
        #[doc = "Identifier assigned to the session used to send/receive messages."]
        pub session_id: ::proto::target::SessionId<'a>,
        #[serde(rename = "targetInfo")]
        pub target_info: ::proto::target::TargetInfo<'a>,
        #[serde(rename = "waitingForDebugger")]
        pub waiting_for_debugger: bool,
    }
    impl<'a> ::traits::SerializeCdpEvent for AttachedToTargetEvent<'a> {
        fn event_name(&self) -> &str {
            "Target.attachedToTarget"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for AttachedToTargetEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Target.attachedToTarget" {
                Ok(
                    <AttachedToTargetEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Issued when detached from target for any reason \\(including <code>detachFromTarget</code> command\\). Can be issued multiple times per target if multiple sessions have been attached to it.\n\n# Event `Target.detachedFromTarget`\n\n*Domain Module:* [`cdp::proto::target`](index.html)  \n*Event Struct:* [`cdp::proto::target::DetachedFromTargetEvent`](struct.DetachedFromTargetEvent.html)"]
    pub struct DetachedFromTargetEvent<'a> {
        #[serde(rename = "sessionId")]
        #[doc = "Detached session identifier."]
        pub session_id: ::proto::target::SessionId<'a>,
        #[serde(rename = "targetId", skip_serializing_if = "Option::is_none")]
        #[doc = "Deprecated."]
        #[deprecated]
        pub target_id: Option<::proto::target::TargetId<'a>>,
    }
    impl<'a> ::traits::SerializeCdpEvent for DetachedFromTargetEvent<'a> {
        fn event_name(&self) -> &str {
            "Target.detachedFromTarget"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for DetachedFromTargetEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Target.detachedFromTarget" {
                Ok ( < DetachedFromTargetEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Notifies about a new protocol message received from the session \\(as reported in <code>attachedToTarget</code> event\\).\n\n# Event `Target.receivedMessageFromTarget`\n\n*Domain Module:* [`cdp::proto::target`](index.html)  \n*Event Struct:* [`cdp::proto::target::ReceivedMessageFromTargetEvent`](struct.ReceivedMessageFromTargetEvent.html)"]
    pub struct ReceivedMessageFromTargetEvent<'a> {
        #[serde(rename = "sessionId")]
        #[doc = "Identifier of a session which sends a message."]
        pub session_id: ::proto::target::SessionId<'a>,
        #[serde(rename = "message")]
        pub message: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "targetId", skip_serializing_if = "Option::is_none")]
        #[doc = "Deprecated."]
        #[deprecated]
        pub target_id: Option<::proto::target::TargetId<'a>>,
    }
    impl<'a> ::traits::SerializeCdpEvent for ReceivedMessageFromTargetEvent<'a> {
        fn event_name(&self) -> &str {
            "Target.receivedMessageFromTarget"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for ReceivedMessageFromTargetEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Target.receivedMessageFromTarget" {
                Ok ( < ReceivedMessageFromTargetEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>"]
    pub type TargetId<'a> = ::std::borrow::Cow<'a, str>;
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Unique identifier of attached debugging session."]
    pub type SessionId<'a> = ::std::borrow::Cow<'a, str>;
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>"]
    pub type BrowserContextId<'a> = ::std::borrow::Cow<'a, str>;
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>"]
    pub struct TargetInfo<'a> {
        #[serde(rename = "targetId")]
        pub target_id: ::proto::target::TargetId<'a>,
        #[serde(rename = "type")]
        pub ty: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "title")]
        pub title: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "url")]
        pub url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "attached")]
        #[doc = "Whether the target has an attached client."]
        pub attached: bool,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>"]
    pub struct RemoteLocation<'a> {
        #[serde(rename = "host")]
        pub host: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "port")]
        pub port: i32,
    }
}
#[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# ServiceWorker\n\n## Commands\n\n- [`ServiceWorker.enable`](struct.EnableCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`ServiceWorker.disable`](struct.DisableCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`ServiceWorker.unregister`](struct.UnregisterCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`ServiceWorker.updateRegistration`](struct.UpdateRegistrationCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`ServiceWorker.startWorker`](struct.StartWorkerCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`ServiceWorker.skipWaiting`](struct.SkipWaitingCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`ServiceWorker.stopWorker`](struct.StopWorkerCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`ServiceWorker.inspectWorker`](struct.InspectWorkerCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`ServiceWorker.setForceUpdateOnPageLoad`](struct.SetForceUpdateOnPageLoadCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`ServiceWorker.deliverPushMessage`](struct.DeliverPushMessageCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`ServiceWorker.dispatchSyncEvent`](struct.DispatchSyncEventCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n## Events\n\n- [`ServiceWorker.workerRegistrationUpdated`](struct.WorkerRegistrationUpdatedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`ServiceWorker.workerVersionUpdated`](struct.WorkerVersionUpdatedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`ServiceWorker.workerErrorReported`](struct.WorkerErrorReportedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n##Types\n\n- [`ServiceWorkerRegistration`](struct.ServiceWorkerRegistration.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  ServiceWorker registration.\n- [`ServiceWorkerVersionRunningStatus`](enum.ServiceWorkerVersionRunningStatus.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`ServiceWorkerVersionStatus`](enum.ServiceWorkerVersionStatus.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`ServiceWorkerVersion`](struct.ServiceWorkerVersion.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  ServiceWorker version.\n- [`ServiceWorkerErrorMessage`](struct.ServiceWorkerErrorMessage.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  ServiceWorker error message.\n"]
pub mod service_worker {
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `ServiceWorker.enable`\n\n*Domain Module:* [`cdp::proto::service_worker`](index.html)  \n*Command Struct:* [`cdp::proto::service_worker::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::proto::service_worker::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableCommand;
    impl ::serde::Serialize for EnableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for EnableCommand {
        fn command_name(&self) -> &str {
            "ServiceWorker.enable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for EnableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "ServiceWorker.enable" {
                Ok(
                    <EnableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `ServiceWorker.enable`\n\n*Domain Module:* [`cdp::proto::service_worker`](index.html)  \n*Command Struct:* [`cdp::proto::service_worker::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::proto::service_worker::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableResponse;
    impl ::serde::Serialize for EnableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for EnableCommand {
        type Response = EnableResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for EnableResponse {
        type Command = EnableCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `ServiceWorker.disable`\n\n*Domain Module:* [`cdp::proto::service_worker`](index.html)  \n*Command Struct:* [`cdp::proto::service_worker::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::proto::service_worker::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableCommand;
    impl ::serde::Serialize for DisableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for DisableCommand {
        fn command_name(&self) -> &str {
            "ServiceWorker.disable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for DisableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "ServiceWorker.disable" {
                Ok(
                    <DisableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `ServiceWorker.disable`\n\n*Domain Module:* [`cdp::proto::service_worker`](index.html)  \n*Command Struct:* [`cdp::proto::service_worker::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::proto::service_worker::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableResponse;
    impl ::serde::Serialize for DisableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for DisableCommand {
        type Response = DisableResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for DisableResponse {
        type Command = DisableCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `ServiceWorker.unregister`\n\n*Domain Module:* [`cdp::proto::service_worker`](index.html)  \n*Command Struct:* [`cdp::proto::service_worker::UnregisterCommand`](struct.UnregisterCommand.html)  \n*Response Struct:* [`cdp::proto::service_worker::UnregisterResponse`](struct.UnregisterResponse.html)"]
    pub struct UnregisterCommand<'a> {
        #[serde(rename = "scopeURL")]
        pub scope_url: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpCommand for UnregisterCommand<'a> {
        fn command_name(&self) -> &str {
            "ServiceWorker.unregister"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for UnregisterCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "ServiceWorker.unregister" {
                Ok(
                    <UnregisterCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `ServiceWorker.unregister`\n\n*Domain Module:* [`cdp::proto::service_worker`](index.html)  \n*Command Struct:* [`cdp::proto::service_worker::UnregisterCommand`](struct.UnregisterCommand.html)  \n*Response Struct:* [`cdp::proto::service_worker::UnregisterResponse`](struct.UnregisterResponse.html)"]
    pub struct UnregisterResponse;
    impl ::serde::Serialize for UnregisterResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for UnregisterResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| UnregisterResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for UnregisterCommand<'a> {
        type Response = UnregisterResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for UnregisterResponse {
        type Command = UnregisterCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `ServiceWorker.updateRegistration`\n\n*Domain Module:* [`cdp::proto::service_worker`](index.html)  \n*Command Struct:* [`cdp::proto::service_worker::UpdateRegistrationCommand`](struct.UpdateRegistrationCommand.html)  \n*Response Struct:* [`cdp::proto::service_worker::UpdateRegistrationResponse`](struct.UpdateRegistrationResponse.html)"]
    pub struct UpdateRegistrationCommand<'a> {
        #[serde(rename = "scopeURL")]
        pub scope_url: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpCommand for UpdateRegistrationCommand<'a> {
        fn command_name(&self) -> &str {
            "ServiceWorker.updateRegistration"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for UpdateRegistrationCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "ServiceWorker.updateRegistration" {
                Ok ( < UpdateRegistrationCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `ServiceWorker.updateRegistration`\n\n*Domain Module:* [`cdp::proto::service_worker`](index.html)  \n*Command Struct:* [`cdp::proto::service_worker::UpdateRegistrationCommand`](struct.UpdateRegistrationCommand.html)  \n*Response Struct:* [`cdp::proto::service_worker::UpdateRegistrationResponse`](struct.UpdateRegistrationResponse.html)"]
    pub struct UpdateRegistrationResponse;
    impl ::serde::Serialize for UpdateRegistrationResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for UpdateRegistrationResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| UpdateRegistrationResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for UpdateRegistrationCommand<'a> {
        type Response = UpdateRegistrationResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for UpdateRegistrationResponse {
        type Command = UpdateRegistrationCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `ServiceWorker.startWorker`\n\n*Domain Module:* [`cdp::proto::service_worker`](index.html)  \n*Command Struct:* [`cdp::proto::service_worker::StartWorkerCommand`](struct.StartWorkerCommand.html)  \n*Response Struct:* [`cdp::proto::service_worker::StartWorkerResponse`](struct.StartWorkerResponse.html)"]
    pub struct StartWorkerCommand<'a> {
        #[serde(rename = "scopeURL")]
        pub scope_url: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpCommand for StartWorkerCommand<'a> {
        fn command_name(&self) -> &str {
            "ServiceWorker.startWorker"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for StartWorkerCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "ServiceWorker.startWorker" {
                Ok(
                    <StartWorkerCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `ServiceWorker.startWorker`\n\n*Domain Module:* [`cdp::proto::service_worker`](index.html)  \n*Command Struct:* [`cdp::proto::service_worker::StartWorkerCommand`](struct.StartWorkerCommand.html)  \n*Response Struct:* [`cdp::proto::service_worker::StartWorkerResponse`](struct.StartWorkerResponse.html)"]
    pub struct StartWorkerResponse;
    impl ::serde::Serialize for StartWorkerResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StartWorkerResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StartWorkerResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for StartWorkerCommand<'a> {
        type Response = StartWorkerResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for StartWorkerResponse {
        type Command = StartWorkerCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `ServiceWorker.skipWaiting`\n\n*Domain Module:* [`cdp::proto::service_worker`](index.html)  \n*Command Struct:* [`cdp::proto::service_worker::SkipWaitingCommand`](struct.SkipWaitingCommand.html)  \n*Response Struct:* [`cdp::proto::service_worker::SkipWaitingResponse`](struct.SkipWaitingResponse.html)"]
    pub struct SkipWaitingCommand<'a> {
        #[serde(rename = "scopeURL")]
        pub scope_url: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpCommand for SkipWaitingCommand<'a> {
        fn command_name(&self) -> &str {
            "ServiceWorker.skipWaiting"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for SkipWaitingCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "ServiceWorker.skipWaiting" {
                Ok(
                    <SkipWaitingCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `ServiceWorker.skipWaiting`\n\n*Domain Module:* [`cdp::proto::service_worker`](index.html)  \n*Command Struct:* [`cdp::proto::service_worker::SkipWaitingCommand`](struct.SkipWaitingCommand.html)  \n*Response Struct:* [`cdp::proto::service_worker::SkipWaitingResponse`](struct.SkipWaitingResponse.html)"]
    pub struct SkipWaitingResponse;
    impl ::serde::Serialize for SkipWaitingResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SkipWaitingResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SkipWaitingResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SkipWaitingCommand<'a> {
        type Response = SkipWaitingResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SkipWaitingResponse {
        type Command = SkipWaitingCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `ServiceWorker.stopWorker`\n\n*Domain Module:* [`cdp::proto::service_worker`](index.html)  \n*Command Struct:* [`cdp::proto::service_worker::StopWorkerCommand`](struct.StopWorkerCommand.html)  \n*Response Struct:* [`cdp::proto::service_worker::StopWorkerResponse`](struct.StopWorkerResponse.html)"]
    pub struct StopWorkerCommand<'a> {
        #[serde(rename = "versionId")]
        pub version_id: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpCommand for StopWorkerCommand<'a> {
        fn command_name(&self) -> &str {
            "ServiceWorker.stopWorker"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for StopWorkerCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "ServiceWorker.stopWorker" {
                Ok(
                    <StopWorkerCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `ServiceWorker.stopWorker`\n\n*Domain Module:* [`cdp::proto::service_worker`](index.html)  \n*Command Struct:* [`cdp::proto::service_worker::StopWorkerCommand`](struct.StopWorkerCommand.html)  \n*Response Struct:* [`cdp::proto::service_worker::StopWorkerResponse`](struct.StopWorkerResponse.html)"]
    pub struct StopWorkerResponse;
    impl ::serde::Serialize for StopWorkerResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StopWorkerResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StopWorkerResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for StopWorkerCommand<'a> {
        type Response = StopWorkerResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for StopWorkerResponse {
        type Command = StopWorkerCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `ServiceWorker.inspectWorker`\n\n*Domain Module:* [`cdp::proto::service_worker`](index.html)  \n*Command Struct:* [`cdp::proto::service_worker::InspectWorkerCommand`](struct.InspectWorkerCommand.html)  \n*Response Struct:* [`cdp::proto::service_worker::InspectWorkerResponse`](struct.InspectWorkerResponse.html)"]
    pub struct InspectWorkerCommand<'a> {
        #[serde(rename = "versionId")]
        pub version_id: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpCommand for InspectWorkerCommand<'a> {
        fn command_name(&self) -> &str {
            "ServiceWorker.inspectWorker"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for InspectWorkerCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "ServiceWorker.inspectWorker" {
                Ok(
                    <InspectWorkerCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `ServiceWorker.inspectWorker`\n\n*Domain Module:* [`cdp::proto::service_worker`](index.html)  \n*Command Struct:* [`cdp::proto::service_worker::InspectWorkerCommand`](struct.InspectWorkerCommand.html)  \n*Response Struct:* [`cdp::proto::service_worker::InspectWorkerResponse`](struct.InspectWorkerResponse.html)"]
    pub struct InspectWorkerResponse;
    impl ::serde::Serialize for InspectWorkerResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for InspectWorkerResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| InspectWorkerResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for InspectWorkerCommand<'a> {
        type Response = InspectWorkerResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for InspectWorkerResponse {
        type Command = InspectWorkerCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `ServiceWorker.setForceUpdateOnPageLoad`\n\n*Domain Module:* [`cdp::proto::service_worker`](index.html)  \n*Command Struct:* [`cdp::proto::service_worker::SetForceUpdateOnPageLoadCommand`](struct.SetForceUpdateOnPageLoadCommand.html)  \n*Response Struct:* [`cdp::proto::service_worker::SetForceUpdateOnPageLoadResponse`](struct.SetForceUpdateOnPageLoadResponse.html)"]
    pub struct SetForceUpdateOnPageLoadCommand {
        #[serde(rename = "forceUpdateOnPageLoad")]
        pub force_update_on_page_load: bool,
    }
    impl ::traits::SerializeCdpCommand for SetForceUpdateOnPageLoadCommand {
        fn command_name(&self) -> &str {
            "ServiceWorker.setForceUpdateOnPageLoad"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for SetForceUpdateOnPageLoadCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "ServiceWorker.setForceUpdateOnPageLoad" {
                Ok ( < SetForceUpdateOnPageLoadCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `ServiceWorker.setForceUpdateOnPageLoad`\n\n*Domain Module:* [`cdp::proto::service_worker`](index.html)  \n*Command Struct:* [`cdp::proto::service_worker::SetForceUpdateOnPageLoadCommand`](struct.SetForceUpdateOnPageLoadCommand.html)  \n*Response Struct:* [`cdp::proto::service_worker::SetForceUpdateOnPageLoadResponse`](struct.SetForceUpdateOnPageLoadResponse.html)"]
    pub struct SetForceUpdateOnPageLoadResponse;
    impl ::serde::Serialize for SetForceUpdateOnPageLoadResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetForceUpdateOnPageLoadResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetForceUpdateOnPageLoadResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetForceUpdateOnPageLoadCommand {
        type Response = SetForceUpdateOnPageLoadResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetForceUpdateOnPageLoadResponse {
        type Command = SetForceUpdateOnPageLoadCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `ServiceWorker.deliverPushMessage`\n\n*Domain Module:* [`cdp::proto::service_worker`](index.html)  \n*Command Struct:* [`cdp::proto::service_worker::DeliverPushMessageCommand`](struct.DeliverPushMessageCommand.html)  \n*Response Struct:* [`cdp::proto::service_worker::DeliverPushMessageResponse`](struct.DeliverPushMessageResponse.html)"]
    pub struct DeliverPushMessageCommand<'a> {
        #[serde(rename = "origin")]
        pub origin: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "registrationId")]
        pub registration_id: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "data")]
        pub data: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpCommand for DeliverPushMessageCommand<'a> {
        fn command_name(&self) -> &str {
            "ServiceWorker.deliverPushMessage"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for DeliverPushMessageCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "ServiceWorker.deliverPushMessage" {
                Ok ( < DeliverPushMessageCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `ServiceWorker.deliverPushMessage`\n\n*Domain Module:* [`cdp::proto::service_worker`](index.html)  \n*Command Struct:* [`cdp::proto::service_worker::DeliverPushMessageCommand`](struct.DeliverPushMessageCommand.html)  \n*Response Struct:* [`cdp::proto::service_worker::DeliverPushMessageResponse`](struct.DeliverPushMessageResponse.html)"]
    pub struct DeliverPushMessageResponse;
    impl ::serde::Serialize for DeliverPushMessageResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DeliverPushMessageResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DeliverPushMessageResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for DeliverPushMessageCommand<'a> {
        type Response = DeliverPushMessageResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for DeliverPushMessageResponse {
        type Command = DeliverPushMessageCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `ServiceWorker.dispatchSyncEvent`\n\n*Domain Module:* [`cdp::proto::service_worker`](index.html)  \n*Command Struct:* [`cdp::proto::service_worker::DispatchSyncEventCommand`](struct.DispatchSyncEventCommand.html)  \n*Response Struct:* [`cdp::proto::service_worker::DispatchSyncEventResponse`](struct.DispatchSyncEventResponse.html)"]
    pub struct DispatchSyncEventCommand<'a> {
        #[serde(rename = "origin")]
        pub origin: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "registrationId")]
        pub registration_id: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "tag")]
        pub tag: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "lastChance")]
        pub last_chance: bool,
    }
    impl<'a> ::traits::SerializeCdpCommand for DispatchSyncEventCommand<'a> {
        fn command_name(&self) -> &str {
            "ServiceWorker.dispatchSyncEvent"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for DispatchSyncEventCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "ServiceWorker.dispatchSyncEvent" {
                Ok ( < DispatchSyncEventCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `ServiceWorker.dispatchSyncEvent`\n\n*Domain Module:* [`cdp::proto::service_worker`](index.html)  \n*Command Struct:* [`cdp::proto::service_worker::DispatchSyncEventCommand`](struct.DispatchSyncEventCommand.html)  \n*Response Struct:* [`cdp::proto::service_worker::DispatchSyncEventResponse`](struct.DispatchSyncEventResponse.html)"]
    pub struct DispatchSyncEventResponse;
    impl ::serde::Serialize for DispatchSyncEventResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DispatchSyncEventResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DispatchSyncEventResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for DispatchSyncEventCommand<'a> {
        type Response = DispatchSyncEventResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for DispatchSyncEventResponse {
        type Command = DispatchSyncEventCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Event `ServiceWorker.workerRegistrationUpdated`\n\n*Domain Module:* [`cdp::proto::service_worker`](index.html)  \n*Event Struct:* [`cdp::proto::service_worker::WorkerRegistrationUpdatedEvent`](struct.WorkerRegistrationUpdatedEvent.html)"]
    pub struct WorkerRegistrationUpdatedEvent<'a> {
        #[serde(rename = "registrations")]
        pub registrations: Vec<::proto::service_worker::ServiceWorkerRegistration<'a>>,
    }
    impl<'a> ::traits::SerializeCdpEvent for WorkerRegistrationUpdatedEvent<'a> {
        fn event_name(&self) -> &str {
            "ServiceWorker.workerRegistrationUpdated"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for WorkerRegistrationUpdatedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "ServiceWorker.workerRegistrationUpdated" {
                Ok ( < WorkerRegistrationUpdatedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Event `ServiceWorker.workerVersionUpdated`\n\n*Domain Module:* [`cdp::proto::service_worker`](index.html)  \n*Event Struct:* [`cdp::proto::service_worker::WorkerVersionUpdatedEvent`](struct.WorkerVersionUpdatedEvent.html)"]
    pub struct WorkerVersionUpdatedEvent<'a> {
        #[serde(rename = "versions")]
        pub versions: Vec<::proto::service_worker::ServiceWorkerVersion<'a>>,
    }
    impl<'a> ::traits::SerializeCdpEvent for WorkerVersionUpdatedEvent<'a> {
        fn event_name(&self) -> &str {
            "ServiceWorker.workerVersionUpdated"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for WorkerVersionUpdatedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "ServiceWorker.workerVersionUpdated" {
                Ok ( < WorkerVersionUpdatedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Event `ServiceWorker.workerErrorReported`\n\n*Domain Module:* [`cdp::proto::service_worker`](index.html)  \n*Event Struct:* [`cdp::proto::service_worker::WorkerErrorReportedEvent`](struct.WorkerErrorReportedEvent.html)"]
    pub struct WorkerErrorReportedEvent<'a> {
        #[serde(rename = "errorMessage")]
        pub error_message: ::proto::service_worker::ServiceWorkerErrorMessage<'a>,
    }
    impl<'a> ::traits::SerializeCdpEvent for WorkerErrorReportedEvent<'a> {
        fn event_name(&self) -> &str {
            "ServiceWorker.workerErrorReported"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for WorkerErrorReportedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "ServiceWorker.workerErrorReported" {
                Ok ( < WorkerErrorReportedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> ServiceWorker registration."]
    pub struct ServiceWorkerRegistration<'a> {
        #[serde(rename = "registrationId")]
        pub registration_id: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "scopeURL")]
        pub scope_url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "isDeleted")]
        pub is_deleted: bool,
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>"]
    pub enum ServiceWorkerVersionRunningStatus {
        #[serde(rename = "stopped")]
        #[doc = "Represented as `\"stopped\"`."]
        Stopped,
        #[serde(rename = "starting")]
        #[doc = "Represented as `\"starting\"`."]
        Starting,
        #[serde(rename = "running")]
        #[doc = "Represented as `\"running\"`."]
        Running,
        #[serde(rename = "stopping")]
        #[doc = "Represented as `\"stopping\"`."]
        Stopping,
    }
    impl ServiceWorkerVersionRunningStatus {
        pub const ENUM_VALUES: &'static [ServiceWorkerVersionRunningStatus] =
            &[
                ServiceWorkerVersionRunningStatus::Stopped,
                ServiceWorkerVersionRunningStatus::Starting,
                ServiceWorkerVersionRunningStatus::Running,
                ServiceWorkerVersionRunningStatus::Stopping,
            ];
        pub const STR_VALUES: &'static [&'static str] =
            &["stopped", "starting", "running", "stopping"];
    }
    impl ::std::str::FromStr for ServiceWorkerVersionRunningStatus {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "stopped" => Ok(ServiceWorkerVersionRunningStatus::Stopped),
                "starting" => Ok(ServiceWorkerVersionRunningStatus::Starting),
                "running" => Ok(ServiceWorkerVersionRunningStatus::Running),
                "stopping" => Ok(ServiceWorkerVersionRunningStatus::Stopping),
                _ => Err(::proto::ParseEnumError {
                    expected: ServiceWorkerVersionRunningStatus::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for ServiceWorkerVersionRunningStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    ServiceWorkerVersionRunningStatus::Stopped => "stopped",
                    ServiceWorkerVersionRunningStatus::Starting => "starting",
                    ServiceWorkerVersionRunningStatus::Running => "running",
                    ServiceWorkerVersionRunningStatus::Stopping => "stopping",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>"]
    pub enum ServiceWorkerVersionStatus {
        #[serde(rename = "new")]
        #[doc = "Represented as `\"new\"`."]
        New,
        #[serde(rename = "installing")]
        #[doc = "Represented as `\"installing\"`."]
        Installing,
        #[serde(rename = "installed")]
        #[doc = "Represented as `\"installed\"`."]
        Installed,
        #[serde(rename = "activating")]
        #[doc = "Represented as `\"activating\"`."]
        Activating,
        #[serde(rename = "activated")]
        #[doc = "Represented as `\"activated\"`."]
        Activated,
        #[serde(rename = "redundant")]
        #[doc = "Represented as `\"redundant\"`."]
        Redundant,
    }
    impl ServiceWorkerVersionStatus {
        pub const ENUM_VALUES: &'static [ServiceWorkerVersionStatus] =
            &[
                ServiceWorkerVersionStatus::New,
                ServiceWorkerVersionStatus::Installing,
                ServiceWorkerVersionStatus::Installed,
                ServiceWorkerVersionStatus::Activating,
                ServiceWorkerVersionStatus::Activated,
                ServiceWorkerVersionStatus::Redundant,
            ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "new",
            "installing",
            "installed",
            "activating",
            "activated",
            "redundant",
        ];
    }
    impl ::std::str::FromStr for ServiceWorkerVersionStatus {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "new" => Ok(ServiceWorkerVersionStatus::New),
                "installing" => Ok(ServiceWorkerVersionStatus::Installing),
                "installed" => Ok(ServiceWorkerVersionStatus::Installed),
                "activating" => Ok(ServiceWorkerVersionStatus::Activating),
                "activated" => Ok(ServiceWorkerVersionStatus::Activated),
                "redundant" => Ok(ServiceWorkerVersionStatus::Redundant),
                _ => Err(::proto::ParseEnumError {
                    expected: ServiceWorkerVersionStatus::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for ServiceWorkerVersionStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    ServiceWorkerVersionStatus::New => "new",
                    ServiceWorkerVersionStatus::Installing => "installing",
                    ServiceWorkerVersionStatus::Installed => "installed",
                    ServiceWorkerVersionStatus::Activating => "activating",
                    ServiceWorkerVersionStatus::Activated => "activated",
                    ServiceWorkerVersionStatus::Redundant => "redundant",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> ServiceWorker version."]
    pub struct ServiceWorkerVersion<'a> {
        #[serde(rename = "versionId")]
        pub version_id: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "registrationId")]
        pub registration_id: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "scriptURL")]
        pub script_url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "runningStatus")]
        pub running_status: ::proto::service_worker::ServiceWorkerVersionRunningStatus,
        #[serde(rename = "status")]
        pub status: ::proto::service_worker::ServiceWorkerVersionStatus,
        #[serde(rename = "scriptLastModified", skip_serializing_if = "Option::is_none")]
        #[doc = "The Last-Modified header value of the main script."]
        pub script_last_modified: Option<f64>,
        #[serde(rename = "scriptResponseTime", skip_serializing_if = "Option::is_none")]
        #[doc = "The time at which the response headers of the main script were received from the server.  For cached script it is the last time the cache entry was validated."]
        pub script_response_time: Option<f64>,
        #[serde(rename = "controlledClients", skip_serializing_if = "Option::is_none")]
        pub controlled_clients: Option<Vec<::proto::target::TargetId<'a>>>,
        #[serde(rename = "targetId", skip_serializing_if = "Option::is_none")]
        pub target_id: Option<::proto::target::TargetId<'a>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> ServiceWorker error message."]
    pub struct ServiceWorkerErrorMessage<'a> {
        #[serde(rename = "errorMessage")]
        pub error_message: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "registrationId")]
        pub registration_id: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "versionId")]
        pub version_id: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "sourceURL")]
        pub source_url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "lineNumber")]
        pub line_number: i32,
        #[serde(rename = "columnNumber")]
        pub column_number: i32,
    }
}
#[doc = "# Input\n\n## Commands\n\n- [`Input.setIgnoreInputEvents`](struct.SetIgnoreInputEventsCommand.html)\n\n  Ignores input events \\(useful while auditing page\\).\n- [`Input.dispatchKeyEvent`](struct.DispatchKeyEventCommand.html)\n\n  Dispatches a key event to the page.\n- [`Input.dispatchMouseEvent`](struct.DispatchMouseEventCommand.html)\n\n  Dispatches a mouse event to the page.\n- [`Input.dispatchTouchEvent`](struct.DispatchTouchEventCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Dispatches a touch event to the page.\n- [`Input.emulateTouchFromMouseEvent`](struct.EmulateTouchFromMouseEventCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Emulates touch event from the mouse event parameters.\n- [`Input.synthesizePinchGesture`](struct.SynthesizePinchGestureCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Synthesizes a pinch gesture over a time period by issuing appropriate touch events.\n- [`Input.synthesizeScrollGesture`](struct.SynthesizeScrollGestureCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Synthesizes a scroll gesture over a time period by issuing appropriate touch events.\n- [`Input.synthesizeTapGesture`](struct.SynthesizeTapGestureCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Synthesizes a tap gesture over a time period by issuing appropriate touch events.\n\n##Types\n\n- [`TouchPoint`](struct.TouchPoint.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`GestureSourceType`](enum.GestureSourceType.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`TimeSinceEpoch`](type.TimeSinceEpoch.html)\n\n  UTC time in seconds, counted from January 1, 1970.\n"]
pub mod input {
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Ignores input events \\(useful while auditing page\\).\n\n# Command `Input.setIgnoreInputEvents`\n\n*Domain Module:* [`cdp::proto::input`](index.html)  \n*Command Struct:* [`cdp::proto::input::SetIgnoreInputEventsCommand`](struct.SetIgnoreInputEventsCommand.html)  \n*Response Struct:* [`cdp::proto::input::SetIgnoreInputEventsResponse`](struct.SetIgnoreInputEventsResponse.html)"]
    pub struct SetIgnoreInputEventsCommand {
        #[serde(rename = "ignore")]
        #[doc = "Ignores input events processing when set to true."]
        pub ignore: bool,
    }
    impl ::traits::SerializeCdpCommand for SetIgnoreInputEventsCommand {
        fn command_name(&self) -> &str {
            "Input.setIgnoreInputEvents"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for SetIgnoreInputEventsCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Input.setIgnoreInputEvents" {
                Ok ( < SetIgnoreInputEventsCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Ignores input events \\(useful while auditing page\\).\n\n# Command `Input.setIgnoreInputEvents`\n\n*Domain Module:* [`cdp::proto::input`](index.html)  \n*Command Struct:* [`cdp::proto::input::SetIgnoreInputEventsCommand`](struct.SetIgnoreInputEventsCommand.html)  \n*Response Struct:* [`cdp::proto::input::SetIgnoreInputEventsResponse`](struct.SetIgnoreInputEventsResponse.html)"]
    pub struct SetIgnoreInputEventsResponse;
    impl ::serde::Serialize for SetIgnoreInputEventsResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetIgnoreInputEventsResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetIgnoreInputEventsResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetIgnoreInputEventsCommand {
        type Response = SetIgnoreInputEventsResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetIgnoreInputEventsResponse {
        type Command = SetIgnoreInputEventsCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "Used in the type of [`cdp::proto::input::DispatchKeyEventCommand::ty`](struct.DispatchKeyEventCommand.html#structfield.ty)."]
    pub enum DispatchKeyEventCommandType {
        #[serde(rename = "keyDown")]
        #[doc = "Represented as `\"keyDown\"`."]
        KeyDown,
        #[serde(rename = "keyUp")]
        #[doc = "Represented as `\"keyUp\"`."]
        KeyUp,
        #[serde(rename = "rawKeyDown")]
        #[doc = "Represented as `\"rawKeyDown\"`."]
        RawKeyDown,
        #[serde(rename = "char")]
        #[doc = "Represented as `\"char\"`."]
        Char,
    }
    impl DispatchKeyEventCommandType {
        pub const ENUM_VALUES: &'static [DispatchKeyEventCommandType] =
            &[
                DispatchKeyEventCommandType::KeyDown,
                DispatchKeyEventCommandType::KeyUp,
                DispatchKeyEventCommandType::RawKeyDown,
                DispatchKeyEventCommandType::Char,
            ];
        pub const STR_VALUES: &'static [&'static str] = &["keyDown", "keyUp", "rawKeyDown", "char"];
    }
    impl ::std::str::FromStr for DispatchKeyEventCommandType {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "keyDown" => Ok(DispatchKeyEventCommandType::KeyDown),
                "keyUp" => Ok(DispatchKeyEventCommandType::KeyUp),
                "rawKeyDown" => Ok(DispatchKeyEventCommandType::RawKeyDown),
                "char" => Ok(DispatchKeyEventCommandType::Char),
                _ => Err(::proto::ParseEnumError {
                    expected: DispatchKeyEventCommandType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for DispatchKeyEventCommandType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    DispatchKeyEventCommandType::KeyDown => "keyDown",
                    DispatchKeyEventCommandType::KeyUp => "keyUp",
                    DispatchKeyEventCommandType::RawKeyDown => "rawKeyDown",
                    DispatchKeyEventCommandType::Char => "char",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Dispatches a key event to the page.\n\n# Command `Input.dispatchKeyEvent`\n\n*Domain Module:* [`cdp::proto::input`](index.html)  \n*Command Struct:* [`cdp::proto::input::DispatchKeyEventCommand`](struct.DispatchKeyEventCommand.html)  \n*Response Struct:* [`cdp::proto::input::DispatchKeyEventResponse`](struct.DispatchKeyEventResponse.html)"]
    pub struct DispatchKeyEventCommand<'a> {
        #[serde(rename = "type")]
        #[doc = "Type of the key event."]
        pub ty: ::proto::input::DispatchKeyEventCommandType,
        #[serde(rename = "modifiers", skip_serializing_if = "Option::is_none")]
        #[doc = "Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 \\(default: 0\\)."]
        pub modifiers: Option<i32>,
        #[serde(rename = "timestamp", skip_serializing_if = "Option::is_none")]
        #[doc = "Time at which the event occurred."]
        pub timestamp: Option<::proto::input::TimeSinceEpoch>,
        #[serde(rename = "text", skip_serializing_if = "Option::is_none")]
        #[doc = "Text as generated by processing a virtual key code with a keyboard layout. Not needed for for <code>keyUp</code> and <code>rawKeyDown</code> events \\(default: \"\"\\)"]
        pub text: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "unmodifiedText", skip_serializing_if = "Option::is_none")]
        #[doc = "Text that would have been generated by the keyboard if no modifiers were pressed \\(except for shift\\). Useful for shortcut \\(accelerator\\) key handling \\(default: \"\"\\)."]
        pub unmodified_text: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "keyIdentifier", skip_serializing_if = "Option::is_none")]
        #[doc = "Unique key identifier \\(e.g., 'U+0041'\\) \\(default: \"\"\\)."]
        pub key_identifier: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "code", skip_serializing_if = "Option::is_none")]
        #[doc = "Unique DOM defined string value for each physical key \\(e.g., 'KeyA'\\) \\(default: \"\"\\)."]
        pub code: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "key", skip_serializing_if = "Option::is_none")]
        #[doc = "Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc \\(e.g., 'AltGr'\\) \\(default: \"\"\\)."]
        pub key: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "windowsVirtualKeyCode", skip_serializing_if = "Option::is_none")]
        #[doc = "Windows virtual key code \\(default: 0\\)."]
        pub windows_virtual_key_code: Option<i32>,
        #[serde(rename = "nativeVirtualKeyCode", skip_serializing_if = "Option::is_none")]
        #[doc = "Native virtual key code \\(default: 0\\)."]
        pub native_virtual_key_code: Option<i32>,
        #[serde(rename = "autoRepeat", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether the event was generated from auto repeat \\(default: false\\)."]
        pub auto_repeat: Option<bool>,
        #[serde(rename = "isKeypad", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether the event was generated from the keypad \\(default: false\\)."]
        pub is_keypad: Option<bool>,
        #[serde(rename = "isSystemKey", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether the event was a system key event \\(default: false\\)."]
        pub is_system_key: Option<bool>,
    }
    impl<'a> ::traits::SerializeCdpCommand for DispatchKeyEventCommand<'a> {
        fn command_name(&self) -> &str {
            "Input.dispatchKeyEvent"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for DispatchKeyEventCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Input.dispatchKeyEvent" {
                Ok ( < DispatchKeyEventCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Dispatches a key event to the page.\n\n# Command `Input.dispatchKeyEvent`\n\n*Domain Module:* [`cdp::proto::input`](index.html)  \n*Command Struct:* [`cdp::proto::input::DispatchKeyEventCommand`](struct.DispatchKeyEventCommand.html)  \n*Response Struct:* [`cdp::proto::input::DispatchKeyEventResponse`](struct.DispatchKeyEventResponse.html)"]
    pub struct DispatchKeyEventResponse;
    impl ::serde::Serialize for DispatchKeyEventResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DispatchKeyEventResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DispatchKeyEventResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for DispatchKeyEventCommand<'a> {
        type Response = DispatchKeyEventResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for DispatchKeyEventResponse {
        type Command = DispatchKeyEventCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "Used in the type of [`cdp::proto::input::DispatchMouseEventCommand::ty`](struct.DispatchMouseEventCommand.html#structfield.ty)."]
    pub enum DispatchMouseEventCommandType {
        #[serde(rename = "mousePressed")]
        #[doc = "Represented as `\"mousePressed\"`."]
        MousePressed,
        #[serde(rename = "mouseReleased")]
        #[doc = "Represented as `\"mouseReleased\"`."]
        MouseReleased,
        #[serde(rename = "mouseMoved")]
        #[doc = "Represented as `\"mouseMoved\"`."]
        MouseMoved,
    }
    impl DispatchMouseEventCommandType {
        pub const ENUM_VALUES: &'static [DispatchMouseEventCommandType] =
            &[
                DispatchMouseEventCommandType::MousePressed,
                DispatchMouseEventCommandType::MouseReleased,
                DispatchMouseEventCommandType::MouseMoved,
            ];
        pub const STR_VALUES: &'static [&'static str] =
            &["mousePressed", "mouseReleased", "mouseMoved"];
    }
    impl ::std::str::FromStr for DispatchMouseEventCommandType {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "mousePressed" => Ok(DispatchMouseEventCommandType::MousePressed),
                "mouseReleased" => Ok(DispatchMouseEventCommandType::MouseReleased),
                "mouseMoved" => Ok(DispatchMouseEventCommandType::MouseMoved),
                _ => Err(::proto::ParseEnumError {
                    expected: DispatchMouseEventCommandType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for DispatchMouseEventCommandType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    DispatchMouseEventCommandType::MousePressed => "mousePressed",
                    DispatchMouseEventCommandType::MouseReleased => "mouseReleased",
                    DispatchMouseEventCommandType::MouseMoved => "mouseMoved",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "Used in the type of [`cdp::proto::input::DispatchMouseEventCommand::button`](struct.DispatchMouseEventCommand.html#structfield.button)."]
    pub enum DispatchMouseEventCommandButton {
        #[serde(rename = "none")]
        #[doc = "Represented as `\"none\"`."]
        None,
        #[serde(rename = "left")]
        #[doc = "Represented as `\"left\"`."]
        Left,
        #[serde(rename = "middle")]
        #[doc = "Represented as `\"middle\"`."]
        Middle,
        #[serde(rename = "right")]
        #[doc = "Represented as `\"right\"`."]
        Right,
    }
    impl DispatchMouseEventCommandButton {
        pub const ENUM_VALUES: &'static [DispatchMouseEventCommandButton] =
            &[
                DispatchMouseEventCommandButton::None,
                DispatchMouseEventCommandButton::Left,
                DispatchMouseEventCommandButton::Middle,
                DispatchMouseEventCommandButton::Right,
            ];
        pub const STR_VALUES: &'static [&'static str] = &["none", "left", "middle", "right"];
    }
    impl ::std::str::FromStr for DispatchMouseEventCommandButton {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "none" => Ok(DispatchMouseEventCommandButton::None),
                "left" => Ok(DispatchMouseEventCommandButton::Left),
                "middle" => Ok(DispatchMouseEventCommandButton::Middle),
                "right" => Ok(DispatchMouseEventCommandButton::Right),
                _ => Err(::proto::ParseEnumError {
                    expected: DispatchMouseEventCommandButton::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for DispatchMouseEventCommandButton {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    DispatchMouseEventCommandButton::None => "none",
                    DispatchMouseEventCommandButton::Left => "left",
                    DispatchMouseEventCommandButton::Middle => "middle",
                    DispatchMouseEventCommandButton::Right => "right",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Dispatches a mouse event to the page.\n\n# Command `Input.dispatchMouseEvent`\n\n*Domain Module:* [`cdp::proto::input`](index.html)  \n*Command Struct:* [`cdp::proto::input::DispatchMouseEventCommand`](struct.DispatchMouseEventCommand.html)  \n*Response Struct:* [`cdp::proto::input::DispatchMouseEventResponse`](struct.DispatchMouseEventResponse.html)"]
    pub struct DispatchMouseEventCommand {
        #[serde(rename = "type")]
        #[doc = "Type of the mouse event."]
        pub ty: ::proto::input::DispatchMouseEventCommandType,
        #[serde(rename = "x")]
        #[doc = "X coordinate of the event relative to the main frame's viewport in CSS pixels."]
        pub x: f64,
        #[serde(rename = "y")]
        #[doc = "Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport."]
        pub y: f64,
        #[serde(rename = "modifiers", skip_serializing_if = "Option::is_none")]
        #[doc = "Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 \\(default: 0\\)."]
        pub modifiers: Option<i32>,
        #[serde(rename = "timestamp", skip_serializing_if = "Option::is_none")]
        #[doc = "Time at which the event occurred."]
        pub timestamp: Option<::proto::input::TimeSinceEpoch>,
        #[serde(rename = "button", skip_serializing_if = "Option::is_none")]
        #[doc = "Mouse button \\(default: \"none\"\\)."]
        pub button: Option<::proto::input::DispatchMouseEventCommandButton>,
        #[serde(rename = "clickCount", skip_serializing_if = "Option::is_none")]
        #[doc = "Number of times the mouse button was clicked \\(default: 0\\)."]
        pub click_count: Option<i32>,
    }
    impl ::traits::SerializeCdpCommand for DispatchMouseEventCommand {
        fn command_name(&self) -> &str {
            "Input.dispatchMouseEvent"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for DispatchMouseEventCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Input.dispatchMouseEvent" {
                Ok ( < DispatchMouseEventCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Dispatches a mouse event to the page.\n\n# Command `Input.dispatchMouseEvent`\n\n*Domain Module:* [`cdp::proto::input`](index.html)  \n*Command Struct:* [`cdp::proto::input::DispatchMouseEventCommand`](struct.DispatchMouseEventCommand.html)  \n*Response Struct:* [`cdp::proto::input::DispatchMouseEventResponse`](struct.DispatchMouseEventResponse.html)"]
    pub struct DispatchMouseEventResponse;
    impl ::serde::Serialize for DispatchMouseEventResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DispatchMouseEventResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DispatchMouseEventResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for DispatchMouseEventCommand {
        type Response = DispatchMouseEventResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for DispatchMouseEventResponse {
        type Command = DispatchMouseEventCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\nUsed in the type of [`cdp::proto::input::DispatchTouchEventCommand::ty`](struct.DispatchTouchEventCommand.html#structfield.ty)."]
    pub enum DispatchTouchEventCommandType {
        #[serde(rename = "touchStart")]
        #[doc = "Represented as `\"touchStart\"`."]
        TouchStart,
        #[serde(rename = "touchEnd")]
        #[doc = "Represented as `\"touchEnd\"`."]
        TouchEnd,
        #[serde(rename = "touchMove")]
        #[doc = "Represented as `\"touchMove\"`."]
        TouchMove,
    }
    impl DispatchTouchEventCommandType {
        pub const ENUM_VALUES: &'static [DispatchTouchEventCommandType] =
            &[
                DispatchTouchEventCommandType::TouchStart,
                DispatchTouchEventCommandType::TouchEnd,
                DispatchTouchEventCommandType::TouchMove,
            ];
        pub const STR_VALUES: &'static [&'static str] = &["touchStart", "touchEnd", "touchMove"];
    }
    impl ::std::str::FromStr for DispatchTouchEventCommandType {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "touchStart" => Ok(DispatchTouchEventCommandType::TouchStart),
                "touchEnd" => Ok(DispatchTouchEventCommandType::TouchEnd),
                "touchMove" => Ok(DispatchTouchEventCommandType::TouchMove),
                _ => Err(::proto::ParseEnumError {
                    expected: DispatchTouchEventCommandType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for DispatchTouchEventCommandType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    DispatchTouchEventCommandType::TouchStart => "touchStart",
                    DispatchTouchEventCommandType::TouchEnd => "touchEnd",
                    DispatchTouchEventCommandType::TouchMove => "touchMove",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Dispatches a touch event to the page.\n\n# Command `Input.dispatchTouchEvent`\n\n*Domain Module:* [`cdp::proto::input`](index.html)  \n*Command Struct:* [`cdp::proto::input::DispatchTouchEventCommand`](struct.DispatchTouchEventCommand.html)  \n*Response Struct:* [`cdp::proto::input::DispatchTouchEventResponse`](struct.DispatchTouchEventResponse.html)"]
    pub struct DispatchTouchEventCommand {
        #[serde(rename = "type")]
        #[doc = "Type of the touch event."]
        pub ty: ::proto::input::DispatchTouchEventCommandType,
        #[serde(rename = "touchPoints")]
        #[doc = "Touch points."]
        pub touch_points: Vec<::proto::input::TouchPoint>,
        #[serde(rename = "modifiers", skip_serializing_if = "Option::is_none")]
        #[doc = "Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 \\(default: 0\\)."]
        pub modifiers: Option<i32>,
        #[serde(rename = "timestamp", skip_serializing_if = "Option::is_none")]
        #[doc = "Time at which the event occurred."]
        pub timestamp: Option<::proto::input::TimeSinceEpoch>,
    }
    impl ::traits::SerializeCdpCommand for DispatchTouchEventCommand {
        fn command_name(&self) -> &str {
            "Input.dispatchTouchEvent"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for DispatchTouchEventCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Input.dispatchTouchEvent" {
                Ok ( < DispatchTouchEventCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Dispatches a touch event to the page.\n\n# Command `Input.dispatchTouchEvent`\n\n*Domain Module:* [`cdp::proto::input`](index.html)  \n*Command Struct:* [`cdp::proto::input::DispatchTouchEventCommand`](struct.DispatchTouchEventCommand.html)  \n*Response Struct:* [`cdp::proto::input::DispatchTouchEventResponse`](struct.DispatchTouchEventResponse.html)"]
    pub struct DispatchTouchEventResponse;
    impl ::serde::Serialize for DispatchTouchEventResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DispatchTouchEventResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DispatchTouchEventResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for DispatchTouchEventCommand {
        type Response = DispatchTouchEventResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for DispatchTouchEventResponse {
        type Command = DispatchTouchEventCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\nUsed in the type of [`cdp::proto::input::EmulateTouchFromMouseEventCommand::ty`](struct.EmulateTouchFromMouseEventCommand.html#structfield.ty)."]
    pub enum EmulateTouchFromMouseEventCommandType {
        #[serde(rename = "mousePressed")]
        #[doc = "Represented as `\"mousePressed\"`."]
        MousePressed,
        #[serde(rename = "mouseReleased")]
        #[doc = "Represented as `\"mouseReleased\"`."]
        MouseReleased,
        #[serde(rename = "mouseMoved")]
        #[doc = "Represented as `\"mouseMoved\"`."]
        MouseMoved,
        #[serde(rename = "mouseWheel")]
        #[doc = "Represented as `\"mouseWheel\"`."]
        MouseWheel,
    }
    impl EmulateTouchFromMouseEventCommandType {
        pub const ENUM_VALUES: &'static [EmulateTouchFromMouseEventCommandType] =
            &[
                EmulateTouchFromMouseEventCommandType::MousePressed,
                EmulateTouchFromMouseEventCommandType::MouseReleased,
                EmulateTouchFromMouseEventCommandType::MouseMoved,
                EmulateTouchFromMouseEventCommandType::MouseWheel,
            ];
        pub const STR_VALUES: &'static [&'static str] =
            &["mousePressed", "mouseReleased", "mouseMoved", "mouseWheel"];
    }
    impl ::std::str::FromStr for EmulateTouchFromMouseEventCommandType {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "mousePressed" => Ok(EmulateTouchFromMouseEventCommandType::MousePressed),
                "mouseReleased" => Ok(EmulateTouchFromMouseEventCommandType::MouseReleased),
                "mouseMoved" => Ok(EmulateTouchFromMouseEventCommandType::MouseMoved),
                "mouseWheel" => Ok(EmulateTouchFromMouseEventCommandType::MouseWheel),
                _ => Err(::proto::ParseEnumError {
                    expected: EmulateTouchFromMouseEventCommandType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for EmulateTouchFromMouseEventCommandType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    EmulateTouchFromMouseEventCommandType::MousePressed => "mousePressed",
                    EmulateTouchFromMouseEventCommandType::MouseReleased => "mouseReleased",
                    EmulateTouchFromMouseEventCommandType::MouseMoved => "mouseMoved",
                    EmulateTouchFromMouseEventCommandType::MouseWheel => "mouseWheel",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\nUsed in the type of [`cdp::proto::input::EmulateTouchFromMouseEventCommand::button`](struct.EmulateTouchFromMouseEventCommand.html#structfield.button)."]
    pub enum EmulateTouchFromMouseEventCommandButton {
        #[serde(rename = "none")]
        #[doc = "Represented as `\"none\"`."]
        None,
        #[serde(rename = "left")]
        #[doc = "Represented as `\"left\"`."]
        Left,
        #[serde(rename = "middle")]
        #[doc = "Represented as `\"middle\"`."]
        Middle,
        #[serde(rename = "right")]
        #[doc = "Represented as `\"right\"`."]
        Right,
    }
    impl EmulateTouchFromMouseEventCommandButton {
        pub const ENUM_VALUES: &'static [EmulateTouchFromMouseEventCommandButton] =
            &[
                EmulateTouchFromMouseEventCommandButton::None,
                EmulateTouchFromMouseEventCommandButton::Left,
                EmulateTouchFromMouseEventCommandButton::Middle,
                EmulateTouchFromMouseEventCommandButton::Right,
            ];
        pub const STR_VALUES: &'static [&'static str] = &["none", "left", "middle", "right"];
    }
    impl ::std::str::FromStr for EmulateTouchFromMouseEventCommandButton {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "none" => Ok(EmulateTouchFromMouseEventCommandButton::None),
                "left" => Ok(EmulateTouchFromMouseEventCommandButton::Left),
                "middle" => Ok(EmulateTouchFromMouseEventCommandButton::Middle),
                "right" => Ok(EmulateTouchFromMouseEventCommandButton::Right),
                _ => Err(::proto::ParseEnumError {
                    expected: EmulateTouchFromMouseEventCommandButton::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for EmulateTouchFromMouseEventCommandButton {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    EmulateTouchFromMouseEventCommandButton::None => "none",
                    EmulateTouchFromMouseEventCommandButton::Left => "left",
                    EmulateTouchFromMouseEventCommandButton::Middle => "middle",
                    EmulateTouchFromMouseEventCommandButton::Right => "right",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Emulates touch event from the mouse event parameters.\n\n# Command `Input.emulateTouchFromMouseEvent`\n\n*Domain Module:* [`cdp::proto::input`](index.html)  \n*Command Struct:* [`cdp::proto::input::EmulateTouchFromMouseEventCommand`](struct.EmulateTouchFromMouseEventCommand.html)  \n*Response Struct:* [`cdp::proto::input::EmulateTouchFromMouseEventResponse`](struct.EmulateTouchFromMouseEventResponse.html)"]
    pub struct EmulateTouchFromMouseEventCommand {
        #[serde(rename = "type")]
        #[doc = "Type of the mouse event."]
        pub ty: ::proto::input::EmulateTouchFromMouseEventCommandType,
        #[serde(rename = "x")]
        #[doc = "X coordinate of the mouse pointer in DIP."]
        pub x: i32,
        #[serde(rename = "y")]
        #[doc = "Y coordinate of the mouse pointer in DIP."]
        pub y: i32,
        #[serde(rename = "timestamp")]
        #[doc = "Time at which the event occurred."]
        pub timestamp: ::proto::input::TimeSinceEpoch,
        #[serde(rename = "button")]
        #[doc = "Mouse button."]
        pub button: ::proto::input::EmulateTouchFromMouseEventCommandButton,
        #[serde(rename = "deltaX", skip_serializing_if = "Option::is_none")]
        #[doc = "X delta in DIP for mouse wheel event \\(default: 0\\)."]
        pub delta_x: Option<f64>,
        #[serde(rename = "deltaY", skip_serializing_if = "Option::is_none")]
        #[doc = "Y delta in DIP for mouse wheel event \\(default: 0\\)."]
        pub delta_y: Option<f64>,
        #[serde(rename = "modifiers", skip_serializing_if = "Option::is_none")]
        #[doc = "Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 \\(default: 0\\)."]
        pub modifiers: Option<i32>,
        #[serde(rename = "clickCount", skip_serializing_if = "Option::is_none")]
        #[doc = "Number of times the mouse button was clicked \\(default: 0\\)."]
        pub click_count: Option<i32>,
    }
    impl ::traits::SerializeCdpCommand for EmulateTouchFromMouseEventCommand {
        fn command_name(&self) -> &str {
            "Input.emulateTouchFromMouseEvent"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for EmulateTouchFromMouseEventCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Input.emulateTouchFromMouseEvent" {
                Ok ( < EmulateTouchFromMouseEventCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Emulates touch event from the mouse event parameters.\n\n# Command `Input.emulateTouchFromMouseEvent`\n\n*Domain Module:* [`cdp::proto::input`](index.html)  \n*Command Struct:* [`cdp::proto::input::EmulateTouchFromMouseEventCommand`](struct.EmulateTouchFromMouseEventCommand.html)  \n*Response Struct:* [`cdp::proto::input::EmulateTouchFromMouseEventResponse`](struct.EmulateTouchFromMouseEventResponse.html)"]
    pub struct EmulateTouchFromMouseEventResponse;
    impl ::serde::Serialize for EmulateTouchFromMouseEventResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EmulateTouchFromMouseEventResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EmulateTouchFromMouseEventResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for EmulateTouchFromMouseEventCommand {
        type Response = EmulateTouchFromMouseEventResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for EmulateTouchFromMouseEventResponse {
        type Command = EmulateTouchFromMouseEventCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Synthesizes a pinch gesture over a time period by issuing appropriate touch events.\n\n# Command `Input.synthesizePinchGesture`\n\n*Domain Module:* [`cdp::proto::input`](index.html)  \n*Command Struct:* [`cdp::proto::input::SynthesizePinchGestureCommand`](struct.SynthesizePinchGestureCommand.html)  \n*Response Struct:* [`cdp::proto::input::SynthesizePinchGestureResponse`](struct.SynthesizePinchGestureResponse.html)"]
    pub struct SynthesizePinchGestureCommand {
        #[serde(rename = "x")]
        #[doc = "X coordinate of the start of the gesture in CSS pixels."]
        pub x: f64,
        #[serde(rename = "y")]
        #[doc = "Y coordinate of the start of the gesture in CSS pixels."]
        pub y: f64,
        #[serde(rename = "scaleFactor")]
        #[doc = "Relative scale factor after zooming \\(>1.0 zooms in, <1.0 zooms out\\)."]
        pub scale_factor: f64,
        #[serde(rename = "relativeSpeed", skip_serializing_if = "Option::is_none")]
        #[doc = "Relative pointer speed in pixels per second \\(default: 800\\)."]
        pub relative_speed: Option<i32>,
        #[serde(rename = "gestureSourceType", skip_serializing_if = "Option::is_none")]
        #[doc = "Which type of input events to be generated \\(default: 'default', which queries the platform for the preferred input type\\)."]
        pub gesture_source_type: Option<::proto::input::GestureSourceType>,
    }
    impl ::traits::SerializeCdpCommand for SynthesizePinchGestureCommand {
        fn command_name(&self) -> &str {
            "Input.synthesizePinchGesture"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for SynthesizePinchGestureCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Input.synthesizePinchGesture" {
                Ok ( < SynthesizePinchGestureCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Synthesizes a pinch gesture over a time period by issuing appropriate touch events.\n\n# Command `Input.synthesizePinchGesture`\n\n*Domain Module:* [`cdp::proto::input`](index.html)  \n*Command Struct:* [`cdp::proto::input::SynthesizePinchGestureCommand`](struct.SynthesizePinchGestureCommand.html)  \n*Response Struct:* [`cdp::proto::input::SynthesizePinchGestureResponse`](struct.SynthesizePinchGestureResponse.html)"]
    pub struct SynthesizePinchGestureResponse;
    impl ::serde::Serialize for SynthesizePinchGestureResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SynthesizePinchGestureResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SynthesizePinchGestureResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SynthesizePinchGestureCommand {
        type Response = SynthesizePinchGestureResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SynthesizePinchGestureResponse {
        type Command = SynthesizePinchGestureCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Synthesizes a scroll gesture over a time period by issuing appropriate touch events.\n\n# Command `Input.synthesizeScrollGesture`\n\n*Domain Module:* [`cdp::proto::input`](index.html)  \n*Command Struct:* [`cdp::proto::input::SynthesizeScrollGestureCommand`](struct.SynthesizeScrollGestureCommand.html)  \n*Response Struct:* [`cdp::proto::input::SynthesizeScrollGestureResponse`](struct.SynthesizeScrollGestureResponse.html)"]
    pub struct SynthesizeScrollGestureCommand<'a> {
        #[serde(rename = "x")]
        #[doc = "X coordinate of the start of the gesture in CSS pixels."]
        pub x: f64,
        #[serde(rename = "y")]
        #[doc = "Y coordinate of the start of the gesture in CSS pixels."]
        pub y: f64,
        #[serde(rename = "xDistance", skip_serializing_if = "Option::is_none")]
        #[doc = "The distance to scroll along the X axis \\(positive to scroll left\\)."]
        pub x_distance: Option<f64>,
        #[serde(rename = "yDistance", skip_serializing_if = "Option::is_none")]
        #[doc = "The distance to scroll along the Y axis \\(positive to scroll up\\)."]
        pub y_distance: Option<f64>,
        #[serde(rename = "xOverscroll", skip_serializing_if = "Option::is_none")]
        #[doc = "The number of additional pixels to scroll back along the X axis, in addition to the given distance."]
        pub x_overscroll: Option<f64>,
        #[serde(rename = "yOverscroll", skip_serializing_if = "Option::is_none")]
        #[doc = "The number of additional pixels to scroll back along the Y axis, in addition to the given distance."]
        pub y_overscroll: Option<f64>,
        #[serde(rename = "preventFling", skip_serializing_if = "Option::is_none")]
        #[doc = "Prevent fling \\(default: true\\)."]
        pub prevent_fling: Option<bool>,
        #[serde(rename = "speed", skip_serializing_if = "Option::is_none")]
        #[doc = "Swipe speed in pixels per second \\(default: 800\\)."]
        pub speed: Option<i32>,
        #[serde(rename = "gestureSourceType", skip_serializing_if = "Option::is_none")]
        #[doc = "Which type of input events to be generated \\(default: 'default', which queries the platform for the preferred input type\\)."]
        pub gesture_source_type: Option<::proto::input::GestureSourceType>,
        #[serde(rename = "repeatCount", skip_serializing_if = "Option::is_none")]
        #[doc = "The number of times to repeat the gesture \\(default: 0\\)."]
        pub repeat_count: Option<i32>,
        #[serde(rename = "repeatDelayMs", skip_serializing_if = "Option::is_none")]
        #[doc = "The number of milliseconds delay between each repeat. \\(default: 250\\)."]
        pub repeat_delay_ms: Option<i32>,
        #[serde(rename = "interactionMarkerName", skip_serializing_if = "Option::is_none")]
        #[doc = "The name of the interaction markers to generate, if not empty \\(default: \"\"\\)."]
        pub interaction_marker_name: Option<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::traits::SerializeCdpCommand for SynthesizeScrollGestureCommand<'a> {
        fn command_name(&self) -> &str {
            "Input.synthesizeScrollGesture"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for SynthesizeScrollGestureCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Input.synthesizeScrollGesture" {
                Ok ( < SynthesizeScrollGestureCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Synthesizes a scroll gesture over a time period by issuing appropriate touch events.\n\n# Command `Input.synthesizeScrollGesture`\n\n*Domain Module:* [`cdp::proto::input`](index.html)  \n*Command Struct:* [`cdp::proto::input::SynthesizeScrollGestureCommand`](struct.SynthesizeScrollGestureCommand.html)  \n*Response Struct:* [`cdp::proto::input::SynthesizeScrollGestureResponse`](struct.SynthesizeScrollGestureResponse.html)"]
    pub struct SynthesizeScrollGestureResponse;
    impl ::serde::Serialize for SynthesizeScrollGestureResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SynthesizeScrollGestureResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SynthesizeScrollGestureResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SynthesizeScrollGestureCommand<'a> {
        type Response = SynthesizeScrollGestureResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SynthesizeScrollGestureResponse {
        type Command = SynthesizeScrollGestureCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Synthesizes a tap gesture over a time period by issuing appropriate touch events.\n\n# Command `Input.synthesizeTapGesture`\n\n*Domain Module:* [`cdp::proto::input`](index.html)  \n*Command Struct:* [`cdp::proto::input::SynthesizeTapGestureCommand`](struct.SynthesizeTapGestureCommand.html)  \n*Response Struct:* [`cdp::proto::input::SynthesizeTapGestureResponse`](struct.SynthesizeTapGestureResponse.html)"]
    pub struct SynthesizeTapGestureCommand {
        #[serde(rename = "x")]
        #[doc = "X coordinate of the start of the gesture in CSS pixels."]
        pub x: f64,
        #[serde(rename = "y")]
        #[doc = "Y coordinate of the start of the gesture in CSS pixels."]
        pub y: f64,
        #[serde(rename = "duration", skip_serializing_if = "Option::is_none")]
        #[doc = "Duration between touchdown and touchup events in ms \\(default: 50\\)."]
        pub duration: Option<i32>,
        #[serde(rename = "tapCount", skip_serializing_if = "Option::is_none")]
        #[doc = "Number of times to perform the tap \\(e.g. 2 for double tap, default: 1\\)."]
        pub tap_count: Option<i32>,
        #[serde(rename = "gestureSourceType", skip_serializing_if = "Option::is_none")]
        #[doc = "Which type of input events to be generated \\(default: 'default', which queries the platform for the preferred input type\\)."]
        pub gesture_source_type: Option<::proto::input::GestureSourceType>,
    }
    impl ::traits::SerializeCdpCommand for SynthesizeTapGestureCommand {
        fn command_name(&self) -> &str {
            "Input.synthesizeTapGesture"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for SynthesizeTapGestureCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Input.synthesizeTapGesture" {
                Ok ( < SynthesizeTapGestureCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Synthesizes a tap gesture over a time period by issuing appropriate touch events.\n\n# Command `Input.synthesizeTapGesture`\n\n*Domain Module:* [`cdp::proto::input`](index.html)  \n*Command Struct:* [`cdp::proto::input::SynthesizeTapGestureCommand`](struct.SynthesizeTapGestureCommand.html)  \n*Response Struct:* [`cdp::proto::input::SynthesizeTapGestureResponse`](struct.SynthesizeTapGestureResponse.html)"]
    pub struct SynthesizeTapGestureResponse;
    impl ::serde::Serialize for SynthesizeTapGestureResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SynthesizeTapGestureResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SynthesizeTapGestureResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SynthesizeTapGestureCommand {
        type Response = SynthesizeTapGestureResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SynthesizeTapGestureResponse {
        type Command = SynthesizeTapGestureCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\nUsed in the type of [`cdp::proto::input::TouchPoint::state`](struct.TouchPoint.html#structfield.state)."]
    pub enum TouchPointState {
        #[serde(rename = "touchPressed")]
        #[doc = "Represented as `\"touchPressed\"`."]
        TouchPressed,
        #[serde(rename = "touchReleased")]
        #[doc = "Represented as `\"touchReleased\"`."]
        TouchReleased,
        #[serde(rename = "touchMoved")]
        #[doc = "Represented as `\"touchMoved\"`."]
        TouchMoved,
        #[serde(rename = "touchStationary")]
        #[doc = "Represented as `\"touchStationary\"`."]
        TouchStationary,
        #[serde(rename = "touchCancelled")]
        #[doc = "Represented as `\"touchCancelled\"`."]
        TouchCancelled,
    }
    impl TouchPointState {
        pub const ENUM_VALUES: &'static [TouchPointState] = &[
            TouchPointState::TouchPressed,
            TouchPointState::TouchReleased,
            TouchPointState::TouchMoved,
            TouchPointState::TouchStationary,
            TouchPointState::TouchCancelled,
        ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "touchPressed",
            "touchReleased",
            "touchMoved",
            "touchStationary",
            "touchCancelled",
        ];
    }
    impl ::std::str::FromStr for TouchPointState {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "touchPressed" => Ok(TouchPointState::TouchPressed),
                "touchReleased" => Ok(TouchPointState::TouchReleased),
                "touchMoved" => Ok(TouchPointState::TouchMoved),
                "touchStationary" => Ok(TouchPointState::TouchStationary),
                "touchCancelled" => Ok(TouchPointState::TouchCancelled),
                _ => Err(::proto::ParseEnumError {
                    expected: TouchPointState::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for TouchPointState {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    TouchPointState::TouchPressed => "touchPressed",
                    TouchPointState::TouchReleased => "touchReleased",
                    TouchPointState::TouchMoved => "touchMoved",
                    TouchPointState::TouchStationary => "touchStationary",
                    TouchPointState::TouchCancelled => "touchCancelled",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>"]
    pub struct TouchPoint {
        #[serde(rename = "state")]
        #[doc = "State of the touch point."]
        pub state: ::proto::input::TouchPointState,
        #[serde(rename = "x")]
        #[doc = "X coordinate of the event relative to the main frame's viewport."]
        pub x: i32,
        #[serde(rename = "y")]
        #[doc = "Y coordinate of the event relative to the main frame's viewport. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport."]
        pub y: i32,
        #[serde(rename = "radiusX", skip_serializing_if = "Option::is_none")]
        #[doc = "X radius of the touch area \\(default: 1\\)."]
        pub radius_x: Option<i32>,
        #[serde(rename = "radiusY", skip_serializing_if = "Option::is_none")]
        #[doc = "Y radius of the touch area \\(default: 1\\)."]
        pub radius_y: Option<i32>,
        #[serde(rename = "rotationAngle", skip_serializing_if = "Option::is_none")]
        #[doc = "Rotation angle \\(default: 0.0\\)."]
        pub rotation_angle: Option<f64>,
        #[serde(rename = "force", skip_serializing_if = "Option::is_none")]
        #[doc = "Force \\(default: 1.0\\)."]
        pub force: Option<f64>,
        #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
        #[doc = "Identifier used to track touch sources between events, must be unique within an event."]
        pub id: Option<f64>,
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>"]
    pub enum GestureSourceType {
        #[serde(rename = "default")]
        #[doc = "Represented as `\"default\"`."]
        Default,
        #[serde(rename = "touch")]
        #[doc = "Represented as `\"touch\"`."]
        Touch,
        #[serde(rename = "mouse")]
        #[doc = "Represented as `\"mouse\"`."]
        Mouse,
    }
    impl GestureSourceType {
        pub const ENUM_VALUES: &'static [GestureSourceType] = &[
            GestureSourceType::Default,
            GestureSourceType::Touch,
            GestureSourceType::Mouse,
        ];
        pub const STR_VALUES: &'static [&'static str] = &["default", "touch", "mouse"];
    }
    impl ::std::str::FromStr for GestureSourceType {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "default" => Ok(GestureSourceType::Default),
                "touch" => Ok(GestureSourceType::Touch),
                "mouse" => Ok(GestureSourceType::Mouse),
                _ => Err(::proto::ParseEnumError {
                    expected: GestureSourceType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for GestureSourceType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    GestureSourceType::Default => "default",
                    GestureSourceType::Touch => "touch",
                    GestureSourceType::Mouse => "mouse",
                }
            )
        }
    }
    #[doc = "UTC time in seconds, counted from January 1, 1970."]
    pub type TimeSinceEpoch = f64;
}
#[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# LayerTree\n\n## Commands\n\n- [`LayerTree.enable`](struct.EnableCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Enables compositing tree inspection.\n- [`LayerTree.disable`](struct.DisableCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Disables compositing tree inspection.\n- [`LayerTree.compositingReasons`](struct.CompositingReasonsCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Provides the reasons why the given layer was composited.\n- [`LayerTree.makeSnapshot`](struct.MakeSnapshotCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns the layer snapshot identifier.\n- [`LayerTree.loadSnapshot`](struct.LoadSnapshotCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns the snapshot identifier.\n- [`LayerTree.releaseSnapshot`](struct.ReleaseSnapshotCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Releases layer snapshot captured by the back-end.\n- [`LayerTree.profileSnapshot`](struct.ProfileSnapshotCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`LayerTree.replaySnapshot`](struct.ReplaySnapshotCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Replays the layer snapshot and returns the resulting bitmap.\n- [`LayerTree.snapshotCommandLog`](struct.SnapshotCommandLogCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Replays the layer snapshot and returns canvas log.\n\n## Events\n\n- [`LayerTree.layerTreeDidChange`](struct.LayerTreeDidChangeEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`LayerTree.layerPainted`](struct.LayerPaintedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n##Types\n\n- [`LayerId`](type.LayerId.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Unique Layer identifier.\n- [`SnapshotId`](type.SnapshotId.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Unique snapshot identifier.\n- [`ScrollRect`](struct.ScrollRect.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Rectangle where scrolling happens on the main thread.\n- [`PictureTile`](struct.PictureTile.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Serialized fragment of layer picture along with its offset within the layer.\n- [`Layer`](struct.Layer.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Information about a compositing layer.\n- [`PaintProfile`](type.PaintProfile.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Array of timings, one per paint step.\n"]
pub mod layer_tree {
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables compositing tree inspection.\n\n# Command `LayerTree.enable`\n\n*Domain Module:* [`cdp::proto::layer_tree`](index.html)  \n*Command Struct:* [`cdp::proto::layer_tree::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::proto::layer_tree::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableCommand;
    impl ::serde::Serialize for EnableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for EnableCommand {
        fn command_name(&self) -> &str {
            "LayerTree.enable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for EnableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "LayerTree.enable" {
                Ok(
                    <EnableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables compositing tree inspection.\n\n# Command `LayerTree.enable`\n\n*Domain Module:* [`cdp::proto::layer_tree`](index.html)  \n*Command Struct:* [`cdp::proto::layer_tree::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::proto::layer_tree::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableResponse;
    impl ::serde::Serialize for EnableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for EnableCommand {
        type Response = EnableResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for EnableResponse {
        type Command = EnableCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Disables compositing tree inspection.\n\n# Command `LayerTree.disable`\n\n*Domain Module:* [`cdp::proto::layer_tree`](index.html)  \n*Command Struct:* [`cdp::proto::layer_tree::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::proto::layer_tree::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableCommand;
    impl ::serde::Serialize for DisableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for DisableCommand {
        fn command_name(&self) -> &str {
            "LayerTree.disable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for DisableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "LayerTree.disable" {
                Ok(
                    <DisableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Disables compositing tree inspection.\n\n# Command `LayerTree.disable`\n\n*Domain Module:* [`cdp::proto::layer_tree`](index.html)  \n*Command Struct:* [`cdp::proto::layer_tree::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::proto::layer_tree::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableResponse;
    impl ::serde::Serialize for DisableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for DisableCommand {
        type Response = DisableResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for DisableResponse {
        type Command = DisableCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Provides the reasons why the given layer was composited.\n\n# Command `LayerTree.compositingReasons`\n\n*Domain Module:* [`cdp::proto::layer_tree`](index.html)  \n*Command Struct:* [`cdp::proto::layer_tree::CompositingReasonsCommand`](struct.CompositingReasonsCommand.html)  \n*Response Struct:* [`cdp::proto::layer_tree::CompositingReasonsResponse`](struct.CompositingReasonsResponse.html)"]
    pub struct CompositingReasonsCommand<'a> {
        #[serde(rename = "layerId")]
        #[doc = "The id of the layer for which we want to get the reasons it was composited."]
        pub layer_id: ::proto::layer_tree::LayerId<'a>,
    }
    impl<'a> ::traits::SerializeCdpCommand for CompositingReasonsCommand<'a> {
        fn command_name(&self) -> &str {
            "LayerTree.compositingReasons"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for CompositingReasonsCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "LayerTree.compositingReasons" {
                Ok ( < CompositingReasonsCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Provides the reasons why the given layer was composited.\n\n# Command `LayerTree.compositingReasons`\n\n*Domain Module:* [`cdp::proto::layer_tree`](index.html)  \n*Command Struct:* [`cdp::proto::layer_tree::CompositingReasonsCommand`](struct.CompositingReasonsCommand.html)  \n*Response Struct:* [`cdp::proto::layer_tree::CompositingReasonsResponse`](struct.CompositingReasonsResponse.html)"]
    pub struct CompositingReasonsResponse<'a> {
        #[serde(rename = "compositingReasons")]
        #[doc = "A list of strings specifying reasons for the given layer to become composited."]
        pub compositing_reasons: Vec<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for CompositingReasonsCommand<'a> {
        type Response = CompositingReasonsResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for CompositingReasonsResponse<'a> {
        type Command = CompositingReasonsCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns the layer snapshot identifier.\n\n# Command `LayerTree.makeSnapshot`\n\n*Domain Module:* [`cdp::proto::layer_tree`](index.html)  \n*Command Struct:* [`cdp::proto::layer_tree::MakeSnapshotCommand`](struct.MakeSnapshotCommand.html)  \n*Response Struct:* [`cdp::proto::layer_tree::MakeSnapshotResponse`](struct.MakeSnapshotResponse.html)"]
    pub struct MakeSnapshotCommand<'a> {
        #[serde(rename = "layerId")]
        #[doc = "The id of the layer."]
        pub layer_id: ::proto::layer_tree::LayerId<'a>,
    }
    impl<'a> ::traits::SerializeCdpCommand for MakeSnapshotCommand<'a> {
        fn command_name(&self) -> &str {
            "LayerTree.makeSnapshot"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for MakeSnapshotCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "LayerTree.makeSnapshot" {
                Ok(
                    <MakeSnapshotCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns the layer snapshot identifier.\n\n# Command `LayerTree.makeSnapshot`\n\n*Domain Module:* [`cdp::proto::layer_tree`](index.html)  \n*Command Struct:* [`cdp::proto::layer_tree::MakeSnapshotCommand`](struct.MakeSnapshotCommand.html)  \n*Response Struct:* [`cdp::proto::layer_tree::MakeSnapshotResponse`](struct.MakeSnapshotResponse.html)"]
    pub struct MakeSnapshotResponse<'a> {
        #[serde(rename = "snapshotId")]
        #[doc = "The id of the layer snapshot."]
        pub snapshot_id: ::proto::layer_tree::SnapshotId<'a>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for MakeSnapshotCommand<'a> {
        type Response = MakeSnapshotResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for MakeSnapshotResponse<'a> {
        type Command = MakeSnapshotCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns the snapshot identifier.\n\n# Command `LayerTree.loadSnapshot`\n\n*Domain Module:* [`cdp::proto::layer_tree`](index.html)  \n*Command Struct:* [`cdp::proto::layer_tree::LoadSnapshotCommand`](struct.LoadSnapshotCommand.html)  \n*Response Struct:* [`cdp::proto::layer_tree::LoadSnapshotResponse`](struct.LoadSnapshotResponse.html)"]
    pub struct LoadSnapshotCommand<'a> {
        #[serde(rename = "tiles")]
        #[doc = "An array of tiles composing the snapshot."]
        pub tiles: Vec<::proto::layer_tree::PictureTile<'a>>,
    }
    impl<'a> ::traits::SerializeCdpCommand for LoadSnapshotCommand<'a> {
        fn command_name(&self) -> &str {
            "LayerTree.loadSnapshot"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for LoadSnapshotCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "LayerTree.loadSnapshot" {
                Ok(
                    <LoadSnapshotCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns the snapshot identifier.\n\n# Command `LayerTree.loadSnapshot`\n\n*Domain Module:* [`cdp::proto::layer_tree`](index.html)  \n*Command Struct:* [`cdp::proto::layer_tree::LoadSnapshotCommand`](struct.LoadSnapshotCommand.html)  \n*Response Struct:* [`cdp::proto::layer_tree::LoadSnapshotResponse`](struct.LoadSnapshotResponse.html)"]
    pub struct LoadSnapshotResponse<'a> {
        #[serde(rename = "snapshotId")]
        #[doc = "The id of the snapshot."]
        pub snapshot_id: ::proto::layer_tree::SnapshotId<'a>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for LoadSnapshotCommand<'a> {
        type Response = LoadSnapshotResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for LoadSnapshotResponse<'a> {
        type Command = LoadSnapshotCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Releases layer snapshot captured by the back-end.\n\n# Command `LayerTree.releaseSnapshot`\n\n*Domain Module:* [`cdp::proto::layer_tree`](index.html)  \n*Command Struct:* [`cdp::proto::layer_tree::ReleaseSnapshotCommand`](struct.ReleaseSnapshotCommand.html)  \n*Response Struct:* [`cdp::proto::layer_tree::ReleaseSnapshotResponse`](struct.ReleaseSnapshotResponse.html)"]
    pub struct ReleaseSnapshotCommand<'a> {
        #[serde(rename = "snapshotId")]
        #[doc = "The id of the layer snapshot."]
        pub snapshot_id: ::proto::layer_tree::SnapshotId<'a>,
    }
    impl<'a> ::traits::SerializeCdpCommand for ReleaseSnapshotCommand<'a> {
        fn command_name(&self) -> &str {
            "LayerTree.releaseSnapshot"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for ReleaseSnapshotCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "LayerTree.releaseSnapshot" {
                Ok(
                    <ReleaseSnapshotCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Releases layer snapshot captured by the back-end.\n\n# Command `LayerTree.releaseSnapshot`\n\n*Domain Module:* [`cdp::proto::layer_tree`](index.html)  \n*Command Struct:* [`cdp::proto::layer_tree::ReleaseSnapshotCommand`](struct.ReleaseSnapshotCommand.html)  \n*Response Struct:* [`cdp::proto::layer_tree::ReleaseSnapshotResponse`](struct.ReleaseSnapshotResponse.html)"]
    pub struct ReleaseSnapshotResponse;
    impl ::serde::Serialize for ReleaseSnapshotResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ReleaseSnapshotResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ReleaseSnapshotResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for ReleaseSnapshotCommand<'a> {
        type Response = ReleaseSnapshotResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for ReleaseSnapshotResponse {
        type Command = ReleaseSnapshotCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `LayerTree.profileSnapshot`\n\n*Domain Module:* [`cdp::proto::layer_tree`](index.html)  \n*Command Struct:* [`cdp::proto::layer_tree::ProfileSnapshotCommand`](struct.ProfileSnapshotCommand.html)  \n*Response Struct:* [`cdp::proto::layer_tree::ProfileSnapshotResponse`](struct.ProfileSnapshotResponse.html)"]
    pub struct ProfileSnapshotCommand<'a> {
        #[serde(rename = "snapshotId")]
        #[doc = "The id of the layer snapshot."]
        pub snapshot_id: ::proto::layer_tree::SnapshotId<'a>,
        #[serde(rename = "minRepeatCount", skip_serializing_if = "Option::is_none")]
        #[doc = "The maximum number of times to replay the snapshot \\(1, if not specified\\)."]
        pub min_repeat_count: Option<i32>,
        #[serde(rename = "minDuration", skip_serializing_if = "Option::is_none")]
        #[doc = "The minimum duration \\(in seconds\\) to replay the snapshot."]
        pub min_duration: Option<f64>,
        #[serde(rename = "clipRect", skip_serializing_if = "Option::is_none")]
        #[doc = "The clip rectangle to apply when replaying the snapshot."]
        pub clip_rect: Option<::proto::dom::Rect>,
    }
    impl<'a> ::traits::SerializeCdpCommand for ProfileSnapshotCommand<'a> {
        fn command_name(&self) -> &str {
            "LayerTree.profileSnapshot"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for ProfileSnapshotCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "LayerTree.profileSnapshot" {
                Ok(
                    <ProfileSnapshotCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `LayerTree.profileSnapshot`\n\n*Domain Module:* [`cdp::proto::layer_tree`](index.html)  \n*Command Struct:* [`cdp::proto::layer_tree::ProfileSnapshotCommand`](struct.ProfileSnapshotCommand.html)  \n*Response Struct:* [`cdp::proto::layer_tree::ProfileSnapshotResponse`](struct.ProfileSnapshotResponse.html)"]
    pub struct ProfileSnapshotResponse {
        #[serde(rename = "timings")]
        #[doc = "The array of paint profiles, one per run."]
        pub timings: Vec<::proto::layer_tree::PaintProfile>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for ProfileSnapshotCommand<'a> {
        type Response = ProfileSnapshotResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for ProfileSnapshotResponse {
        type Command = ProfileSnapshotCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Replays the layer snapshot and returns the resulting bitmap.\n\n# Command `LayerTree.replaySnapshot`\n\n*Domain Module:* [`cdp::proto::layer_tree`](index.html)  \n*Command Struct:* [`cdp::proto::layer_tree::ReplaySnapshotCommand`](struct.ReplaySnapshotCommand.html)  \n*Response Struct:* [`cdp::proto::layer_tree::ReplaySnapshotResponse`](struct.ReplaySnapshotResponse.html)"]
    pub struct ReplaySnapshotCommand<'a> {
        #[serde(rename = "snapshotId")]
        #[doc = "The id of the layer snapshot."]
        pub snapshot_id: ::proto::layer_tree::SnapshotId<'a>,
        #[serde(rename = "fromStep", skip_serializing_if = "Option::is_none")]
        #[doc = "The first step to replay from \\(replay from the very start if not specified\\)."]
        pub from_step: Option<i32>,
        #[serde(rename = "toStep", skip_serializing_if = "Option::is_none")]
        #[doc = "The last step to replay to \\(replay till the end if not specified\\)."]
        pub to_step: Option<i32>,
        #[serde(rename = "scale", skip_serializing_if = "Option::is_none")]
        #[doc = "The scale to apply while replaying \\(defaults to 1\\)."]
        pub scale: Option<f64>,
    }
    impl<'a> ::traits::SerializeCdpCommand for ReplaySnapshotCommand<'a> {
        fn command_name(&self) -> &str {
            "LayerTree.replaySnapshot"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for ReplaySnapshotCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "LayerTree.replaySnapshot" {
                Ok(
                    <ReplaySnapshotCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Replays the layer snapshot and returns the resulting bitmap.\n\n# Command `LayerTree.replaySnapshot`\n\n*Domain Module:* [`cdp::proto::layer_tree`](index.html)  \n*Command Struct:* [`cdp::proto::layer_tree::ReplaySnapshotCommand`](struct.ReplaySnapshotCommand.html)  \n*Response Struct:* [`cdp::proto::layer_tree::ReplaySnapshotResponse`](struct.ReplaySnapshotResponse.html)"]
    pub struct ReplaySnapshotResponse<'a> {
        #[serde(rename = "dataURL")]
        #[doc = "A data: URL for resulting image."]
        pub data_url: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for ReplaySnapshotCommand<'a> {
        type Response = ReplaySnapshotResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for ReplaySnapshotResponse<'a> {
        type Command = ReplaySnapshotCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Replays the layer snapshot and returns canvas log.\n\n# Command `LayerTree.snapshotCommandLog`\n\n*Domain Module:* [`cdp::proto::layer_tree`](index.html)  \n*Command Struct:* [`cdp::proto::layer_tree::SnapshotCommandLogCommand`](struct.SnapshotCommandLogCommand.html)  \n*Response Struct:* [`cdp::proto::layer_tree::SnapshotCommandLogResponse`](struct.SnapshotCommandLogResponse.html)"]
    pub struct SnapshotCommandLogCommand<'a> {
        #[serde(rename = "snapshotId")]
        #[doc = "The id of the layer snapshot."]
        pub snapshot_id: ::proto::layer_tree::SnapshotId<'a>,
    }
    impl<'a> ::traits::SerializeCdpCommand for SnapshotCommandLogCommand<'a> {
        fn command_name(&self) -> &str {
            "LayerTree.snapshotCommandLog"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for SnapshotCommandLogCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "LayerTree.snapshotCommandLog" {
                Ok ( < SnapshotCommandLogCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Replays the layer snapshot and returns canvas log.\n\n# Command `LayerTree.snapshotCommandLog`\n\n*Domain Module:* [`cdp::proto::layer_tree`](index.html)  \n*Command Struct:* [`cdp::proto::layer_tree::SnapshotCommandLogCommand`](struct.SnapshotCommandLogCommand.html)  \n*Response Struct:* [`cdp::proto::layer_tree::SnapshotCommandLogResponse`](struct.SnapshotCommandLogResponse.html)"]
    pub struct SnapshotCommandLogResponse {
        #[serde(rename = "commandLog")]
        #[doc = "The array of canvas function calls."]
        pub command_log: Vec<::proto::Empty>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SnapshotCommandLogCommand<'a> {
        type Response = SnapshotCommandLogResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SnapshotCommandLogResponse {
        type Command = SnapshotCommandLogCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Event `LayerTree.layerTreeDidChange`\n\n*Domain Module:* [`cdp::proto::layer_tree`](index.html)  \n*Event Struct:* [`cdp::proto::layer_tree::LayerTreeDidChangeEvent`](struct.LayerTreeDidChangeEvent.html)"]
    pub struct LayerTreeDidChangeEvent<'a> {
        #[serde(rename = "layers", skip_serializing_if = "Option::is_none")]
        #[doc = "Layer tree, absent if not in the comspositing mode."]
        pub layers: Option<Vec<::proto::layer_tree::Layer<'a>>>,
    }
    impl<'a> ::traits::SerializeCdpEvent for LayerTreeDidChangeEvent<'a> {
        fn event_name(&self) -> &str {
            "LayerTree.layerTreeDidChange"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for LayerTreeDidChangeEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "LayerTree.layerTreeDidChange" {
                Ok ( < LayerTreeDidChangeEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Event `LayerTree.layerPainted`\n\n*Domain Module:* [`cdp::proto::layer_tree`](index.html)  \n*Event Struct:* [`cdp::proto::layer_tree::LayerPaintedEvent`](struct.LayerPaintedEvent.html)"]
    pub struct LayerPaintedEvent<'a> {
        #[serde(rename = "layerId")]
        #[doc = "The id of the painted layer."]
        pub layer_id: ::proto::layer_tree::LayerId<'a>,
        #[serde(rename = "clip")]
        #[doc = "Clip rectangle."]
        pub clip: ::proto::dom::Rect,
    }
    impl<'a> ::traits::SerializeCdpEvent for LayerPaintedEvent<'a> {
        fn event_name(&self) -> &str {
            "LayerTree.layerPainted"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for LayerPaintedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "LayerTree.layerPainted" {
                Ok(
                    <LayerPaintedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Unique Layer identifier."]
    pub type LayerId<'a> = ::std::borrow::Cow<'a, str>;
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Unique snapshot identifier."]
    pub type SnapshotId<'a> = ::std::borrow::Cow<'a, str>;
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\nUsed in the type of [`cdp::proto::layer_tree::ScrollRect::ty`](struct.ScrollRect.html#structfield.ty)."]
    pub enum ScrollRectType {
        #[serde(rename = "RepaintsOnScroll")]
        #[doc = "Represented as `\"RepaintsOnScroll\"`."]
        RepaintsOnScroll,
        #[serde(rename = "TouchEventHandler")]
        #[doc = "Represented as `\"TouchEventHandler\"`."]
        TouchEventHandler,
        #[serde(rename = "WheelEventHandler")]
        #[doc = "Represented as `\"WheelEventHandler\"`."]
        WheelEventHandler,
    }
    impl ScrollRectType {
        pub const ENUM_VALUES: &'static [ScrollRectType] = &[
            ScrollRectType::RepaintsOnScroll,
            ScrollRectType::TouchEventHandler,
            ScrollRectType::WheelEventHandler,
        ];
        pub const STR_VALUES: &'static [&'static str] =
            &["RepaintsOnScroll", "TouchEventHandler", "WheelEventHandler"];
    }
    impl ::std::str::FromStr for ScrollRectType {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "RepaintsOnScroll" => Ok(ScrollRectType::RepaintsOnScroll),
                "TouchEventHandler" => Ok(ScrollRectType::TouchEventHandler),
                "WheelEventHandler" => Ok(ScrollRectType::WheelEventHandler),
                _ => Err(::proto::ParseEnumError {
                    expected: ScrollRectType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for ScrollRectType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    ScrollRectType::RepaintsOnScroll => "RepaintsOnScroll",
                    ScrollRectType::TouchEventHandler => "TouchEventHandler",
                    ScrollRectType::WheelEventHandler => "WheelEventHandler",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Rectangle where scrolling happens on the main thread."]
    pub struct ScrollRect {
        #[serde(rename = "rect")]
        #[doc = "Rectangle itself."]
        pub rect: ::proto::dom::Rect,
        #[serde(rename = "type")]
        #[doc = "Reason for rectangle to force scrolling on the main thread"]
        pub ty: ::proto::layer_tree::ScrollRectType,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Serialized fragment of layer picture along with its offset within the layer."]
    pub struct PictureTile<'a> {
        #[serde(rename = "x")]
        #[doc = "Offset from owning layer left boundary"]
        pub x: f64,
        #[serde(rename = "y")]
        #[doc = "Offset from owning layer top boundary"]
        pub y: f64,
        #[serde(rename = "picture")]
        #[doc = "Base64-encoded snapshot data."]
        pub picture: ::std::borrow::Cow<'a, str>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Information about a compositing layer."]
    pub struct Layer<'a> {
        #[serde(rename = "layerId")]
        #[doc = "The unique id for this layer."]
        pub layer_id: ::proto::layer_tree::LayerId<'a>,
        #[serde(rename = "parentLayerId", skip_serializing_if = "Option::is_none")]
        #[doc = "The id of parent \\(not present for root\\)."]
        pub parent_layer_id: Option<::proto::layer_tree::LayerId<'a>>,
        #[serde(rename = "backendNodeId", skip_serializing_if = "Option::is_none")]
        #[doc = "The backend id for the node associated with this layer."]
        pub backend_node_id: Option<::proto::dom::BackendNodeId>,
        #[serde(rename = "offsetX")]
        #[doc = "Offset from parent layer, X coordinate."]
        pub offset_x: f64,
        #[serde(rename = "offsetY")]
        #[doc = "Offset from parent layer, Y coordinate."]
        pub offset_y: f64,
        #[serde(rename = "width")]
        #[doc = "Layer width."]
        pub width: f64,
        #[serde(rename = "height")]
        #[doc = "Layer height."]
        pub height: f64,
        #[serde(rename = "transform", skip_serializing_if = "Option::is_none")]
        #[doc = "Transformation matrix for layer, default is identity matrix"]
        pub transform: Option<[f64; 16usize]>,
        #[serde(rename = "anchorX", skip_serializing_if = "Option::is_none")]
        #[doc = "Transform anchor point X, absent if no transform specified"]
        pub anchor_x: Option<f64>,
        #[serde(rename = "anchorY", skip_serializing_if = "Option::is_none")]
        #[doc = "Transform anchor point Y, absent if no transform specified"]
        pub anchor_y: Option<f64>,
        #[serde(rename = "anchorZ", skip_serializing_if = "Option::is_none")]
        #[doc = "Transform anchor point Z, absent if no transform specified"]
        pub anchor_z: Option<f64>,
        #[serde(rename = "paintCount")]
        #[doc = "Indicates how many time this layer has painted."]
        pub paint_count: i32,
        #[serde(rename = "drawsContent")]
        #[doc = "Indicates whether this layer hosts any content, rather than being used for transform/scrolling purposes only."]
        pub draws_content: bool,
        #[serde(rename = "invisible", skip_serializing_if = "Option::is_none")]
        #[doc = "Set if layer is not visible."]
        pub invisible: Option<bool>,
        #[serde(rename = "scrollRects", skip_serializing_if = "Option::is_none")]
        #[doc = "Rectangles scrolling on main thread only."]
        pub scroll_rects: Option<Vec<::proto::layer_tree::ScrollRect>>,
    }
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Array of timings, one per paint step."]
    pub type PaintProfile = Vec<f64>;
}
#[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# DeviceOrientation\n\n## Commands\n\n- [`DeviceOrientation.setDeviceOrientationOverride`](struct.SetDeviceOrientationOverrideCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Overrides the Device Orientation.\n- [`DeviceOrientation.clearDeviceOrientationOverride`](struct.ClearDeviceOrientationOverrideCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Clears the overridden Device Orientation.\n"]
pub mod device_orientation {
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Overrides the Device Orientation.\n\n# Command `DeviceOrientation.setDeviceOrientationOverride`\n\n*Domain Module:* [`cdp::proto::device_orientation`](index.html)  \n*Command Struct:* [`cdp::proto::device_orientation::SetDeviceOrientationOverrideCommand`](struct.SetDeviceOrientationOverrideCommand.html)  \n*Response Struct:* [`cdp::proto::device_orientation::SetDeviceOrientationOverrideResponse`](struct.SetDeviceOrientationOverrideResponse.html)"]
    pub struct SetDeviceOrientationOverrideCommand {
        #[serde(rename = "alpha")]
        #[doc = "Mock alpha"]
        pub alpha: f64,
        #[serde(rename = "beta")]
        #[doc = "Mock beta"]
        pub beta: f64,
        #[serde(rename = "gamma")]
        #[doc = "Mock gamma"]
        pub gamma: f64,
    }
    impl ::traits::SerializeCdpCommand for SetDeviceOrientationOverrideCommand {
        fn command_name(&self) -> &str {
            "DeviceOrientation.setDeviceOrientationOverride"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for SetDeviceOrientationOverrideCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DeviceOrientation.setDeviceOrientationOverride" {
                Ok ( < SetDeviceOrientationOverrideCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Overrides the Device Orientation.\n\n# Command `DeviceOrientation.setDeviceOrientationOverride`\n\n*Domain Module:* [`cdp::proto::device_orientation`](index.html)  \n*Command Struct:* [`cdp::proto::device_orientation::SetDeviceOrientationOverrideCommand`](struct.SetDeviceOrientationOverrideCommand.html)  \n*Response Struct:* [`cdp::proto::device_orientation::SetDeviceOrientationOverrideResponse`](struct.SetDeviceOrientationOverrideResponse.html)"]
    pub struct SetDeviceOrientationOverrideResponse;
    impl ::serde::Serialize for SetDeviceOrientationOverrideResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetDeviceOrientationOverrideResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetDeviceOrientationOverrideResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetDeviceOrientationOverrideCommand {
        type Response = SetDeviceOrientationOverrideResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetDeviceOrientationOverrideResponse {
        type Command = SetDeviceOrientationOverrideCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Clears the overridden Device Orientation.\n\n# Command `DeviceOrientation.clearDeviceOrientationOverride`\n\n*Domain Module:* [`cdp::proto::device_orientation`](index.html)  \n*Command Struct:* [`cdp::proto::device_orientation::ClearDeviceOrientationOverrideCommand`](struct.ClearDeviceOrientationOverrideCommand.html)  \n*Response Struct:* [`cdp::proto::device_orientation::ClearDeviceOrientationOverrideResponse`](struct.ClearDeviceOrientationOverrideResponse.html)"]
    pub struct ClearDeviceOrientationOverrideCommand;
    impl ::serde::Serialize for ClearDeviceOrientationOverrideCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ClearDeviceOrientationOverrideCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ClearDeviceOrientationOverrideCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for ClearDeviceOrientationOverrideCommand {
        fn command_name(&self) -> &str {
            "DeviceOrientation.clearDeviceOrientationOverride"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for ClearDeviceOrientationOverrideCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DeviceOrientation.clearDeviceOrientationOverride" {
                Ok ( < ClearDeviceOrientationOverrideCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Clears the overridden Device Orientation.\n\n# Command `DeviceOrientation.clearDeviceOrientationOverride`\n\n*Domain Module:* [`cdp::proto::device_orientation`](index.html)  \n*Command Struct:* [`cdp::proto::device_orientation::ClearDeviceOrientationOverrideCommand`](struct.ClearDeviceOrientationOverrideCommand.html)  \n*Response Struct:* [`cdp::proto::device_orientation::ClearDeviceOrientationOverrideResponse`](struct.ClearDeviceOrientationOverrideResponse.html)"]
    pub struct ClearDeviceOrientationOverrideResponse;
    impl ::serde::Serialize for ClearDeviceOrientationOverrideResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ClearDeviceOrientationOverrideResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ClearDeviceOrientationOverrideResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for ClearDeviceOrientationOverrideCommand {
        type Response = ClearDeviceOrientationOverrideResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for ClearDeviceOrientationOverrideResponse {
        type Command = ClearDeviceOrientationOverrideCommand;
    }
}
#[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Tracing\n\n## Commands\n\n- [`Tracing.start`](struct.StartCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Start trace events collection.\n- [`Tracing.end`](struct.EndCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Stop trace events collection.\n- [`Tracing.getCategories`](struct.GetCategoriesCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Gets supported tracing categories.\n- [`Tracing.requestMemoryDump`](struct.RequestMemoryDumpCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Request a global memory dump.\n- [`Tracing.recordClockSyncMarker`](struct.RecordClockSyncMarkerCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Record a clock sync marker in the trace.\n\n## Events\n\n- [`Tracing.dataCollected`](struct.DataCollectedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Contains an bucket of collected trace events. When tracing is stopped collected events will be send as a sequence of dataCollected events followed by tracingComplete event.\n- [`Tracing.tracingComplete`](struct.TracingCompleteEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Signals that tracing is stopped and there is no trace buffers pending flush, all data were delivered via dataCollected events.\n- [`Tracing.bufferUsage`](struct.BufferUsageEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n##Types\n\n- [`MemoryDumpConfig`](struct.MemoryDumpConfig.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Configuration for memory dump. Used only when \"memory-infra\" category is enabled.\n- [`TraceConfig`](struct.TraceConfig.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n"]
pub mod tracing {
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\nUsed in the type of [`cdp::proto::tracing::StartCommand::transfer_mode`](struct.StartCommand.html#structfield.transfer_mode)."]
    pub enum StartCommandTransferMode {
        #[serde(rename = "ReportEvents")]
        #[doc = "Represented as `\"ReportEvents\"`."]
        ReportEvents,
        #[serde(rename = "ReturnAsStream")]
        #[doc = "Represented as `\"ReturnAsStream\"`."]
        ReturnAsStream,
    }
    impl StartCommandTransferMode {
        pub const ENUM_VALUES: &'static [StartCommandTransferMode] =
            &[
                StartCommandTransferMode::ReportEvents,
                StartCommandTransferMode::ReturnAsStream,
            ];
        pub const STR_VALUES: &'static [&'static str] = &["ReportEvents", "ReturnAsStream"];
    }
    impl ::std::str::FromStr for StartCommandTransferMode {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "ReportEvents" => Ok(StartCommandTransferMode::ReportEvents),
                "ReturnAsStream" => Ok(StartCommandTransferMode::ReturnAsStream),
                _ => Err(::proto::ParseEnumError {
                    expected: StartCommandTransferMode::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for StartCommandTransferMode {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    StartCommandTransferMode::ReportEvents => "ReportEvents",
                    StartCommandTransferMode::ReturnAsStream => "ReturnAsStream",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Start trace events collection.\n\n# Command `Tracing.start`\n\n*Domain Module:* [`cdp::proto::tracing`](index.html)  \n*Command Struct:* [`cdp::proto::tracing::StartCommand`](struct.StartCommand.html)  \n*Response Struct:* [`cdp::proto::tracing::StartResponse`](struct.StartResponse.html)"]
    pub struct StartCommand<'a> {
        #[serde(rename = "categories", skip_serializing_if = "Option::is_none")]
        #[doc = "Category/tag filter"]
        #[deprecated]
        pub categories: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "options", skip_serializing_if = "Option::is_none")]
        #[doc = "Tracing options"]
        #[deprecated]
        pub options: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "bufferUsageReportingInterval", skip_serializing_if = "Option::is_none")]
        #[doc = "If set, the agent will issue bufferUsage events at this interval, specified in milliseconds"]
        pub buffer_usage_reporting_interval: Option<f64>,
        #[serde(rename = "transferMode", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether to report trace events as series of dataCollected events or to save trace to a stream \\(defaults to <code>ReportEvents</code>\\)."]
        pub transfer_mode: Option<::proto::tracing::StartCommandTransferMode>,
        #[serde(rename = "traceConfig", skip_serializing_if = "Option::is_none")]
        pub trace_config: Option<::proto::tracing::TraceConfig<'a>>,
    }
    impl<'a> ::traits::SerializeCdpCommand for StartCommand<'a> {
        fn command_name(&self) -> &str {
            "Tracing.start"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for StartCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Tracing.start" {
                Ok(
                    <StartCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Start trace events collection.\n\n# Command `Tracing.start`\n\n*Domain Module:* [`cdp::proto::tracing`](index.html)  \n*Command Struct:* [`cdp::proto::tracing::StartCommand`](struct.StartCommand.html)  \n*Response Struct:* [`cdp::proto::tracing::StartResponse`](struct.StartResponse.html)"]
    pub struct StartResponse;
    impl ::serde::Serialize for StartResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StartResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StartResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for StartCommand<'a> {
        type Response = StartResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for StartResponse {
        type Command = StartCommand<'a>;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Stop trace events collection.\n\n# Command `Tracing.end`\n\n*Domain Module:* [`cdp::proto::tracing`](index.html)  \n*Command Struct:* [`cdp::proto::tracing::EndCommand`](struct.EndCommand.html)  \n*Response Struct:* [`cdp::proto::tracing::EndResponse`](struct.EndResponse.html)"]
    pub struct EndCommand;
    impl ::serde::Serialize for EndCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EndCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EndCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for EndCommand {
        fn command_name(&self) -> &str {
            "Tracing.end"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for EndCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Tracing.end" {
                Ok(<EndCommand as ::serde::Deserialize<'de>>::deserialize(
                    params,
                ))
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Stop trace events collection.\n\n# Command `Tracing.end`\n\n*Domain Module:* [`cdp::proto::tracing`](index.html)  \n*Command Struct:* [`cdp::proto::tracing::EndCommand`](struct.EndCommand.html)  \n*Response Struct:* [`cdp::proto::tracing::EndResponse`](struct.EndResponse.html)"]
    pub struct EndResponse;
    impl ::serde::Serialize for EndResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EndResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EndResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for EndCommand {
        type Response = EndResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for EndResponse {
        type Command = EndCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Gets supported tracing categories.\n\n# Command `Tracing.getCategories`\n\n*Domain Module:* [`cdp::proto::tracing`](index.html)  \n*Command Struct:* [`cdp::proto::tracing::GetCategoriesCommand`](struct.GetCategoriesCommand.html)  \n*Response Struct:* [`cdp::proto::tracing::GetCategoriesResponse`](struct.GetCategoriesResponse.html)"]
    pub struct GetCategoriesCommand;
    impl ::serde::Serialize for GetCategoriesCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetCategoriesCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| GetCategoriesCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for GetCategoriesCommand {
        fn command_name(&self) -> &str {
            "Tracing.getCategories"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for GetCategoriesCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Tracing.getCategories" {
                Ok(
                    <GetCategoriesCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Gets supported tracing categories.\n\n# Command `Tracing.getCategories`\n\n*Domain Module:* [`cdp::proto::tracing`](index.html)  \n*Command Struct:* [`cdp::proto::tracing::GetCategoriesCommand`](struct.GetCategoriesCommand.html)  \n*Response Struct:* [`cdp::proto::tracing::GetCategoriesResponse`](struct.GetCategoriesResponse.html)"]
    pub struct GetCategoriesResponse<'a> {
        #[serde(rename = "categories")]
        #[doc = "A list of supported tracing categories."]
        pub categories: Vec<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for GetCategoriesCommand {
        type Response = GetCategoriesResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for GetCategoriesResponse<'a> {
        type Command = GetCategoriesCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Request a global memory dump.\n\n# Command `Tracing.requestMemoryDump`\n\n*Domain Module:* [`cdp::proto::tracing`](index.html)  \n*Command Struct:* [`cdp::proto::tracing::RequestMemoryDumpCommand`](struct.RequestMemoryDumpCommand.html)  \n*Response Struct:* [`cdp::proto::tracing::RequestMemoryDumpResponse`](struct.RequestMemoryDumpResponse.html)"]
    pub struct RequestMemoryDumpCommand;
    impl ::serde::Serialize for RequestMemoryDumpCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for RequestMemoryDumpCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| RequestMemoryDumpCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for RequestMemoryDumpCommand {
        fn command_name(&self) -> &str {
            "Tracing.requestMemoryDump"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for RequestMemoryDumpCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Tracing.requestMemoryDump" {
                Ok ( < RequestMemoryDumpCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Request a global memory dump.\n\n# Command `Tracing.requestMemoryDump`\n\n*Domain Module:* [`cdp::proto::tracing`](index.html)  \n*Command Struct:* [`cdp::proto::tracing::RequestMemoryDumpCommand`](struct.RequestMemoryDumpCommand.html)  \n*Response Struct:* [`cdp::proto::tracing::RequestMemoryDumpResponse`](struct.RequestMemoryDumpResponse.html)"]
    pub struct RequestMemoryDumpResponse<'a> {
        #[serde(rename = "dumpGuid")]
        #[doc = "GUID of the resulting global memory dump."]
        pub dump_guid: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "success")]
        #[doc = "True iff the global memory dump succeeded."]
        pub success: bool,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for RequestMemoryDumpCommand {
        type Response = RequestMemoryDumpResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for RequestMemoryDumpResponse<'a> {
        type Command = RequestMemoryDumpCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Record a clock sync marker in the trace.\n\n# Command `Tracing.recordClockSyncMarker`\n\n*Domain Module:* [`cdp::proto::tracing`](index.html)  \n*Command Struct:* [`cdp::proto::tracing::RecordClockSyncMarkerCommand`](struct.RecordClockSyncMarkerCommand.html)  \n*Response Struct:* [`cdp::proto::tracing::RecordClockSyncMarkerResponse`](struct.RecordClockSyncMarkerResponse.html)"]
    pub struct RecordClockSyncMarkerCommand<'a> {
        #[serde(rename = "syncId")]
        #[doc = "The ID of this clock sync marker"]
        pub sync_id: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpCommand for RecordClockSyncMarkerCommand<'a> {
        fn command_name(&self) -> &str {
            "Tracing.recordClockSyncMarker"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for RecordClockSyncMarkerCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Tracing.recordClockSyncMarker" {
                Ok ( < RecordClockSyncMarkerCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Record a clock sync marker in the trace.\n\n# Command `Tracing.recordClockSyncMarker`\n\n*Domain Module:* [`cdp::proto::tracing`](index.html)  \n*Command Struct:* [`cdp::proto::tracing::RecordClockSyncMarkerCommand`](struct.RecordClockSyncMarkerCommand.html)  \n*Response Struct:* [`cdp::proto::tracing::RecordClockSyncMarkerResponse`](struct.RecordClockSyncMarkerResponse.html)"]
    pub struct RecordClockSyncMarkerResponse;
    impl ::serde::Serialize for RecordClockSyncMarkerResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for RecordClockSyncMarkerResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| RecordClockSyncMarkerResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for RecordClockSyncMarkerCommand<'a> {
        type Response = RecordClockSyncMarkerResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for RecordClockSyncMarkerResponse {
        type Command = RecordClockSyncMarkerCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Contains an bucket of collected trace events. When tracing is stopped collected events will be send as a sequence of dataCollected events followed by tracingComplete event.\n\n# Event `Tracing.dataCollected`\n\n*Domain Module:* [`cdp::proto::tracing`](index.html)  \n*Event Struct:* [`cdp::proto::tracing::DataCollectedEvent`](struct.DataCollectedEvent.html)"]
    pub struct DataCollectedEvent {
        #[serde(rename = "value")]
        pub value: Vec<::proto::Empty>,
    }
    impl ::traits::SerializeCdpEvent for DataCollectedEvent {
        fn event_name(&self) -> &str {
            "Tracing.dataCollected"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpEvent<'de> for DataCollectedEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Tracing.dataCollected" {
                Ok(
                    <DataCollectedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Signals that tracing is stopped and there is no trace buffers pending flush, all data were delivered via dataCollected events.\n\n# Event `Tracing.tracingComplete`\n\n*Domain Module:* [`cdp::proto::tracing`](index.html)  \n*Event Struct:* [`cdp::proto::tracing::TracingCompleteEvent`](struct.TracingCompleteEvent.html)"]
    pub struct TracingCompleteEvent<'a> {
        #[serde(rename = "stream", skip_serializing_if = "Option::is_none")]
        #[doc = "A handle of the stream that holds resulting trace data."]
        pub stream: Option<::proto::io::StreamHandle<'a>>,
    }
    impl<'a> ::traits::SerializeCdpEvent for TracingCompleteEvent<'a> {
        fn event_name(&self) -> &str {
            "Tracing.tracingComplete"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for TracingCompleteEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Tracing.tracingComplete" {
                Ok(
                    <TracingCompleteEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Event `Tracing.bufferUsage`\n\n*Domain Module:* [`cdp::proto::tracing`](index.html)  \n*Event Struct:* [`cdp::proto::tracing::BufferUsageEvent`](struct.BufferUsageEvent.html)"]
    pub struct BufferUsageEvent {
        #[serde(rename = "percentFull", skip_serializing_if = "Option::is_none")]
        #[doc = "A number in range \\[0..1\\] that indicates the used size of event buffer as a fraction of its total size."]
        pub percent_full: Option<f64>,
        #[serde(rename = "eventCount", skip_serializing_if = "Option::is_none")]
        #[doc = "An approximate number of events in the trace log."]
        pub event_count: Option<f64>,
        #[serde(rename = "value", skip_serializing_if = "Option::is_none")]
        #[doc = "A number in range \\[0..1\\] that indicates the used size of event buffer as a fraction of its total size."]
        pub value: Option<f64>,
    }
    impl ::traits::SerializeCdpEvent for BufferUsageEvent {
        fn event_name(&self) -> &str {
            "Tracing.bufferUsage"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpEvent<'de> for BufferUsageEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Tracing.bufferUsage" {
                Ok(
                    <BufferUsageEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Configuration for memory dump. Used only when \"memory-infra\" category is enabled."]
    pub type MemoryDumpConfig = ::proto::Empty;
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\nUsed in the type of [`cdp::proto::tracing::TraceConfig::record_mode`](struct.TraceConfig.html#structfield.record_mode)."]
    pub enum TraceConfigRecordMode {
        #[serde(rename = "recordUntilFull")]
        #[doc = "Represented as `\"recordUntilFull\"`."]
        RecordUntilFull,
        #[serde(rename = "recordContinuously")]
        #[doc = "Represented as `\"recordContinuously\"`."]
        RecordContinuously,
        #[serde(rename = "recordAsMuchAsPossible")]
        #[doc = "Represented as `\"recordAsMuchAsPossible\"`."]
        RecordAsMuchAsPossible,
        #[serde(rename = "echoToConsole")]
        #[doc = "Represented as `\"echoToConsole\"`."]
        EchoToConsole,
    }
    impl TraceConfigRecordMode {
        pub const ENUM_VALUES: &'static [TraceConfigRecordMode] =
            &[
                TraceConfigRecordMode::RecordUntilFull,
                TraceConfigRecordMode::RecordContinuously,
                TraceConfigRecordMode::RecordAsMuchAsPossible,
                TraceConfigRecordMode::EchoToConsole,
            ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "recordUntilFull",
            "recordContinuously",
            "recordAsMuchAsPossible",
            "echoToConsole",
        ];
    }
    impl ::std::str::FromStr for TraceConfigRecordMode {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "recordUntilFull" => Ok(TraceConfigRecordMode::RecordUntilFull),
                "recordContinuously" => Ok(TraceConfigRecordMode::RecordContinuously),
                "recordAsMuchAsPossible" => Ok(TraceConfigRecordMode::RecordAsMuchAsPossible),
                "echoToConsole" => Ok(TraceConfigRecordMode::EchoToConsole),
                _ => Err(::proto::ParseEnumError {
                    expected: TraceConfigRecordMode::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for TraceConfigRecordMode {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    TraceConfigRecordMode::RecordUntilFull => "recordUntilFull",
                    TraceConfigRecordMode::RecordContinuously => "recordContinuously",
                    TraceConfigRecordMode::RecordAsMuchAsPossible => "recordAsMuchAsPossible",
                    TraceConfigRecordMode::EchoToConsole => "echoToConsole",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>"]
    pub struct TraceConfig<'a> {
        #[serde(rename = "recordMode", skip_serializing_if = "Option::is_none")]
        #[doc = "Controls how the trace buffer stores data."]
        pub record_mode: Option<::proto::tracing::TraceConfigRecordMode>,
        #[serde(rename = "enableSampling", skip_serializing_if = "Option::is_none")]
        #[doc = "Turns on JavaScript stack sampling."]
        pub enable_sampling: Option<bool>,
        #[serde(rename = "enableSystrace", skip_serializing_if = "Option::is_none")]
        #[doc = "Turns on system tracing."]
        pub enable_systrace: Option<bool>,
        #[serde(rename = "enableArgumentFilter", skip_serializing_if = "Option::is_none")]
        #[doc = "Turns on argument filter."]
        pub enable_argument_filter: Option<bool>,
        #[serde(rename = "includedCategories", skip_serializing_if = "Option::is_none")]
        #[doc = "Included category filters."]
        pub included_categories: Option<Vec<::std::borrow::Cow<'a, str>>>,
        #[serde(rename = "excludedCategories", skip_serializing_if = "Option::is_none")]
        #[doc = "Excluded category filters."]
        pub excluded_categories: Option<Vec<::std::borrow::Cow<'a, str>>>,
        #[serde(rename = "syntheticDelays", skip_serializing_if = "Option::is_none")]
        #[doc = "Configuration to synthesize the delays in tracing."]
        pub synthetic_delays: Option<Vec<::std::borrow::Cow<'a, str>>>,
        #[serde(rename = "memoryDumpConfig", skip_serializing_if = "Option::is_none")]
        #[doc = "Configuration for memory dump triggers. Used only when \"memory-infra\" category is enabled."]
        pub memory_dump_config: Option<::proto::tracing::MemoryDumpConfig>,
    }
}
#[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Animation\n\n## Commands\n\n- [`Animation.enable`](struct.EnableCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Enables animation domain notifications.\n- [`Animation.disable`](struct.DisableCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Disables animation domain notifications.\n- [`Animation.getPlaybackRate`](struct.GetPlaybackRateCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Gets the playback rate of the document timeline.\n- [`Animation.setPlaybackRate`](struct.SetPlaybackRateCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Sets the playback rate of the document timeline.\n- [`Animation.getCurrentTime`](struct.GetCurrentTimeCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns the current time of the an animation.\n- [`Animation.setPaused`](struct.SetPausedCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Sets the paused state of a set of animations.\n- [`Animation.setTiming`](struct.SetTimingCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Sets the timing of an animation node.\n- [`Animation.seekAnimations`](struct.SeekAnimationsCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Seek a set of animations to a particular time within each animation.\n- [`Animation.releaseAnimations`](struct.ReleaseAnimationsCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Releases a set of animations to no longer be manipulated.\n- [`Animation.resolveAnimation`](struct.ResolveAnimationCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Gets the remote object of the Animation.\n\n## Events\n\n- [`Animation.animationCreated`](struct.AnimationCreatedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Event for each animation that has been created.\n- [`Animation.animationStarted`](struct.AnimationStartedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Event for animation that has been started.\n- [`Animation.animationCanceled`](struct.AnimationCanceledEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Event for when an animation has been cancelled.\n\n##Types\n\n- [`Animation`](struct.Animation.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Animation instance.\n- [`AnimationEffect`](struct.AnimationEffect.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  AnimationEffect instance\n- [`KeyframesRule`](struct.KeyframesRule.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Keyframes Rule\n- [`KeyframeStyle`](struct.KeyframeStyle.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Keyframe Style\n"]
pub mod animation {
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables animation domain notifications.\n\n# Command `Animation.enable`\n\n*Domain Module:* [`cdp::proto::animation`](index.html)  \n*Command Struct:* [`cdp::proto::animation::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::proto::animation::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableCommand;
    impl ::serde::Serialize for EnableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for EnableCommand {
        fn command_name(&self) -> &str {
            "Animation.enable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for EnableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Animation.enable" {
                Ok(
                    <EnableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables animation domain notifications.\n\n# Command `Animation.enable`\n\n*Domain Module:* [`cdp::proto::animation`](index.html)  \n*Command Struct:* [`cdp::proto::animation::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::proto::animation::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableResponse;
    impl ::serde::Serialize for EnableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for EnableCommand {
        type Response = EnableResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for EnableResponse {
        type Command = EnableCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Disables animation domain notifications.\n\n# Command `Animation.disable`\n\n*Domain Module:* [`cdp::proto::animation`](index.html)  \n*Command Struct:* [`cdp::proto::animation::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::proto::animation::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableCommand;
    impl ::serde::Serialize for DisableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for DisableCommand {
        fn command_name(&self) -> &str {
            "Animation.disable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for DisableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Animation.disable" {
                Ok(
                    <DisableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Disables animation domain notifications.\n\n# Command `Animation.disable`\n\n*Domain Module:* [`cdp::proto::animation`](index.html)  \n*Command Struct:* [`cdp::proto::animation::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::proto::animation::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableResponse;
    impl ::serde::Serialize for DisableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for DisableCommand {
        type Response = DisableResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for DisableResponse {
        type Command = DisableCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Gets the playback rate of the document timeline.\n\n# Command `Animation.getPlaybackRate`\n\n*Domain Module:* [`cdp::proto::animation`](index.html)  \n*Command Struct:* [`cdp::proto::animation::GetPlaybackRateCommand`](struct.GetPlaybackRateCommand.html)  \n*Response Struct:* [`cdp::proto::animation::GetPlaybackRateResponse`](struct.GetPlaybackRateResponse.html)"]
    pub struct GetPlaybackRateCommand;
    impl ::serde::Serialize for GetPlaybackRateCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetPlaybackRateCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| GetPlaybackRateCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for GetPlaybackRateCommand {
        fn command_name(&self) -> &str {
            "Animation.getPlaybackRate"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for GetPlaybackRateCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Animation.getPlaybackRate" {
                Ok(
                    <GetPlaybackRateCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Gets the playback rate of the document timeline.\n\n# Command `Animation.getPlaybackRate`\n\n*Domain Module:* [`cdp::proto::animation`](index.html)  \n*Command Struct:* [`cdp::proto::animation::GetPlaybackRateCommand`](struct.GetPlaybackRateCommand.html)  \n*Response Struct:* [`cdp::proto::animation::GetPlaybackRateResponse`](struct.GetPlaybackRateResponse.html)"]
    pub struct GetPlaybackRateResponse {
        #[serde(rename = "playbackRate")]
        #[doc = "Playback rate for animations on page."]
        pub playback_rate: f64,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for GetPlaybackRateCommand {
        type Response = GetPlaybackRateResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for GetPlaybackRateResponse {
        type Command = GetPlaybackRateCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Sets the playback rate of the document timeline.\n\n# Command `Animation.setPlaybackRate`\n\n*Domain Module:* [`cdp::proto::animation`](index.html)  \n*Command Struct:* [`cdp::proto::animation::SetPlaybackRateCommand`](struct.SetPlaybackRateCommand.html)  \n*Response Struct:* [`cdp::proto::animation::SetPlaybackRateResponse`](struct.SetPlaybackRateResponse.html)"]
    pub struct SetPlaybackRateCommand {
        #[serde(rename = "playbackRate")]
        #[doc = "Playback rate for animations on page"]
        pub playback_rate: f64,
    }
    impl ::traits::SerializeCdpCommand for SetPlaybackRateCommand {
        fn command_name(&self) -> &str {
            "Animation.setPlaybackRate"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for SetPlaybackRateCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Animation.setPlaybackRate" {
                Ok(
                    <SetPlaybackRateCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Sets the playback rate of the document timeline.\n\n# Command `Animation.setPlaybackRate`\n\n*Domain Module:* [`cdp::proto::animation`](index.html)  \n*Command Struct:* [`cdp::proto::animation::SetPlaybackRateCommand`](struct.SetPlaybackRateCommand.html)  \n*Response Struct:* [`cdp::proto::animation::SetPlaybackRateResponse`](struct.SetPlaybackRateResponse.html)"]
    pub struct SetPlaybackRateResponse;
    impl ::serde::Serialize for SetPlaybackRateResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetPlaybackRateResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetPlaybackRateResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetPlaybackRateCommand {
        type Response = SetPlaybackRateResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetPlaybackRateResponse {
        type Command = SetPlaybackRateCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns the current time of the an animation.\n\n# Command `Animation.getCurrentTime`\n\n*Domain Module:* [`cdp::proto::animation`](index.html)  \n*Command Struct:* [`cdp::proto::animation::GetCurrentTimeCommand`](struct.GetCurrentTimeCommand.html)  \n*Response Struct:* [`cdp::proto::animation::GetCurrentTimeResponse`](struct.GetCurrentTimeResponse.html)"]
    pub struct GetCurrentTimeCommand<'a> {
        #[serde(rename = "id")]
        #[doc = "Id of animation."]
        pub id: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpCommand for GetCurrentTimeCommand<'a> {
        fn command_name(&self) -> &str {
            "Animation.getCurrentTime"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for GetCurrentTimeCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Animation.getCurrentTime" {
                Ok(
                    <GetCurrentTimeCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns the current time of the an animation.\n\n# Command `Animation.getCurrentTime`\n\n*Domain Module:* [`cdp::proto::animation`](index.html)  \n*Command Struct:* [`cdp::proto::animation::GetCurrentTimeCommand`](struct.GetCurrentTimeCommand.html)  \n*Response Struct:* [`cdp::proto::animation::GetCurrentTimeResponse`](struct.GetCurrentTimeResponse.html)"]
    pub struct GetCurrentTimeResponse {
        #[serde(rename = "currentTime")]
        #[doc = "Current time of the page."]
        pub current_time: f64,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for GetCurrentTimeCommand<'a> {
        type Response = GetCurrentTimeResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for GetCurrentTimeResponse {
        type Command = GetCurrentTimeCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Sets the paused state of a set of animations.\n\n# Command `Animation.setPaused`\n\n*Domain Module:* [`cdp::proto::animation`](index.html)  \n*Command Struct:* [`cdp::proto::animation::SetPausedCommand`](struct.SetPausedCommand.html)  \n*Response Struct:* [`cdp::proto::animation::SetPausedResponse`](struct.SetPausedResponse.html)"]
    pub struct SetPausedCommand<'a> {
        #[serde(rename = "animations")]
        #[doc = "Animations to set the pause state of."]
        pub animations: Vec<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "paused")]
        #[doc = "Paused state to set to."]
        pub paused: bool,
    }
    impl<'a> ::traits::SerializeCdpCommand for SetPausedCommand<'a> {
        fn command_name(&self) -> &str {
            "Animation.setPaused"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for SetPausedCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Animation.setPaused" {
                Ok(
                    <SetPausedCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Sets the paused state of a set of animations.\n\n# Command `Animation.setPaused`\n\n*Domain Module:* [`cdp::proto::animation`](index.html)  \n*Command Struct:* [`cdp::proto::animation::SetPausedCommand`](struct.SetPausedCommand.html)  \n*Response Struct:* [`cdp::proto::animation::SetPausedResponse`](struct.SetPausedResponse.html)"]
    pub struct SetPausedResponse;
    impl ::serde::Serialize for SetPausedResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetPausedResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetPausedResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetPausedCommand<'a> {
        type Response = SetPausedResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetPausedResponse {
        type Command = SetPausedCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Sets the timing of an animation node.\n\n# Command `Animation.setTiming`\n\n*Domain Module:* [`cdp::proto::animation`](index.html)  \n*Command Struct:* [`cdp::proto::animation::SetTimingCommand`](struct.SetTimingCommand.html)  \n*Response Struct:* [`cdp::proto::animation::SetTimingResponse`](struct.SetTimingResponse.html)"]
    pub struct SetTimingCommand<'a> {
        #[serde(rename = "animationId")]
        #[doc = "Animation id."]
        pub animation_id: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "duration")]
        #[doc = "Duration of the animation."]
        pub duration: f64,
        #[serde(rename = "delay")]
        #[doc = "Delay of the animation."]
        pub delay: f64,
    }
    impl<'a> ::traits::SerializeCdpCommand for SetTimingCommand<'a> {
        fn command_name(&self) -> &str {
            "Animation.setTiming"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for SetTimingCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Animation.setTiming" {
                Ok(
                    <SetTimingCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Sets the timing of an animation node.\n\n# Command `Animation.setTiming`\n\n*Domain Module:* [`cdp::proto::animation`](index.html)  \n*Command Struct:* [`cdp::proto::animation::SetTimingCommand`](struct.SetTimingCommand.html)  \n*Response Struct:* [`cdp::proto::animation::SetTimingResponse`](struct.SetTimingResponse.html)"]
    pub struct SetTimingResponse;
    impl ::serde::Serialize for SetTimingResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetTimingResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetTimingResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetTimingCommand<'a> {
        type Response = SetTimingResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetTimingResponse {
        type Command = SetTimingCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Seek a set of animations to a particular time within each animation.\n\n# Command `Animation.seekAnimations`\n\n*Domain Module:* [`cdp::proto::animation`](index.html)  \n*Command Struct:* [`cdp::proto::animation::SeekAnimationsCommand`](struct.SeekAnimationsCommand.html)  \n*Response Struct:* [`cdp::proto::animation::SeekAnimationsResponse`](struct.SeekAnimationsResponse.html)"]
    pub struct SeekAnimationsCommand<'a> {
        #[serde(rename = "animations")]
        #[doc = "List of animation ids to seek."]
        pub animations: Vec<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "currentTime")]
        #[doc = "Set the current time of each animation."]
        pub current_time: f64,
    }
    impl<'a> ::traits::SerializeCdpCommand for SeekAnimationsCommand<'a> {
        fn command_name(&self) -> &str {
            "Animation.seekAnimations"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for SeekAnimationsCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Animation.seekAnimations" {
                Ok(
                    <SeekAnimationsCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Seek a set of animations to a particular time within each animation.\n\n# Command `Animation.seekAnimations`\n\n*Domain Module:* [`cdp::proto::animation`](index.html)  \n*Command Struct:* [`cdp::proto::animation::SeekAnimationsCommand`](struct.SeekAnimationsCommand.html)  \n*Response Struct:* [`cdp::proto::animation::SeekAnimationsResponse`](struct.SeekAnimationsResponse.html)"]
    pub struct SeekAnimationsResponse;
    impl ::serde::Serialize for SeekAnimationsResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SeekAnimationsResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SeekAnimationsResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SeekAnimationsCommand<'a> {
        type Response = SeekAnimationsResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SeekAnimationsResponse {
        type Command = SeekAnimationsCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Releases a set of animations to no longer be manipulated.\n\n# Command `Animation.releaseAnimations`\n\n*Domain Module:* [`cdp::proto::animation`](index.html)  \n*Command Struct:* [`cdp::proto::animation::ReleaseAnimationsCommand`](struct.ReleaseAnimationsCommand.html)  \n*Response Struct:* [`cdp::proto::animation::ReleaseAnimationsResponse`](struct.ReleaseAnimationsResponse.html)"]
    pub struct ReleaseAnimationsCommand<'a> {
        #[serde(rename = "animations")]
        #[doc = "List of animation ids to seek."]
        pub animations: Vec<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::traits::SerializeCdpCommand for ReleaseAnimationsCommand<'a> {
        fn command_name(&self) -> &str {
            "Animation.releaseAnimations"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for ReleaseAnimationsCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Animation.releaseAnimations" {
                Ok ( < ReleaseAnimationsCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Releases a set of animations to no longer be manipulated.\n\n# Command `Animation.releaseAnimations`\n\n*Domain Module:* [`cdp::proto::animation`](index.html)  \n*Command Struct:* [`cdp::proto::animation::ReleaseAnimationsCommand`](struct.ReleaseAnimationsCommand.html)  \n*Response Struct:* [`cdp::proto::animation::ReleaseAnimationsResponse`](struct.ReleaseAnimationsResponse.html)"]
    pub struct ReleaseAnimationsResponse;
    impl ::serde::Serialize for ReleaseAnimationsResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ReleaseAnimationsResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ReleaseAnimationsResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for ReleaseAnimationsCommand<'a> {
        type Response = ReleaseAnimationsResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for ReleaseAnimationsResponse {
        type Command = ReleaseAnimationsCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Gets the remote object of the Animation.\n\n# Command `Animation.resolveAnimation`\n\n*Domain Module:* [`cdp::proto::animation`](index.html)  \n*Command Struct:* [`cdp::proto::animation::ResolveAnimationCommand`](struct.ResolveAnimationCommand.html)  \n*Response Struct:* [`cdp::proto::animation::ResolveAnimationResponse`](struct.ResolveAnimationResponse.html)"]
    pub struct ResolveAnimationCommand<'a> {
        #[serde(rename = "animationId")]
        #[doc = "Animation id."]
        pub animation_id: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpCommand for ResolveAnimationCommand<'a> {
        fn command_name(&self) -> &str {
            "Animation.resolveAnimation"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for ResolveAnimationCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Animation.resolveAnimation" {
                Ok ( < ResolveAnimationCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Gets the remote object of the Animation.\n\n# Command `Animation.resolveAnimation`\n\n*Domain Module:* [`cdp::proto::animation`](index.html)  \n*Command Struct:* [`cdp::proto::animation::ResolveAnimationCommand`](struct.ResolveAnimationCommand.html)  \n*Response Struct:* [`cdp::proto::animation::ResolveAnimationResponse`](struct.ResolveAnimationResponse.html)"]
    pub struct ResolveAnimationResponse<'a> {
        #[serde(rename = "remoteObject")]
        #[doc = "Corresponding remote object."]
        pub remote_object: ::proto::runtime::RemoteObject<'a>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for ResolveAnimationCommand<'a> {
        type Response = ResolveAnimationResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for ResolveAnimationResponse<'a> {
        type Command = ResolveAnimationCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Event for each animation that has been created.\n\n# Event `Animation.animationCreated`\n\n*Domain Module:* [`cdp::proto::animation`](index.html)  \n*Event Struct:* [`cdp::proto::animation::AnimationCreatedEvent`](struct.AnimationCreatedEvent.html)"]
    pub struct AnimationCreatedEvent<'a> {
        #[serde(rename = "id")]
        #[doc = "Id of the animation that was created."]
        pub id: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpEvent for AnimationCreatedEvent<'a> {
        fn event_name(&self) -> &str {
            "Animation.animationCreated"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for AnimationCreatedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Animation.animationCreated" {
                Ok(
                    <AnimationCreatedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Event for animation that has been started.\n\n# Event `Animation.animationStarted`\n\n*Domain Module:* [`cdp::proto::animation`](index.html)  \n*Event Struct:* [`cdp::proto::animation::AnimationStartedEvent`](struct.AnimationStartedEvent.html)"]
    pub struct AnimationStartedEvent<'a> {
        #[serde(rename = "animation")]
        #[doc = "Animation that was started."]
        pub animation: ::proto::animation::Animation<'a>,
    }
    impl<'a> ::traits::SerializeCdpEvent for AnimationStartedEvent<'a> {
        fn event_name(&self) -> &str {
            "Animation.animationStarted"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for AnimationStartedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Animation.animationStarted" {
                Ok(
                    <AnimationStartedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Event for when an animation has been cancelled.\n\n# Event `Animation.animationCanceled`\n\n*Domain Module:* [`cdp::proto::animation`](index.html)  \n*Event Struct:* [`cdp::proto::animation::AnimationCanceledEvent`](struct.AnimationCanceledEvent.html)"]
    pub struct AnimationCanceledEvent<'a> {
        #[serde(rename = "id")]
        #[doc = "Id of the animation that was cancelled."]
        pub id: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpEvent for AnimationCanceledEvent<'a> {
        fn event_name(&self) -> &str {
            "Animation.animationCanceled"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for AnimationCanceledEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Animation.animationCanceled" {
                Ok(
                    <AnimationCanceledEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\nUsed in the type of [`cdp::proto::animation::Animation::ty`](struct.Animation.html#structfield.ty)."]
    pub enum AnimationType {
        #[serde(rename = "CSSTransition")]
        #[doc = "Represented as `\"CSSTransition\"`."]
        CssTransition,
        #[serde(rename = "CSSAnimation")]
        #[doc = "Represented as `\"CSSAnimation\"`."]
        CssAnimation,
        #[serde(rename = "WebAnimation")]
        #[doc = "Represented as `\"WebAnimation\"`."]
        WebAnimation,
    }
    impl AnimationType {
        pub const ENUM_VALUES: &'static [AnimationType] = &[
            AnimationType::CssTransition,
            AnimationType::CssAnimation,
            AnimationType::WebAnimation,
        ];
        pub const STR_VALUES: &'static [&'static str] =
            &["CSSTransition", "CSSAnimation", "WebAnimation"];
    }
    impl ::std::str::FromStr for AnimationType {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "CSSTransition" => Ok(AnimationType::CssTransition),
                "CSSAnimation" => Ok(AnimationType::CssAnimation),
                "WebAnimation" => Ok(AnimationType::WebAnimation),
                _ => Err(::proto::ParseEnumError {
                    expected: AnimationType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for AnimationType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    AnimationType::CssTransition => "CSSTransition",
                    AnimationType::CssAnimation => "CSSAnimation",
                    AnimationType::WebAnimation => "WebAnimation",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Animation instance."]
    pub struct Animation<'a> {
        #[serde(rename = "id")]
        #[doc = "<code>Animation</code>'s id."]
        pub id: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "name")]
        #[doc = "<code>Animation</code>'s name."]
        pub name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "pausedState")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> <code>Animation</code>'s internal paused state."]
        pub paused_state: bool,
        #[serde(rename = "playState")]
        #[doc = "<code>Animation</code>'s play state."]
        pub play_state: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "playbackRate")]
        #[doc = "<code>Animation</code>'s playback rate."]
        pub playback_rate: f64,
        #[serde(rename = "startTime")]
        #[doc = "<code>Animation</code>'s start time."]
        pub start_time: f64,
        #[serde(rename = "currentTime")]
        #[doc = "<code>Animation</code>'s current time."]
        pub current_time: f64,
        #[serde(rename = "source")]
        #[doc = "<code>Animation</code>'s source animation node."]
        pub source: ::proto::animation::AnimationEffect<'a>,
        #[serde(rename = "type")]
        #[doc = "Animation type of <code>Animation</code>."]
        pub ty: ::proto::animation::AnimationType,
        #[serde(rename = "cssId", skip_serializing_if = "Option::is_none")]
        #[doc = "A unique ID for <code>Animation</code> representing the sources that triggered this CSS animation/transition."]
        pub css_id: Option<::std::borrow::Cow<'a, str>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> AnimationEffect instance"]
    pub struct AnimationEffect<'a> {
        #[serde(rename = "delay")]
        #[doc = "<code>AnimationEffect</code>'s delay."]
        pub delay: f64,
        #[serde(rename = "endDelay")]
        #[doc = "<code>AnimationEffect</code>'s end delay."]
        pub end_delay: f64,
        #[serde(rename = "iterationStart")]
        #[doc = "<code>AnimationEffect</code>'s iteration start."]
        pub iteration_start: f64,
        #[serde(rename = "iterations")]
        #[doc = "<code>AnimationEffect</code>'s iterations."]
        pub iterations: f64,
        #[serde(rename = "duration")]
        #[doc = "<code>AnimationEffect</code>'s iteration duration."]
        pub duration: f64,
        #[serde(rename = "direction")]
        #[doc = "<code>AnimationEffect</code>'s playback direction."]
        pub direction: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "fill")]
        #[doc = "<code>AnimationEffect</code>'s fill mode."]
        pub fill: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "backendNodeId")]
        #[doc = "<code>AnimationEffect</code>'s target node."]
        pub backend_node_id: ::proto::dom::BackendNodeId,
        #[serde(rename = "keyframesRule", skip_serializing_if = "Option::is_none")]
        #[doc = "<code>AnimationEffect</code>'s keyframes."]
        pub keyframes_rule: Option<::proto::animation::KeyframesRule<'a>>,
        #[serde(rename = "easing")]
        #[doc = "<code>AnimationEffect</code>'s timing function."]
        pub easing: ::std::borrow::Cow<'a, str>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Keyframes Rule"]
    pub struct KeyframesRule<'a> {
        #[serde(rename = "name", skip_serializing_if = "Option::is_none")]
        #[doc = "CSS keyframed animation's name."]
        pub name: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "keyframes")]
        #[doc = "List of animation keyframes."]
        pub keyframes: Vec<::proto::animation::KeyframeStyle<'a>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Keyframe Style"]
    pub struct KeyframeStyle<'a> {
        #[serde(rename = "offset")]
        #[doc = "Keyframe's time offset."]
        pub offset: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "easing")]
        #[doc = "<code>AnimationEffect</code>'s timing function."]
        pub easing: ::std::borrow::Cow<'a, str>,
    }
}
#[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Accessibility\n\n## Commands\n\n- [`Accessibility.getPartialAXTree`](struct.GetPartialAxTreeCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Fetches the accessibility node and partial accessibility tree for this DOM node, if it exists.\n\n##Types\n\n- [`AXNodeId`](type.AxNodeId.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Unique accessibility node identifier.\n- [`AXValueType`](enum.AxValueType.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Enum of possible property types.\n- [`AXValueSourceType`](enum.AxValueSourceType.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Enum of possible property sources.\n- [`AXValueNativeSourceType`](enum.AxValueNativeSourceType.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Enum of possible native property sources \\(as a subtype of a particular AXValueSourceType\\).\n- [`AXValueSource`](struct.AxValueSource.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  A single source for a computed AX property.\n- [`AXRelatedNode`](struct.AxRelatedNode.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`AXProperty`](struct.AxProperty.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`AXValue`](struct.AxValue.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  A single computed AX property.\n- [`AXGlobalStates`](enum.AxGlobalStates.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  States which apply to every AX node.\n- [`AXLiveRegionAttributes`](enum.AxLiveRegionAttributes.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Attributes which apply to nodes in live regions.\n- [`AXWidgetAttributes`](enum.AxWidgetAttributes.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Attributes which apply to widgets.\n- [`AXWidgetStates`](enum.AxWidgetStates.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  States which apply to widgets.\n- [`AXRelationshipAttributes`](enum.AxRelationshipAttributes.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Relationships between elements other than parent/child/sibling.\n- [`AXNode`](struct.AxNode.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  A node in the accessibility tree.\n"]
pub mod accessibility {
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Fetches the accessibility node and partial accessibility tree for this DOM node, if it exists.\n\n# Command `Accessibility.getPartialAXTree`\n\n*Domain Module:* [`cdp::proto::accessibility`](index.html)  \n*Command Struct:* [`cdp::proto::accessibility::GetPartialAxTreeCommand`](struct.GetPartialAxTreeCommand.html)  \n*Response Struct:* [`cdp::proto::accessibility::GetPartialAxTreeResponse`](struct.GetPartialAxTreeResponse.html)"]
    pub struct GetPartialAxTreeCommand {
        #[serde(rename = "nodeId")]
        #[doc = "ID of node to get the partial accessibility tree for."]
        pub node_id: ::proto::dom::NodeId,
        #[serde(rename = "fetchRelatives", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether to fetch this nodes ancestors, siblings and children. Defaults to true."]
        pub fetch_relatives: Option<bool>,
    }
    impl ::traits::SerializeCdpCommand for GetPartialAxTreeCommand {
        fn command_name(&self) -> &str {
            "Accessibility.getPartialAXTree"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for GetPartialAxTreeCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Accessibility.getPartialAXTree" {
                Ok ( < GetPartialAxTreeCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Fetches the accessibility node and partial accessibility tree for this DOM node, if it exists.\n\n# Command `Accessibility.getPartialAXTree`\n\n*Domain Module:* [`cdp::proto::accessibility`](index.html)  \n*Command Struct:* [`cdp::proto::accessibility::GetPartialAxTreeCommand`](struct.GetPartialAxTreeCommand.html)  \n*Response Struct:* [`cdp::proto::accessibility::GetPartialAxTreeResponse`](struct.GetPartialAxTreeResponse.html)"]
    pub struct GetPartialAxTreeResponse<'a> {
        #[serde(rename = "nodes")]
        #[doc = "The <code>Accessibility.AXNode</code> for this DOM node, if it exists, plus its ancestors, siblings and children, if requested."]
        pub nodes: Vec<::proto::accessibility::AxNode<'a>>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for GetPartialAxTreeCommand {
        type Response = GetPartialAxTreeResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for GetPartialAxTreeResponse<'a> {
        type Command = GetPartialAxTreeCommand;
    }
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Unique accessibility node identifier."]
    pub type AxNodeId<'a> = ::std::borrow::Cow<'a, str>;
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enum of possible property types."]
    pub enum AxValueType {
        #[serde(rename = "boolean")]
        #[doc = "Represented as `\"boolean\"`."]
        Boolean,
        #[serde(rename = "tristate")]
        #[doc = "Represented as `\"tristate\"`."]
        Tristate,
        #[serde(rename = "booleanOrUndefined")]
        #[doc = "Represented as `\"booleanOrUndefined\"`."]
        BooleanOrUndefined,
        #[serde(rename = "idref")]
        #[doc = "Represented as `\"idref\"`."]
        Idref,
        #[serde(rename = "idrefList")]
        #[doc = "Represented as `\"idrefList\"`."]
        IdrefList,
        #[serde(rename = "integer")]
        #[doc = "Represented as `\"integer\"`."]
        Integer,
        #[serde(rename = "node")]
        #[doc = "Represented as `\"node\"`."]
        Node,
        #[serde(rename = "nodeList")]
        #[doc = "Represented as `\"nodeList\"`."]
        NodeList,
        #[serde(rename = "number")]
        #[doc = "Represented as `\"number\"`."]
        Number,
        #[serde(rename = "string")]
        #[doc = "Represented as `\"string\"`."]
        String,
        #[serde(rename = "computedString")]
        #[doc = "Represented as `\"computedString\"`."]
        ComputedString,
        #[serde(rename = "token")]
        #[doc = "Represented as `\"token\"`."]
        Token,
        #[serde(rename = "tokenList")]
        #[doc = "Represented as `\"tokenList\"`."]
        TokenList,
        #[serde(rename = "domRelation")]
        #[doc = "Represented as `\"domRelation\"`."]
        DomRelation,
        #[serde(rename = "role")]
        #[doc = "Represented as `\"role\"`."]
        Role,
        #[serde(rename = "internalRole")]
        #[doc = "Represented as `\"internalRole\"`."]
        InternalRole,
        #[serde(rename = "valueUndefined")]
        #[doc = "Represented as `\"valueUndefined\"`."]
        ValueUndefined,
    }
    impl AxValueType {
        pub const ENUM_VALUES: &'static [AxValueType] = &[
            AxValueType::Boolean,
            AxValueType::Tristate,
            AxValueType::BooleanOrUndefined,
            AxValueType::Idref,
            AxValueType::IdrefList,
            AxValueType::Integer,
            AxValueType::Node,
            AxValueType::NodeList,
            AxValueType::Number,
            AxValueType::String,
            AxValueType::ComputedString,
            AxValueType::Token,
            AxValueType::TokenList,
            AxValueType::DomRelation,
            AxValueType::Role,
            AxValueType::InternalRole,
            AxValueType::ValueUndefined,
        ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "boolean",
            "tristate",
            "booleanOrUndefined",
            "idref",
            "idrefList",
            "integer",
            "node",
            "nodeList",
            "number",
            "string",
            "computedString",
            "token",
            "tokenList",
            "domRelation",
            "role",
            "internalRole",
            "valueUndefined",
        ];
    }
    impl ::std::str::FromStr for AxValueType {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "boolean" => Ok(AxValueType::Boolean),
                "tristate" => Ok(AxValueType::Tristate),
                "booleanOrUndefined" => Ok(AxValueType::BooleanOrUndefined),
                "idref" => Ok(AxValueType::Idref),
                "idrefList" => Ok(AxValueType::IdrefList),
                "integer" => Ok(AxValueType::Integer),
                "node" => Ok(AxValueType::Node),
                "nodeList" => Ok(AxValueType::NodeList),
                "number" => Ok(AxValueType::Number),
                "string" => Ok(AxValueType::String),
                "computedString" => Ok(AxValueType::ComputedString),
                "token" => Ok(AxValueType::Token),
                "tokenList" => Ok(AxValueType::TokenList),
                "domRelation" => Ok(AxValueType::DomRelation),
                "role" => Ok(AxValueType::Role),
                "internalRole" => Ok(AxValueType::InternalRole),
                "valueUndefined" => Ok(AxValueType::ValueUndefined),
                _ => Err(::proto::ParseEnumError {
                    expected: AxValueType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for AxValueType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    AxValueType::Boolean => "boolean",
                    AxValueType::Tristate => "tristate",
                    AxValueType::BooleanOrUndefined => "booleanOrUndefined",
                    AxValueType::Idref => "idref",
                    AxValueType::IdrefList => "idrefList",
                    AxValueType::Integer => "integer",
                    AxValueType::Node => "node",
                    AxValueType::NodeList => "nodeList",
                    AxValueType::Number => "number",
                    AxValueType::String => "string",
                    AxValueType::ComputedString => "computedString",
                    AxValueType::Token => "token",
                    AxValueType::TokenList => "tokenList",
                    AxValueType::DomRelation => "domRelation",
                    AxValueType::Role => "role",
                    AxValueType::InternalRole => "internalRole",
                    AxValueType::ValueUndefined => "valueUndefined",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enum of possible property sources."]
    pub enum AxValueSourceType {
        #[serde(rename = "attribute")]
        #[doc = "Represented as `\"attribute\"`."]
        Attribute,
        #[serde(rename = "implicit")]
        #[doc = "Represented as `\"implicit\"`."]
        Implicit,
        #[serde(rename = "style")]
        #[doc = "Represented as `\"style\"`."]
        Style,
        #[serde(rename = "contents")]
        #[doc = "Represented as `\"contents\"`."]
        Contents,
        #[serde(rename = "placeholder")]
        #[doc = "Represented as `\"placeholder\"`."]
        Placeholder,
        #[serde(rename = "relatedElement")]
        #[doc = "Represented as `\"relatedElement\"`."]
        RelatedElement,
    }
    impl AxValueSourceType {
        pub const ENUM_VALUES: &'static [AxValueSourceType] = &[
            AxValueSourceType::Attribute,
            AxValueSourceType::Implicit,
            AxValueSourceType::Style,
            AxValueSourceType::Contents,
            AxValueSourceType::Placeholder,
            AxValueSourceType::RelatedElement,
        ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "attribute",
            "implicit",
            "style",
            "contents",
            "placeholder",
            "relatedElement",
        ];
    }
    impl ::std::str::FromStr for AxValueSourceType {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "attribute" => Ok(AxValueSourceType::Attribute),
                "implicit" => Ok(AxValueSourceType::Implicit),
                "style" => Ok(AxValueSourceType::Style),
                "contents" => Ok(AxValueSourceType::Contents),
                "placeholder" => Ok(AxValueSourceType::Placeholder),
                "relatedElement" => Ok(AxValueSourceType::RelatedElement),
                _ => Err(::proto::ParseEnumError {
                    expected: AxValueSourceType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for AxValueSourceType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    AxValueSourceType::Attribute => "attribute",
                    AxValueSourceType::Implicit => "implicit",
                    AxValueSourceType::Style => "style",
                    AxValueSourceType::Contents => "contents",
                    AxValueSourceType::Placeholder => "placeholder",
                    AxValueSourceType::RelatedElement => "relatedElement",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enum of possible native property sources \\(as a subtype of a particular AXValueSourceType\\)."]
    pub enum AxValueNativeSourceType {
        #[serde(rename = "figcaption")]
        #[doc = "Represented as `\"figcaption\"`."]
        Figcaption,
        #[serde(rename = "label")]
        #[doc = "Represented as `\"label\"`."]
        Label,
        #[serde(rename = "labelfor")]
        #[doc = "Represented as `\"labelfor\"`."]
        Labelfor,
        #[serde(rename = "labelwrapped")]
        #[doc = "Represented as `\"labelwrapped\"`."]
        Labelwrapped,
        #[serde(rename = "legend")]
        #[doc = "Represented as `\"legend\"`."]
        Legend,
        #[serde(rename = "tablecaption")]
        #[doc = "Represented as `\"tablecaption\"`."]
        Tablecaption,
        #[serde(rename = "title")]
        #[doc = "Represented as `\"title\"`."]
        Title,
        #[serde(rename = "other")]
        #[doc = "Represented as `\"other\"`."]
        Other,
    }
    impl AxValueNativeSourceType {
        pub const ENUM_VALUES: &'static [AxValueNativeSourceType] =
            &[
                AxValueNativeSourceType::Figcaption,
                AxValueNativeSourceType::Label,
                AxValueNativeSourceType::Labelfor,
                AxValueNativeSourceType::Labelwrapped,
                AxValueNativeSourceType::Legend,
                AxValueNativeSourceType::Tablecaption,
                AxValueNativeSourceType::Title,
                AxValueNativeSourceType::Other,
            ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "figcaption",
            "label",
            "labelfor",
            "labelwrapped",
            "legend",
            "tablecaption",
            "title",
            "other",
        ];
    }
    impl ::std::str::FromStr for AxValueNativeSourceType {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "figcaption" => Ok(AxValueNativeSourceType::Figcaption),
                "label" => Ok(AxValueNativeSourceType::Label),
                "labelfor" => Ok(AxValueNativeSourceType::Labelfor),
                "labelwrapped" => Ok(AxValueNativeSourceType::Labelwrapped),
                "legend" => Ok(AxValueNativeSourceType::Legend),
                "tablecaption" => Ok(AxValueNativeSourceType::Tablecaption),
                "title" => Ok(AxValueNativeSourceType::Title),
                "other" => Ok(AxValueNativeSourceType::Other),
                _ => Err(::proto::ParseEnumError {
                    expected: AxValueNativeSourceType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for AxValueNativeSourceType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    AxValueNativeSourceType::Figcaption => "figcaption",
                    AxValueNativeSourceType::Label => "label",
                    AxValueNativeSourceType::Labelfor => "labelfor",
                    AxValueNativeSourceType::Labelwrapped => "labelwrapped",
                    AxValueNativeSourceType::Legend => "legend",
                    AxValueNativeSourceType::Tablecaption => "tablecaption",
                    AxValueNativeSourceType::Title => "title",
                    AxValueNativeSourceType::Other => "other",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> A single source for a computed AX property."]
    pub struct AxValueSource<'a> {
        #[serde(rename = "type")]
        #[doc = "What type of source this is."]
        pub ty: ::proto::accessibility::AxValueSourceType,
        #[serde(rename = "value", skip_serializing_if = "Option::is_none")]
        #[doc = "The value of this property source."]
        pub value: Option<::proto::accessibility::AxValue<'a>>,
        #[serde(rename = "attribute", skip_serializing_if = "Option::is_none")]
        #[doc = "The name of the relevant attribute, if any."]
        pub attribute: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "attributeValue", skip_serializing_if = "Option::is_none")]
        #[doc = "The value of the relevant attribute, if any."]
        pub attribute_value: Option<::proto::accessibility::AxValue<'a>>,
        #[serde(rename = "superseded", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether this source is superseded by a higher priority source."]
        pub superseded: Option<bool>,
        #[serde(rename = "nativeSource", skip_serializing_if = "Option::is_none")]
        #[doc = "The native markup source for this value, e.g. a <label> element."]
        pub native_source: Option<::proto::accessibility::AxValueNativeSourceType>,
        #[serde(rename = "nativeSourceValue", skip_serializing_if = "Option::is_none")]
        #[doc = "The value, such as a node or node list, of the native source."]
        pub native_source_value: Option<::proto::accessibility::AxValue<'a>>,
        #[serde(rename = "invalid", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether the value for this property is invalid."]
        pub invalid: Option<bool>,
        #[serde(rename = "invalidReason", skip_serializing_if = "Option::is_none")]
        #[doc = "Reason for the value being invalid, if it is."]
        pub invalid_reason: Option<::std::borrow::Cow<'a, str>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>"]
    pub struct AxRelatedNode<'a> {
        #[serde(rename = "backendDOMNodeId")]
        #[doc = "The BackendNodeId of the related DOM node."]
        pub backend_dom_node_id: ::proto::dom::BackendNodeId,
        #[serde(rename = "idref", skip_serializing_if = "Option::is_none")]
        #[doc = "The IDRef value provided, if any."]
        pub idref: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "text", skip_serializing_if = "Option::is_none")]
        #[doc = "The text alternative of this node in the current context."]
        pub text: Option<::std::borrow::Cow<'a, str>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>"]
    pub struct AxProperty<'a> {
        #[serde(rename = "name")]
        #[doc = "The name of this property."]
        pub name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "value")]
        #[doc = "The value of this property."]
        pub value: ::proto::accessibility::AxValue<'a>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> A single computed AX property."]
    pub struct AxValue<'a> {
        #[serde(rename = "type")]
        #[doc = "The type of this value."]
        pub ty: ::proto::accessibility::AxValueType,
        #[serde(rename = "value", skip_serializing_if = "Option::is_none")]
        #[doc = "The computed value of this property."]
        pub value: Option<::serde_json::Value>,
        #[serde(rename = "relatedNodes", skip_serializing_if = "Option::is_none")]
        #[doc = "One or more related nodes, if applicable."]
        pub related_nodes: Option<Vec<::proto::accessibility::AxRelatedNode<'a>>>,
        #[serde(rename = "sources", skip_serializing_if = "Option::is_none")]
        #[doc = "The sources which contributed to the computation of this property."]
        pub sources: Option<Vec<::proto::accessibility::AxValueSource<'a>>>,
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> States which apply to every AX node."]
    pub enum AxGlobalStates {
        #[serde(rename = "disabled")]
        #[doc = "Represented as `\"disabled\"`."]
        Disabled,
        #[serde(rename = "hidden")]
        #[doc = "Represented as `\"hidden\"`."]
        Hidden,
        #[serde(rename = "hiddenRoot")]
        #[doc = "Represented as `\"hiddenRoot\"`."]
        HiddenRoot,
        #[serde(rename = "invalid")]
        #[doc = "Represented as `\"invalid\"`."]
        Invalid,
        #[serde(rename = "keyshortcuts")]
        #[doc = "Represented as `\"keyshortcuts\"`."]
        Keyshortcuts,
        #[serde(rename = "roledescription")]
        #[doc = "Represented as `\"roledescription\"`."]
        Roledescription,
    }
    impl AxGlobalStates {
        pub const ENUM_VALUES: &'static [AxGlobalStates] = &[
            AxGlobalStates::Disabled,
            AxGlobalStates::Hidden,
            AxGlobalStates::HiddenRoot,
            AxGlobalStates::Invalid,
            AxGlobalStates::Keyshortcuts,
            AxGlobalStates::Roledescription,
        ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "disabled",
            "hidden",
            "hiddenRoot",
            "invalid",
            "keyshortcuts",
            "roledescription",
        ];
    }
    impl ::std::str::FromStr for AxGlobalStates {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "disabled" => Ok(AxGlobalStates::Disabled),
                "hidden" => Ok(AxGlobalStates::Hidden),
                "hiddenRoot" => Ok(AxGlobalStates::HiddenRoot),
                "invalid" => Ok(AxGlobalStates::Invalid),
                "keyshortcuts" => Ok(AxGlobalStates::Keyshortcuts),
                "roledescription" => Ok(AxGlobalStates::Roledescription),
                _ => Err(::proto::ParseEnumError {
                    expected: AxGlobalStates::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for AxGlobalStates {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    AxGlobalStates::Disabled => "disabled",
                    AxGlobalStates::Hidden => "hidden",
                    AxGlobalStates::HiddenRoot => "hiddenRoot",
                    AxGlobalStates::Invalid => "invalid",
                    AxGlobalStates::Keyshortcuts => "keyshortcuts",
                    AxGlobalStates::Roledescription => "roledescription",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Attributes which apply to nodes in live regions."]
    pub enum AxLiveRegionAttributes {
        #[serde(rename = "live")]
        #[doc = "Represented as `\"live\"`."]
        Live,
        #[serde(rename = "atomic")]
        #[doc = "Represented as `\"atomic\"`."]
        Atomic,
        #[serde(rename = "relevant")]
        #[doc = "Represented as `\"relevant\"`."]
        Relevant,
        #[serde(rename = "busy")]
        #[doc = "Represented as `\"busy\"`."]
        Busy,
        #[serde(rename = "root")]
        #[doc = "Represented as `\"root\"`."]
        Root,
    }
    impl AxLiveRegionAttributes {
        pub const ENUM_VALUES: &'static [AxLiveRegionAttributes] =
            &[
                AxLiveRegionAttributes::Live,
                AxLiveRegionAttributes::Atomic,
                AxLiveRegionAttributes::Relevant,
                AxLiveRegionAttributes::Busy,
                AxLiveRegionAttributes::Root,
            ];
        pub const STR_VALUES: &'static [&'static str] =
            &["live", "atomic", "relevant", "busy", "root"];
    }
    impl ::std::str::FromStr for AxLiveRegionAttributes {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "live" => Ok(AxLiveRegionAttributes::Live),
                "atomic" => Ok(AxLiveRegionAttributes::Atomic),
                "relevant" => Ok(AxLiveRegionAttributes::Relevant),
                "busy" => Ok(AxLiveRegionAttributes::Busy),
                "root" => Ok(AxLiveRegionAttributes::Root),
                _ => Err(::proto::ParseEnumError {
                    expected: AxLiveRegionAttributes::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for AxLiveRegionAttributes {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    AxLiveRegionAttributes::Live => "live",
                    AxLiveRegionAttributes::Atomic => "atomic",
                    AxLiveRegionAttributes::Relevant => "relevant",
                    AxLiveRegionAttributes::Busy => "busy",
                    AxLiveRegionAttributes::Root => "root",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Attributes which apply to widgets."]
    pub enum AxWidgetAttributes {
        #[serde(rename = "autocomplete")]
        #[doc = "Represented as `\"autocomplete\"`."]
        Autocomplete,
        #[serde(rename = "haspopup")]
        #[doc = "Represented as `\"haspopup\"`."]
        Haspopup,
        #[serde(rename = "level")]
        #[doc = "Represented as `\"level\"`."]
        Level,
        #[serde(rename = "multiselectable")]
        #[doc = "Represented as `\"multiselectable\"`."]
        Multiselectable,
        #[serde(rename = "orientation")]
        #[doc = "Represented as `\"orientation\"`."]
        Orientation,
        #[serde(rename = "multiline")]
        #[doc = "Represented as `\"multiline\"`."]
        Multiline,
        #[serde(rename = "readonly")]
        #[doc = "Represented as `\"readonly\"`."]
        Readonly,
        #[serde(rename = "required")]
        #[doc = "Represented as `\"required\"`."]
        Required,
        #[serde(rename = "valuemin")]
        #[doc = "Represented as `\"valuemin\"`."]
        Valuemin,
        #[serde(rename = "valuemax")]
        #[doc = "Represented as `\"valuemax\"`."]
        Valuemax,
        #[serde(rename = "valuetext")]
        #[doc = "Represented as `\"valuetext\"`."]
        Valuetext,
    }
    impl AxWidgetAttributes {
        pub const ENUM_VALUES: &'static [AxWidgetAttributes] = &[
            AxWidgetAttributes::Autocomplete,
            AxWidgetAttributes::Haspopup,
            AxWidgetAttributes::Level,
            AxWidgetAttributes::Multiselectable,
            AxWidgetAttributes::Orientation,
            AxWidgetAttributes::Multiline,
            AxWidgetAttributes::Readonly,
            AxWidgetAttributes::Required,
            AxWidgetAttributes::Valuemin,
            AxWidgetAttributes::Valuemax,
            AxWidgetAttributes::Valuetext,
        ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "autocomplete",
            "haspopup",
            "level",
            "multiselectable",
            "orientation",
            "multiline",
            "readonly",
            "required",
            "valuemin",
            "valuemax",
            "valuetext",
        ];
    }
    impl ::std::str::FromStr for AxWidgetAttributes {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "autocomplete" => Ok(AxWidgetAttributes::Autocomplete),
                "haspopup" => Ok(AxWidgetAttributes::Haspopup),
                "level" => Ok(AxWidgetAttributes::Level),
                "multiselectable" => Ok(AxWidgetAttributes::Multiselectable),
                "orientation" => Ok(AxWidgetAttributes::Orientation),
                "multiline" => Ok(AxWidgetAttributes::Multiline),
                "readonly" => Ok(AxWidgetAttributes::Readonly),
                "required" => Ok(AxWidgetAttributes::Required),
                "valuemin" => Ok(AxWidgetAttributes::Valuemin),
                "valuemax" => Ok(AxWidgetAttributes::Valuemax),
                "valuetext" => Ok(AxWidgetAttributes::Valuetext),
                _ => Err(::proto::ParseEnumError {
                    expected: AxWidgetAttributes::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for AxWidgetAttributes {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    AxWidgetAttributes::Autocomplete => "autocomplete",
                    AxWidgetAttributes::Haspopup => "haspopup",
                    AxWidgetAttributes::Level => "level",
                    AxWidgetAttributes::Multiselectable => "multiselectable",
                    AxWidgetAttributes::Orientation => "orientation",
                    AxWidgetAttributes::Multiline => "multiline",
                    AxWidgetAttributes::Readonly => "readonly",
                    AxWidgetAttributes::Required => "required",
                    AxWidgetAttributes::Valuemin => "valuemin",
                    AxWidgetAttributes::Valuemax => "valuemax",
                    AxWidgetAttributes::Valuetext => "valuetext",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> States which apply to widgets."]
    pub enum AxWidgetStates {
        #[serde(rename = "checked")]
        #[doc = "Represented as `\"checked\"`."]
        Checked,
        #[serde(rename = "expanded")]
        #[doc = "Represented as `\"expanded\"`."]
        Expanded,
        #[serde(rename = "modal")]
        #[doc = "Represented as `\"modal\"`."]
        Modal,
        #[serde(rename = "pressed")]
        #[doc = "Represented as `\"pressed\"`."]
        Pressed,
        #[serde(rename = "selected")]
        #[doc = "Represented as `\"selected\"`."]
        Selected,
    }
    impl AxWidgetStates {
        pub const ENUM_VALUES: &'static [AxWidgetStates] = &[
            AxWidgetStates::Checked,
            AxWidgetStates::Expanded,
            AxWidgetStates::Modal,
            AxWidgetStates::Pressed,
            AxWidgetStates::Selected,
        ];
        pub const STR_VALUES: &'static [&'static str] =
            &["checked", "expanded", "modal", "pressed", "selected"];
    }
    impl ::std::str::FromStr for AxWidgetStates {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "checked" => Ok(AxWidgetStates::Checked),
                "expanded" => Ok(AxWidgetStates::Expanded),
                "modal" => Ok(AxWidgetStates::Modal),
                "pressed" => Ok(AxWidgetStates::Pressed),
                "selected" => Ok(AxWidgetStates::Selected),
                _ => Err(::proto::ParseEnumError {
                    expected: AxWidgetStates::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for AxWidgetStates {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    AxWidgetStates::Checked => "checked",
                    AxWidgetStates::Expanded => "expanded",
                    AxWidgetStates::Modal => "modal",
                    AxWidgetStates::Pressed => "pressed",
                    AxWidgetStates::Selected => "selected",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Relationships between elements other than parent/child/sibling."]
    pub enum AxRelationshipAttributes {
        #[serde(rename = "activedescendant")]
        #[doc = "Represented as `\"activedescendant\"`."]
        Activedescendant,
        #[serde(rename = "controls")]
        #[doc = "Represented as `\"controls\"`."]
        Controls,
        #[serde(rename = "describedby")]
        #[doc = "Represented as `\"describedby\"`."]
        Describedby,
        #[serde(rename = "details")]
        #[doc = "Represented as `\"details\"`."]
        Details,
        #[serde(rename = "errormessage")]
        #[doc = "Represented as `\"errormessage\"`."]
        Errormessage,
        #[serde(rename = "flowto")]
        #[doc = "Represented as `\"flowto\"`."]
        Flowto,
        #[serde(rename = "labelledby")]
        #[doc = "Represented as `\"labelledby\"`."]
        Labelledby,
        #[serde(rename = "owns")]
        #[doc = "Represented as `\"owns\"`."]
        Owns,
    }
    impl AxRelationshipAttributes {
        pub const ENUM_VALUES: &'static [AxRelationshipAttributes] =
            &[
                AxRelationshipAttributes::Activedescendant,
                AxRelationshipAttributes::Controls,
                AxRelationshipAttributes::Describedby,
                AxRelationshipAttributes::Details,
                AxRelationshipAttributes::Errormessage,
                AxRelationshipAttributes::Flowto,
                AxRelationshipAttributes::Labelledby,
                AxRelationshipAttributes::Owns,
            ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "activedescendant",
            "controls",
            "describedby",
            "details",
            "errormessage",
            "flowto",
            "labelledby",
            "owns",
        ];
    }
    impl ::std::str::FromStr for AxRelationshipAttributes {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "activedescendant" => Ok(AxRelationshipAttributes::Activedescendant),
                "controls" => Ok(AxRelationshipAttributes::Controls),
                "describedby" => Ok(AxRelationshipAttributes::Describedby),
                "details" => Ok(AxRelationshipAttributes::Details),
                "errormessage" => Ok(AxRelationshipAttributes::Errormessage),
                "flowto" => Ok(AxRelationshipAttributes::Flowto),
                "labelledby" => Ok(AxRelationshipAttributes::Labelledby),
                "owns" => Ok(AxRelationshipAttributes::Owns),
                _ => Err(::proto::ParseEnumError {
                    expected: AxRelationshipAttributes::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for AxRelationshipAttributes {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    AxRelationshipAttributes::Activedescendant => "activedescendant",
                    AxRelationshipAttributes::Controls => "controls",
                    AxRelationshipAttributes::Describedby => "describedby",
                    AxRelationshipAttributes::Details => "details",
                    AxRelationshipAttributes::Errormessage => "errormessage",
                    AxRelationshipAttributes::Flowto => "flowto",
                    AxRelationshipAttributes::Labelledby => "labelledby",
                    AxRelationshipAttributes::Owns => "owns",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> A node in the accessibility tree."]
    pub struct AxNode<'a> {
        #[serde(rename = "nodeId")]
        #[doc = "Unique identifier for this node."]
        pub node_id: ::proto::accessibility::AxNodeId<'a>,
        #[serde(rename = "ignored")]
        #[doc = "Whether this node is ignored for accessibility"]
        pub ignored: bool,
        #[serde(rename = "ignoredReasons", skip_serializing_if = "Option::is_none")]
        #[doc = "Collection of reasons why this node is hidden."]
        pub ignored_reasons: Option<Vec<::proto::accessibility::AxProperty<'a>>>,
        #[serde(rename = "role", skip_serializing_if = "Option::is_none")]
        #[doc = "This <code>Node</code>'s role, whether explicit or implicit."]
        pub role: Option<::proto::accessibility::AxValue<'a>>,
        #[serde(rename = "name", skip_serializing_if = "Option::is_none")]
        #[doc = "The accessible name for this <code>Node</code>."]
        pub name: Option<::proto::accessibility::AxValue<'a>>,
        #[serde(rename = "description", skip_serializing_if = "Option::is_none")]
        #[doc = "The accessible description for this <code>Node</code>."]
        pub description: Option<::proto::accessibility::AxValue<'a>>,
        #[serde(rename = "value", skip_serializing_if = "Option::is_none")]
        #[doc = "The value for this <code>Node</code>."]
        pub value: Option<::proto::accessibility::AxValue<'a>>,
        #[serde(rename = "properties", skip_serializing_if = "Option::is_none")]
        #[doc = "All other properties"]
        pub properties: Option<Vec<::proto::accessibility::AxProperty<'a>>>,
        #[serde(rename = "childIds", skip_serializing_if = "Option::is_none")]
        #[doc = "IDs for each of this node's child nodes."]
        pub child_ids: Option<Vec<::proto::accessibility::AxNodeId<'a>>>,
        #[serde(rename = "backendDOMNodeId", skip_serializing_if = "Option::is_none")]
        #[doc = "The backend ID for the associated DOM node, if any."]
        pub backend_dom_node_id: Option<::proto::dom::BackendNodeId>,
    }
}
#[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Storage\n\n## Commands\n\n- [`Storage.clearDataForOrigin`](struct.ClearDataForOriginCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Clears storage for origin.\n- [`Storage.getUsageAndQuota`](struct.GetUsageAndQuotaCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns usage and quota in bytes.\n\n##Types\n\n- [`StorageType`](enum.StorageType.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Enum of possible storage types.\n- [`UsageForType`](struct.UsageForType.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Usage for a storage type.\n"]
pub mod storage {
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Clears storage for origin.\n\n# Command `Storage.clearDataForOrigin`\n\n*Domain Module:* [`cdp::proto::storage`](index.html)  \n*Command Struct:* [`cdp::proto::storage::ClearDataForOriginCommand`](struct.ClearDataForOriginCommand.html)  \n*Response Struct:* [`cdp::proto::storage::ClearDataForOriginResponse`](struct.ClearDataForOriginResponse.html)"]
    pub struct ClearDataForOriginCommand<'a> {
        #[serde(rename = "origin")]
        #[doc = "Security origin."]
        pub origin: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "storageTypes")]
        #[doc = "Comma separated origin names."]
        pub storage_types: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpCommand for ClearDataForOriginCommand<'a> {
        fn command_name(&self) -> &str {
            "Storage.clearDataForOrigin"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for ClearDataForOriginCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Storage.clearDataForOrigin" {
                Ok ( < ClearDataForOriginCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Clears storage for origin.\n\n# Command `Storage.clearDataForOrigin`\n\n*Domain Module:* [`cdp::proto::storage`](index.html)  \n*Command Struct:* [`cdp::proto::storage::ClearDataForOriginCommand`](struct.ClearDataForOriginCommand.html)  \n*Response Struct:* [`cdp::proto::storage::ClearDataForOriginResponse`](struct.ClearDataForOriginResponse.html)"]
    pub struct ClearDataForOriginResponse;
    impl ::serde::Serialize for ClearDataForOriginResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ClearDataForOriginResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ClearDataForOriginResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for ClearDataForOriginCommand<'a> {
        type Response = ClearDataForOriginResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for ClearDataForOriginResponse {
        type Command = ClearDataForOriginCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns usage and quota in bytes.\n\n# Command `Storage.getUsageAndQuota`\n\n*Domain Module:* [`cdp::proto::storage`](index.html)  \n*Command Struct:* [`cdp::proto::storage::GetUsageAndQuotaCommand`](struct.GetUsageAndQuotaCommand.html)  \n*Response Struct:* [`cdp::proto::storage::GetUsageAndQuotaResponse`](struct.GetUsageAndQuotaResponse.html)"]
    pub struct GetUsageAndQuotaCommand<'a> {
        #[serde(rename = "origin")]
        #[doc = "Security origin."]
        pub origin: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpCommand for GetUsageAndQuotaCommand<'a> {
        fn command_name(&self) -> &str {
            "Storage.getUsageAndQuota"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for GetUsageAndQuotaCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Storage.getUsageAndQuota" {
                Ok ( < GetUsageAndQuotaCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns usage and quota in bytes.\n\n# Command `Storage.getUsageAndQuota`\n\n*Domain Module:* [`cdp::proto::storage`](index.html)  \n*Command Struct:* [`cdp::proto::storage::GetUsageAndQuotaCommand`](struct.GetUsageAndQuotaCommand.html)  \n*Response Struct:* [`cdp::proto::storage::GetUsageAndQuotaResponse`](struct.GetUsageAndQuotaResponse.html)"]
    pub struct GetUsageAndQuotaResponse {
        #[serde(rename = "usage")]
        #[doc = "Storage usage \\(bytes\\)."]
        pub usage: f64,
        #[serde(rename = "quota")]
        #[doc = "Storage quota \\(bytes\\)."]
        pub quota: f64,
        #[serde(rename = "usageBreakdown")]
        #[doc = "Storage usage per type \\(bytes\\)."]
        pub usage_breakdown: Vec<::proto::storage::UsageForType>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for GetUsageAndQuotaCommand<'a> {
        type Response = GetUsageAndQuotaResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for GetUsageAndQuotaResponse {
        type Command = GetUsageAndQuotaCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enum of possible storage types."]
    pub enum StorageType {
        #[serde(rename = "appcache")]
        #[doc = "Represented as `\"appcache\"`."]
        Appcache,
        #[serde(rename = "cookies")]
        #[doc = "Represented as `\"cookies\"`."]
        Cookies,
        #[serde(rename = "file_systems")]
        #[doc = "Represented as `\"file_systems\"`."]
        FileSystems,
        #[serde(rename = "indexeddb")]
        #[doc = "Represented as `\"indexeddb\"`."]
        Indexeddb,
        #[serde(rename = "local_storage")]
        #[doc = "Represented as `\"local_storage\"`."]
        LocalStorage,
        #[serde(rename = "shader_cache")]
        #[doc = "Represented as `\"shader_cache\"`."]
        ShaderCache,
        #[serde(rename = "websql")]
        #[doc = "Represented as `\"websql\"`."]
        Websql,
        #[serde(rename = "service_workers")]
        #[doc = "Represented as `\"service_workers\"`."]
        ServiceWorkers,
        #[serde(rename = "cache_storage")]
        #[doc = "Represented as `\"cache_storage\"`."]
        CacheStorage,
        #[serde(rename = "all")]
        #[doc = "Represented as `\"all\"`."]
        All,
        #[serde(rename = "other")]
        #[doc = "Represented as `\"other\"`."]
        Other,
    }
    impl StorageType {
        pub const ENUM_VALUES: &'static [StorageType] = &[
            StorageType::Appcache,
            StorageType::Cookies,
            StorageType::FileSystems,
            StorageType::Indexeddb,
            StorageType::LocalStorage,
            StorageType::ShaderCache,
            StorageType::Websql,
            StorageType::ServiceWorkers,
            StorageType::CacheStorage,
            StorageType::All,
            StorageType::Other,
        ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "appcache",
            "cookies",
            "file_systems",
            "indexeddb",
            "local_storage",
            "shader_cache",
            "websql",
            "service_workers",
            "cache_storage",
            "all",
            "other",
        ];
    }
    impl ::std::str::FromStr for StorageType {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "appcache" => Ok(StorageType::Appcache),
                "cookies" => Ok(StorageType::Cookies),
                "file_systems" => Ok(StorageType::FileSystems),
                "indexeddb" => Ok(StorageType::Indexeddb),
                "local_storage" => Ok(StorageType::LocalStorage),
                "shader_cache" => Ok(StorageType::ShaderCache),
                "websql" => Ok(StorageType::Websql),
                "service_workers" => Ok(StorageType::ServiceWorkers),
                "cache_storage" => Ok(StorageType::CacheStorage),
                "all" => Ok(StorageType::All),
                "other" => Ok(StorageType::Other),
                _ => Err(::proto::ParseEnumError {
                    expected: StorageType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for StorageType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    StorageType::Appcache => "appcache",
                    StorageType::Cookies => "cookies",
                    StorageType::FileSystems => "file_systems",
                    StorageType::Indexeddb => "indexeddb",
                    StorageType::LocalStorage => "local_storage",
                    StorageType::ShaderCache => "shader_cache",
                    StorageType::Websql => "websql",
                    StorageType::ServiceWorkers => "service_workers",
                    StorageType::CacheStorage => "cache_storage",
                    StorageType::All => "all",
                    StorageType::Other => "other",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Usage for a storage type."]
    pub struct UsageForType {
        #[serde(rename = "storageType")]
        #[doc = "Name of storage type."]
        pub storage_type: ::proto::storage::StorageType,
        #[serde(rename = "usage")]
        #[doc = "Storage usage \\(bytes\\)."]
        pub usage: f64,
    }
}
#[doc = "<span class=\"stab unstable\">[Experimental]</span> Provides access to log entries.\n\n# Log\n\n## Commands\n\n- [`Log.enable`](struct.EnableCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Enables log domain, sends the entries collected so far to the client by means of the <code>entryAdded</code> notification.\n- [`Log.disable`](struct.DisableCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Disables log domain, prevents further log entries from being reported to the client.\n- [`Log.clear`](struct.ClearCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Clears the log.\n- [`Log.startViolationsReport`](struct.StartViolationsReportCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  start violation reporting.\n- [`Log.stopViolationsReport`](struct.StopViolationsReportCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Stop violation reporting.\n\n## Events\n\n- [`Log.entryAdded`](struct.EntryAddedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Issued when new message was logged.\n\n##Types\n\n- [`LogEntry`](struct.LogEntry.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Log entry.\n- [`ViolationSetting`](struct.ViolationSetting.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Violation configuration setting.\n"]
pub mod log {
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables log domain, sends the entries collected so far to the client by means of the <code>entryAdded</code> notification.\n\n# Command `Log.enable`\n\n*Domain Module:* [`cdp::proto::log`](index.html)  \n*Command Struct:* [`cdp::proto::log::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::proto::log::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableCommand;
    impl ::serde::Serialize for EnableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for EnableCommand {
        fn command_name(&self) -> &str {
            "Log.enable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for EnableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Log.enable" {
                Ok(
                    <EnableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables log domain, sends the entries collected so far to the client by means of the <code>entryAdded</code> notification.\n\n# Command `Log.enable`\n\n*Domain Module:* [`cdp::proto::log`](index.html)  \n*Command Struct:* [`cdp::proto::log::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::proto::log::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableResponse;
    impl ::serde::Serialize for EnableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for EnableCommand {
        type Response = EnableResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for EnableResponse {
        type Command = EnableCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Disables log domain, prevents further log entries from being reported to the client.\n\n# Command `Log.disable`\n\n*Domain Module:* [`cdp::proto::log`](index.html)  \n*Command Struct:* [`cdp::proto::log::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::proto::log::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableCommand;
    impl ::serde::Serialize for DisableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for DisableCommand {
        fn command_name(&self) -> &str {
            "Log.disable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for DisableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Log.disable" {
                Ok(
                    <DisableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Disables log domain, prevents further log entries from being reported to the client.\n\n# Command `Log.disable`\n\n*Domain Module:* [`cdp::proto::log`](index.html)  \n*Command Struct:* [`cdp::proto::log::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::proto::log::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableResponse;
    impl ::serde::Serialize for DisableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for DisableCommand {
        type Response = DisableResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for DisableResponse {
        type Command = DisableCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Clears the log.\n\n# Command `Log.clear`\n\n*Domain Module:* [`cdp::proto::log`](index.html)  \n*Command Struct:* [`cdp::proto::log::ClearCommand`](struct.ClearCommand.html)  \n*Response Struct:* [`cdp::proto::log::ClearResponse`](struct.ClearResponse.html)"]
    pub struct ClearCommand;
    impl ::serde::Serialize for ClearCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ClearCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ClearCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for ClearCommand {
        fn command_name(&self) -> &str {
            "Log.clear"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for ClearCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Log.clear" {
                Ok(
                    <ClearCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Clears the log.\n\n# Command `Log.clear`\n\n*Domain Module:* [`cdp::proto::log`](index.html)  \n*Command Struct:* [`cdp::proto::log::ClearCommand`](struct.ClearCommand.html)  \n*Response Struct:* [`cdp::proto::log::ClearResponse`](struct.ClearResponse.html)"]
    pub struct ClearResponse;
    impl ::serde::Serialize for ClearResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ClearResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ClearResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for ClearCommand {
        type Response = ClearResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for ClearResponse {
        type Command = ClearCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> start violation reporting.\n\n# Command `Log.startViolationsReport`\n\n*Domain Module:* [`cdp::proto::log`](index.html)  \n*Command Struct:* [`cdp::proto::log::StartViolationsReportCommand`](struct.StartViolationsReportCommand.html)  \n*Response Struct:* [`cdp::proto::log::StartViolationsReportResponse`](struct.StartViolationsReportResponse.html)"]
    pub struct StartViolationsReportCommand {
        #[serde(rename = "config")]
        #[doc = "Configuration for violations."]
        pub config: Vec<::proto::log::ViolationSetting>,
    }
    impl ::traits::SerializeCdpCommand for StartViolationsReportCommand {
        fn command_name(&self) -> &str {
            "Log.startViolationsReport"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for StartViolationsReportCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Log.startViolationsReport" {
                Ok ( < StartViolationsReportCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> start violation reporting.\n\n# Command `Log.startViolationsReport`\n\n*Domain Module:* [`cdp::proto::log`](index.html)  \n*Command Struct:* [`cdp::proto::log::StartViolationsReportCommand`](struct.StartViolationsReportCommand.html)  \n*Response Struct:* [`cdp::proto::log::StartViolationsReportResponse`](struct.StartViolationsReportResponse.html)"]
    pub struct StartViolationsReportResponse;
    impl ::serde::Serialize for StartViolationsReportResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StartViolationsReportResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StartViolationsReportResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for StartViolationsReportCommand {
        type Response = StartViolationsReportResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for StartViolationsReportResponse {
        type Command = StartViolationsReportCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Stop violation reporting.\n\n# Command `Log.stopViolationsReport`\n\n*Domain Module:* [`cdp::proto::log`](index.html)  \n*Command Struct:* [`cdp::proto::log::StopViolationsReportCommand`](struct.StopViolationsReportCommand.html)  \n*Response Struct:* [`cdp::proto::log::StopViolationsReportResponse`](struct.StopViolationsReportResponse.html)"]
    pub struct StopViolationsReportCommand;
    impl ::serde::Serialize for StopViolationsReportCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StopViolationsReportCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StopViolationsReportCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for StopViolationsReportCommand {
        fn command_name(&self) -> &str {
            "Log.stopViolationsReport"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for StopViolationsReportCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Log.stopViolationsReport" {
                Ok ( < StopViolationsReportCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Stop violation reporting.\n\n# Command `Log.stopViolationsReport`\n\n*Domain Module:* [`cdp::proto::log`](index.html)  \n*Command Struct:* [`cdp::proto::log::StopViolationsReportCommand`](struct.StopViolationsReportCommand.html)  \n*Response Struct:* [`cdp::proto::log::StopViolationsReportResponse`](struct.StopViolationsReportResponse.html)"]
    pub struct StopViolationsReportResponse;
    impl ::serde::Serialize for StopViolationsReportResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StopViolationsReportResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StopViolationsReportResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for StopViolationsReportCommand {
        type Response = StopViolationsReportResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for StopViolationsReportResponse {
        type Command = StopViolationsReportCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Issued when new message was logged.\n\n# Event `Log.entryAdded`\n\n*Domain Module:* [`cdp::proto::log`](index.html)  \n*Event Struct:* [`cdp::proto::log::EntryAddedEvent`](struct.EntryAddedEvent.html)"]
    pub struct EntryAddedEvent<'a> {
        #[serde(rename = "entry")]
        #[doc = "The entry."]
        pub entry: ::proto::log::LogEntry<'a>,
    }
    impl<'a> ::traits::SerializeCdpEvent for EntryAddedEvent<'a> {
        fn event_name(&self) -> &str {
            "Log.entryAdded"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for EntryAddedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Log.entryAdded" {
                Ok(
                    <EntryAddedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\nUsed in the type of [`cdp::proto::log::LogEntry::source`](struct.LogEntry.html#structfield.source)."]
    pub enum LogEntrySource {
        #[serde(rename = "xml")]
        #[doc = "Represented as `\"xml\"`."]
        Xml,
        #[serde(rename = "javascript")]
        #[doc = "Represented as `\"javascript\"`."]
        Javascript,
        #[serde(rename = "network")]
        #[doc = "Represented as `\"network\"`."]
        Network,
        #[serde(rename = "storage")]
        #[doc = "Represented as `\"storage\"`."]
        Storage,
        #[serde(rename = "appcache")]
        #[doc = "Represented as `\"appcache\"`."]
        Appcache,
        #[serde(rename = "rendering")]
        #[doc = "Represented as `\"rendering\"`."]
        Rendering,
        #[serde(rename = "security")]
        #[doc = "Represented as `\"security\"`."]
        Security,
        #[serde(rename = "deprecation")]
        #[doc = "Represented as `\"deprecation\"`."]
        Deprecation,
        #[serde(rename = "worker")]
        #[doc = "Represented as `\"worker\"`."]
        Worker,
        #[serde(rename = "violation")]
        #[doc = "Represented as `\"violation\"`."]
        Violation,
        #[serde(rename = "intervention")]
        #[doc = "Represented as `\"intervention\"`."]
        Intervention,
        #[serde(rename = "other")]
        #[doc = "Represented as `\"other\"`."]
        Other,
    }
    impl LogEntrySource {
        pub const ENUM_VALUES: &'static [LogEntrySource] = &[
            LogEntrySource::Xml,
            LogEntrySource::Javascript,
            LogEntrySource::Network,
            LogEntrySource::Storage,
            LogEntrySource::Appcache,
            LogEntrySource::Rendering,
            LogEntrySource::Security,
            LogEntrySource::Deprecation,
            LogEntrySource::Worker,
            LogEntrySource::Violation,
            LogEntrySource::Intervention,
            LogEntrySource::Other,
        ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "xml",
            "javascript",
            "network",
            "storage",
            "appcache",
            "rendering",
            "security",
            "deprecation",
            "worker",
            "violation",
            "intervention",
            "other",
        ];
    }
    impl ::std::str::FromStr for LogEntrySource {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "xml" => Ok(LogEntrySource::Xml),
                "javascript" => Ok(LogEntrySource::Javascript),
                "network" => Ok(LogEntrySource::Network),
                "storage" => Ok(LogEntrySource::Storage),
                "appcache" => Ok(LogEntrySource::Appcache),
                "rendering" => Ok(LogEntrySource::Rendering),
                "security" => Ok(LogEntrySource::Security),
                "deprecation" => Ok(LogEntrySource::Deprecation),
                "worker" => Ok(LogEntrySource::Worker),
                "violation" => Ok(LogEntrySource::Violation),
                "intervention" => Ok(LogEntrySource::Intervention),
                "other" => Ok(LogEntrySource::Other),
                _ => Err(::proto::ParseEnumError {
                    expected: LogEntrySource::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for LogEntrySource {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    LogEntrySource::Xml => "xml",
                    LogEntrySource::Javascript => "javascript",
                    LogEntrySource::Network => "network",
                    LogEntrySource::Storage => "storage",
                    LogEntrySource::Appcache => "appcache",
                    LogEntrySource::Rendering => "rendering",
                    LogEntrySource::Security => "security",
                    LogEntrySource::Deprecation => "deprecation",
                    LogEntrySource::Worker => "worker",
                    LogEntrySource::Violation => "violation",
                    LogEntrySource::Intervention => "intervention",
                    LogEntrySource::Other => "other",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\nUsed in the type of [`cdp::proto::log::LogEntry::level`](struct.LogEntry.html#structfield.level)."]
    pub enum LogEntryLevel {
        #[serde(rename = "verbose")]
        #[doc = "Represented as `\"verbose\"`."]
        Verbose,
        #[serde(rename = "info")]
        #[doc = "Represented as `\"info\"`."]
        Info,
        #[serde(rename = "warning")]
        #[doc = "Represented as `\"warning\"`."]
        Warning,
        #[serde(rename = "error")]
        #[doc = "Represented as `\"error\"`."]
        Error,
    }
    impl LogEntryLevel {
        pub const ENUM_VALUES: &'static [LogEntryLevel] = &[
            LogEntryLevel::Verbose,
            LogEntryLevel::Info,
            LogEntryLevel::Warning,
            LogEntryLevel::Error,
        ];
        pub const STR_VALUES: &'static [&'static str] = &["verbose", "info", "warning", "error"];
    }
    impl ::std::str::FromStr for LogEntryLevel {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "verbose" => Ok(LogEntryLevel::Verbose),
                "info" => Ok(LogEntryLevel::Info),
                "warning" => Ok(LogEntryLevel::Warning),
                "error" => Ok(LogEntryLevel::Error),
                _ => Err(::proto::ParseEnumError {
                    expected: LogEntryLevel::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for LogEntryLevel {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    LogEntryLevel::Verbose => "verbose",
                    LogEntryLevel::Info => "info",
                    LogEntryLevel::Warning => "warning",
                    LogEntryLevel::Error => "error",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Log entry."]
    pub struct LogEntry<'a> {
        #[serde(rename = "source")]
        #[doc = "Log entry source."]
        pub source: ::proto::log::LogEntrySource,
        #[serde(rename = "level")]
        #[doc = "Log entry severity."]
        pub level: ::proto::log::LogEntryLevel,
        #[serde(rename = "text")]
        #[doc = "Logged text."]
        pub text: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "timestamp")]
        #[doc = "Timestamp when this entry was added."]
        pub timestamp: ::proto::runtime::Timestamp,
        #[serde(rename = "url", skip_serializing_if = "Option::is_none")]
        #[doc = "URL of the resource if known."]
        pub url: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "lineNumber", skip_serializing_if = "Option::is_none")]
        #[doc = "Line number in the resource."]
        pub line_number: Option<i32>,
        #[serde(rename = "stackTrace", skip_serializing_if = "Option::is_none")]
        #[doc = "JavaScript stack trace."]
        pub stack_trace: Option<::proto::runtime::StackTrace<'a>>,
        #[serde(rename = "networkRequestId", skip_serializing_if = "Option::is_none")]
        #[doc = "Identifier of the network request associated with this entry."]
        pub network_request_id: Option<::proto::network::RequestId<'a>>,
        #[serde(rename = "workerId", skip_serializing_if = "Option::is_none")]
        #[doc = "Identifier of the worker associated with this entry."]
        pub worker_id: Option<::std::borrow::Cow<'a, str>>,
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\nUsed in the type of [`cdp::proto::log::ViolationSetting::name`](struct.ViolationSetting.html#structfield.name)."]
    pub enum ViolationSettingName {
        #[serde(rename = "longTask")]
        #[doc = "Represented as `\"longTask\"`."]
        LongTask,
        #[serde(rename = "longLayout")]
        #[doc = "Represented as `\"longLayout\"`."]
        LongLayout,
        #[serde(rename = "blockedEvent")]
        #[doc = "Represented as `\"blockedEvent\"`."]
        BlockedEvent,
        #[serde(rename = "blockedParser")]
        #[doc = "Represented as `\"blockedParser\"`."]
        BlockedParser,
        #[serde(rename = "discouragedAPIUse")]
        #[doc = "Represented as `\"discouragedAPIUse\"`."]
        DiscouragedApiUse,
        #[serde(rename = "handler")]
        #[doc = "Represented as `\"handler\"`."]
        Handler,
        #[serde(rename = "recurringHandler")]
        #[doc = "Represented as `\"recurringHandler\"`."]
        RecurringHandler,
    }
    impl ViolationSettingName {
        pub const ENUM_VALUES: &'static [ViolationSettingName] =
            &[
                ViolationSettingName::LongTask,
                ViolationSettingName::LongLayout,
                ViolationSettingName::BlockedEvent,
                ViolationSettingName::BlockedParser,
                ViolationSettingName::DiscouragedApiUse,
                ViolationSettingName::Handler,
                ViolationSettingName::RecurringHandler,
            ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "longTask",
            "longLayout",
            "blockedEvent",
            "blockedParser",
            "discouragedAPIUse",
            "handler",
            "recurringHandler",
        ];
    }
    impl ::std::str::FromStr for ViolationSettingName {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "longTask" => Ok(ViolationSettingName::LongTask),
                "longLayout" => Ok(ViolationSettingName::LongLayout),
                "blockedEvent" => Ok(ViolationSettingName::BlockedEvent),
                "blockedParser" => Ok(ViolationSettingName::BlockedParser),
                "discouragedAPIUse" => Ok(ViolationSettingName::DiscouragedApiUse),
                "handler" => Ok(ViolationSettingName::Handler),
                "recurringHandler" => Ok(ViolationSettingName::RecurringHandler),
                _ => Err(::proto::ParseEnumError {
                    expected: ViolationSettingName::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for ViolationSettingName {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    ViolationSettingName::LongTask => "longTask",
                    ViolationSettingName::LongLayout => "longLayout",
                    ViolationSettingName::BlockedEvent => "blockedEvent",
                    ViolationSettingName::BlockedParser => "blockedParser",
                    ViolationSettingName::DiscouragedApiUse => "discouragedAPIUse",
                    ViolationSettingName::Handler => "handler",
                    ViolationSettingName::RecurringHandler => "recurringHandler",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Violation configuration setting."]
    pub struct ViolationSetting {
        #[serde(rename = "name")]
        #[doc = "Violation type."]
        pub name: ::proto::log::ViolationSettingName,
        #[serde(rename = "threshold")]
        #[doc = "Time threshold to trigger upon."]
        pub threshold: f64,
    }
}
#[doc = "<span class=\"stab unstable\">[Experimental]</span> The SystemInfo domain defines methods and events for querying low-level system information.\n\n# SystemInfo\n\n## Commands\n\n- [`SystemInfo.getInfo`](struct.GetInfoCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns information about the system.\n\n##Types\n\n- [`GPUDevice`](struct.GpuDevice.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Describes a single graphics processor \\(GPU\\).\n- [`GPUInfo`](struct.GpuInfo.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Provides information about the GPU\\(s\\) on the system.\n"]
pub mod system_info {
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns information about the system.\n\n# Command `SystemInfo.getInfo`\n\n*Domain Module:* [`cdp::proto::system_info`](index.html)  \n*Command Struct:* [`cdp::proto::system_info::GetInfoCommand`](struct.GetInfoCommand.html)  \n*Response Struct:* [`cdp::proto::system_info::GetInfoResponse`](struct.GetInfoResponse.html)"]
    pub struct GetInfoCommand;
    impl ::serde::Serialize for GetInfoCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetInfoCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| GetInfoCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for GetInfoCommand {
        fn command_name(&self) -> &str {
            "SystemInfo.getInfo"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for GetInfoCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "SystemInfo.getInfo" {
                Ok(
                    <GetInfoCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns information about the system.\n\n# Command `SystemInfo.getInfo`\n\n*Domain Module:* [`cdp::proto::system_info`](index.html)  \n*Command Struct:* [`cdp::proto::system_info::GetInfoCommand`](struct.GetInfoCommand.html)  \n*Response Struct:* [`cdp::proto::system_info::GetInfoResponse`](struct.GetInfoResponse.html)"]
    pub struct GetInfoResponse<'a> {
        #[serde(rename = "gpu")]
        #[doc = "Information about the GPUs on the system."]
        pub gpu: ::proto::system_info::GpuInfo<'a>,
        #[serde(rename = "modelName")]
        #[doc = "A platform-dependent description of the model of the machine. On Mac OS, this is, for example, 'MacBookPro'. Will be the empty string if not supported."]
        pub model_name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "modelVersion")]
        #[doc = "A platform-dependent description of the version of the machine. On Mac OS, this is, for example, '10.1'. Will be the empty string if not supported."]
        pub model_version: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "commandLine")]
        #[doc = "The command line string used to launch the browser. Will be the empty string if not supported."]
        pub command_line: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for GetInfoCommand {
        type Response = GetInfoResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for GetInfoResponse<'a> {
        type Command = GetInfoCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Describes a single graphics processor \\(GPU\\)."]
    pub struct GpuDevice<'a> {
        #[serde(rename = "vendorId")]
        #[doc = "PCI ID of the GPU vendor, if available; 0 otherwise."]
        pub vendor_id: f64,
        #[serde(rename = "deviceId")]
        #[doc = "PCI ID of the GPU device, if available; 0 otherwise."]
        pub device_id: f64,
        #[serde(rename = "vendorString")]
        #[doc = "String description of the GPU vendor, if the PCI ID is not available."]
        pub vendor_string: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "deviceString")]
        #[doc = "String description of the GPU device, if the PCI ID is not available."]
        pub device_string: ::std::borrow::Cow<'a, str>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Provides information about the GPU\\(s\\) on the system."]
    pub struct GpuInfo<'a> {
        #[serde(rename = "devices")]
        #[doc = "The graphics devices on the system. Element 0 is the primary GPU."]
        pub devices: Vec<::proto::system_info::GpuDevice<'a>>,
        #[serde(rename = "auxAttributes", skip_serializing_if = "Option::is_none")]
        #[doc = "An optional dictionary of additional GPU related attributes."]
        pub aux_attributes: Option<::proto::Empty>,
        #[serde(rename = "featureStatus", skip_serializing_if = "Option::is_none")]
        #[doc = "An optional dictionary of graphics features and their status."]
        pub feature_status: Option<::proto::Empty>,
        #[serde(rename = "driverBugWorkarounds")]
        #[doc = "An optional array of GPU driver bug workarounds."]
        pub driver_bug_workarounds: Vec<::std::borrow::Cow<'a, str>>,
    }
}
#[doc = "<span class=\"stab unstable\">[Experimental]</span> The Tethering domain defines methods and events for browser port binding.\n\n# Tethering\n\n## Commands\n\n- [`Tethering.bind`](struct.BindCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Request browser port binding.\n- [`Tethering.unbind`](struct.UnbindCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Request browser port unbinding.\n\n## Events\n\n- [`Tethering.accepted`](struct.AcceptedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Informs that port was successfully bound and got a specified connection id.\n"]
pub mod tethering {
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Request browser port binding.\n\n# Command `Tethering.bind`\n\n*Domain Module:* [`cdp::proto::tethering`](index.html)  \n*Command Struct:* [`cdp::proto::tethering::BindCommand`](struct.BindCommand.html)  \n*Response Struct:* [`cdp::proto::tethering::BindResponse`](struct.BindResponse.html)"]
    pub struct BindCommand {
        #[serde(rename = "port")]
        #[doc = "Port number to bind."]
        pub port: i32,
    }
    impl ::traits::SerializeCdpCommand for BindCommand {
        fn command_name(&self) -> &str {
            "Tethering.bind"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for BindCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Tethering.bind" {
                Ok(
                    <BindCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Request browser port binding.\n\n# Command `Tethering.bind`\n\n*Domain Module:* [`cdp::proto::tethering`](index.html)  \n*Command Struct:* [`cdp::proto::tethering::BindCommand`](struct.BindCommand.html)  \n*Response Struct:* [`cdp::proto::tethering::BindResponse`](struct.BindResponse.html)"]
    pub struct BindResponse;
    impl ::serde::Serialize for BindResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for BindResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| BindResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for BindCommand {
        type Response = BindResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for BindResponse {
        type Command = BindCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Request browser port unbinding.\n\n# Command `Tethering.unbind`\n\n*Domain Module:* [`cdp::proto::tethering`](index.html)  \n*Command Struct:* [`cdp::proto::tethering::UnbindCommand`](struct.UnbindCommand.html)  \n*Response Struct:* [`cdp::proto::tethering::UnbindResponse`](struct.UnbindResponse.html)"]
    pub struct UnbindCommand {
        #[serde(rename = "port")]
        #[doc = "Port number to unbind."]
        pub port: i32,
    }
    impl ::traits::SerializeCdpCommand for UnbindCommand {
        fn command_name(&self) -> &str {
            "Tethering.unbind"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for UnbindCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Tethering.unbind" {
                Ok(
                    <UnbindCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Request browser port unbinding.\n\n# Command `Tethering.unbind`\n\n*Domain Module:* [`cdp::proto::tethering`](index.html)  \n*Command Struct:* [`cdp::proto::tethering::UnbindCommand`](struct.UnbindCommand.html)  \n*Response Struct:* [`cdp::proto::tethering::UnbindResponse`](struct.UnbindResponse.html)"]
    pub struct UnbindResponse;
    impl ::serde::Serialize for UnbindResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for UnbindResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| UnbindResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for UnbindCommand {
        type Response = UnbindResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for UnbindResponse {
        type Command = UnbindCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Informs that port was successfully bound and got a specified connection id.\n\n# Event `Tethering.accepted`\n\n*Domain Module:* [`cdp::proto::tethering`](index.html)  \n*Event Struct:* [`cdp::proto::tethering::AcceptedEvent`](struct.AcceptedEvent.html)"]
    pub struct AcceptedEvent<'a> {
        #[serde(rename = "port")]
        #[doc = "Port number that was successfully bound."]
        pub port: i32,
        #[serde(rename = "connectionId")]
        #[doc = "Connection id to be used."]
        pub connection_id: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpEvent for AcceptedEvent<'a> {
        fn event_name(&self) -> &str {
            "Tethering.accepted"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for AcceptedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Tethering.accepted" {
                Ok(
                    <AcceptedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
}
#[doc = "<span class=\"stab unstable\">[Experimental]</span> The Browser domain defines methods and events for browser managing.\n\n# Browser\n\n## Commands\n\n- [`Browser.getWindowForTarget`](struct.GetWindowForTargetCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Get the browser window that contains the devtools target.\n- [`Browser.setWindowBounds`](struct.SetWindowBoundsCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Set position and/or size of the browser window.\n- [`Browser.getWindowBounds`](struct.GetWindowBoundsCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Get position and size of the browser window.\n\n##Types\n\n- [`WindowID`](type.WindowId.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`WindowState`](enum.WindowState.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  The state of the browser window.\n- [`Bounds`](struct.Bounds.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Browser window bounds information\n"]
pub mod browser {
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Get the browser window that contains the devtools target.\n\n# Command `Browser.getWindowForTarget`\n\n*Domain Module:* [`cdp::proto::browser`](index.html)  \n*Command Struct:* [`cdp::proto::browser::GetWindowForTargetCommand`](struct.GetWindowForTargetCommand.html)  \n*Response Struct:* [`cdp::proto::browser::GetWindowForTargetResponse`](struct.GetWindowForTargetResponse.html)"]
    pub struct GetWindowForTargetCommand<'a> {
        #[serde(rename = "targetId")]
        #[doc = "Devtools agent host id."]
        pub target_id: ::proto::target::TargetId<'a>,
    }
    impl<'a> ::traits::SerializeCdpCommand for GetWindowForTargetCommand<'a> {
        fn command_name(&self) -> &str {
            "Browser.getWindowForTarget"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for GetWindowForTargetCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Browser.getWindowForTarget" {
                Ok ( < GetWindowForTargetCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Get the browser window that contains the devtools target.\n\n# Command `Browser.getWindowForTarget`\n\n*Domain Module:* [`cdp::proto::browser`](index.html)  \n*Command Struct:* [`cdp::proto::browser::GetWindowForTargetCommand`](struct.GetWindowForTargetCommand.html)  \n*Response Struct:* [`cdp::proto::browser::GetWindowForTargetResponse`](struct.GetWindowForTargetResponse.html)"]
    pub struct GetWindowForTargetResponse {
        #[serde(rename = "windowId")]
        #[doc = "Browser window id."]
        pub window_id: ::proto::browser::WindowId,
        #[serde(rename = "bounds")]
        #[doc = "Bounds information of the window. When window state is 'minimized', the restored window position and size are returned."]
        pub bounds: ::proto::browser::Bounds,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for GetWindowForTargetCommand<'a> {
        type Response = GetWindowForTargetResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for GetWindowForTargetResponse {
        type Command = GetWindowForTargetCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Set position and/or size of the browser window.\n\n# Command `Browser.setWindowBounds`\n\n*Domain Module:* [`cdp::proto::browser`](index.html)  \n*Command Struct:* [`cdp::proto::browser::SetWindowBoundsCommand`](struct.SetWindowBoundsCommand.html)  \n*Response Struct:* [`cdp::proto::browser::SetWindowBoundsResponse`](struct.SetWindowBoundsResponse.html)"]
    pub struct SetWindowBoundsCommand {
        #[serde(rename = "windowId")]
        #[doc = "Browser window id."]
        pub window_id: ::proto::browser::WindowId,
        #[serde(rename = "bounds")]
        #[doc = "New window bounds. The 'minimized', 'maximized' and 'fullscreen' states cannot be combined with 'left', 'top', 'width' or 'height'. Leaves unspecified fields unchanged."]
        pub bounds: ::proto::browser::Bounds,
    }
    impl ::traits::SerializeCdpCommand for SetWindowBoundsCommand {
        fn command_name(&self) -> &str {
            "Browser.setWindowBounds"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for SetWindowBoundsCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Browser.setWindowBounds" {
                Ok(
                    <SetWindowBoundsCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Set position and/or size of the browser window.\n\n# Command `Browser.setWindowBounds`\n\n*Domain Module:* [`cdp::proto::browser`](index.html)  \n*Command Struct:* [`cdp::proto::browser::SetWindowBoundsCommand`](struct.SetWindowBoundsCommand.html)  \n*Response Struct:* [`cdp::proto::browser::SetWindowBoundsResponse`](struct.SetWindowBoundsResponse.html)"]
    pub struct SetWindowBoundsResponse;
    impl ::serde::Serialize for SetWindowBoundsResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetWindowBoundsResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetWindowBoundsResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetWindowBoundsCommand {
        type Response = SetWindowBoundsResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetWindowBoundsResponse {
        type Command = SetWindowBoundsCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Get position and size of the browser window.\n\n# Command `Browser.getWindowBounds`\n\n*Domain Module:* [`cdp::proto::browser`](index.html)  \n*Command Struct:* [`cdp::proto::browser::GetWindowBoundsCommand`](struct.GetWindowBoundsCommand.html)  \n*Response Struct:* [`cdp::proto::browser::GetWindowBoundsResponse`](struct.GetWindowBoundsResponse.html)"]
    pub struct GetWindowBoundsCommand {
        #[serde(rename = "windowId")]
        #[doc = "Browser window id."]
        pub window_id: ::proto::browser::WindowId,
    }
    impl ::traits::SerializeCdpCommand for GetWindowBoundsCommand {
        fn command_name(&self) -> &str {
            "Browser.getWindowBounds"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for GetWindowBoundsCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Browser.getWindowBounds" {
                Ok(
                    <GetWindowBoundsCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Get position and size of the browser window.\n\n# Command `Browser.getWindowBounds`\n\n*Domain Module:* [`cdp::proto::browser`](index.html)  \n*Command Struct:* [`cdp::proto::browser::GetWindowBoundsCommand`](struct.GetWindowBoundsCommand.html)  \n*Response Struct:* [`cdp::proto::browser::GetWindowBoundsResponse`](struct.GetWindowBoundsResponse.html)"]
    pub struct GetWindowBoundsResponse {
        #[serde(rename = "bounds")]
        #[doc = "Bounds information of the window. When window state is 'minimized', the restored window position and size are returned."]
        pub bounds: ::proto::browser::Bounds,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for GetWindowBoundsCommand {
        type Response = GetWindowBoundsResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for GetWindowBoundsResponse {
        type Command = GetWindowBoundsCommand;
    }
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>"]
    pub type WindowId = i32;
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> The state of the browser window."]
    pub enum WindowState {
        #[serde(rename = "normal")]
        #[doc = "Represented as `\"normal\"`."]
        Normal,
        #[serde(rename = "minimized")]
        #[doc = "Represented as `\"minimized\"`."]
        Minimized,
        #[serde(rename = "maximized")]
        #[doc = "Represented as `\"maximized\"`."]
        Maximized,
        #[serde(rename = "fullscreen")]
        #[doc = "Represented as `\"fullscreen\"`."]
        Fullscreen,
    }
    impl WindowState {
        pub const ENUM_VALUES: &'static [WindowState] = &[
            WindowState::Normal,
            WindowState::Minimized,
            WindowState::Maximized,
            WindowState::Fullscreen,
        ];
        pub const STR_VALUES: &'static [&'static str] =
            &["normal", "minimized", "maximized", "fullscreen"];
    }
    impl ::std::str::FromStr for WindowState {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "normal" => Ok(WindowState::Normal),
                "minimized" => Ok(WindowState::Minimized),
                "maximized" => Ok(WindowState::Maximized),
                "fullscreen" => Ok(WindowState::Fullscreen),
                _ => Err(::proto::ParseEnumError {
                    expected: WindowState::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for WindowState {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    WindowState::Normal => "normal",
                    WindowState::Minimized => "minimized",
                    WindowState::Maximized => "maximized",
                    WindowState::Fullscreen => "fullscreen",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Browser window bounds information"]
    pub struct Bounds {
        #[serde(rename = "left", skip_serializing_if = "Option::is_none")]
        #[doc = "The offset from the left edge of the screen to the window in pixels."]
        pub left: Option<i32>,
        #[serde(rename = "top", skip_serializing_if = "Option::is_none")]
        #[doc = "The offset from the top edge of the screen to the window in pixels."]
        pub top: Option<i32>,
        #[serde(rename = "width", skip_serializing_if = "Option::is_none")]
        #[doc = "The window width in pixels."]
        pub width: Option<i32>,
        #[serde(rename = "height", skip_serializing_if = "Option::is_none")]
        #[doc = "The window height in pixels."]
        pub height: Option<i32>,
        #[serde(rename = "windowState", skip_serializing_if = "Option::is_none")]
        #[doc = "The window state. Default to normal."]
        pub window_state: Option<::proto::browser::WindowState>,
    }
}
#[doc = "Provides information about the protocol schema.\n\n# Schema\n\n## Commands\n\n- [`Schema.getDomains`](struct.GetDomainsCommand.html)\n\n  Returns supported domains.\n\n##Types\n\n- [`Domain`](struct.Domain.html)\n\n  Description of the protocol domain.\n"]
pub mod schema {
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Returns supported domains.\n\n# Command `Schema.getDomains`\n\n*Domain Module:* [`cdp::proto::schema`](index.html)  \n*Command Struct:* [`cdp::proto::schema::GetDomainsCommand`](struct.GetDomainsCommand.html)  \n*Response Struct:* [`cdp::proto::schema::GetDomainsResponse`](struct.GetDomainsResponse.html)"]
    pub struct GetDomainsCommand;
    impl ::serde::Serialize for GetDomainsCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetDomainsCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| GetDomainsCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for GetDomainsCommand {
        fn command_name(&self) -> &str {
            "Schema.getDomains"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for GetDomainsCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Schema.getDomains" {
                Ok(
                    <GetDomainsCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Returns supported domains.\n\n# Command `Schema.getDomains`\n\n*Domain Module:* [`cdp::proto::schema`](index.html)  \n*Command Struct:* [`cdp::proto::schema::GetDomainsCommand`](struct.GetDomainsCommand.html)  \n*Response Struct:* [`cdp::proto::schema::GetDomainsResponse`](struct.GetDomainsResponse.html)"]
    pub struct GetDomainsResponse<'a> {
        #[serde(rename = "domains")]
        #[doc = "List of supported domains."]
        pub domains: Vec<::proto::schema::Domain<'a>>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for GetDomainsCommand {
        type Response = GetDomainsResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for GetDomainsResponse<'a> {
        type Command = GetDomainsCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Description of the protocol domain."]
    pub struct Domain<'a> {
        #[serde(rename = "name")]
        #[doc = "Domain name."]
        pub name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "version")]
        #[doc = "Domain version."]
        pub version: ::std::borrow::Cow<'a, str>,
    }
}
#[doc = "Runtime domain exposes JavaScript runtime by means of remote evaluation and mirror objects. Evaluation results are returned as mirror object that expose object type, string representation and unique identifier that can be used for further object reference. Original objects are maintained in memory unless they are either explicitly released or are released along with the other objects in their object group.\n\n# Runtime\n\n## Commands\n\n- [`Runtime.evaluate`](struct.EvaluateCommand.html)\n\n  Evaluates expression on global object.\n- [`Runtime.awaitPromise`](struct.AwaitPromiseCommand.html)\n\n  Add handler to promise with given promise object id.\n- [`Runtime.callFunctionOn`](struct.CallFunctionOnCommand.html)\n\n  Calls function with given declaration on the given object. Object group of the result is inherited from the target object.\n- [`Runtime.getProperties`](struct.GetPropertiesCommand.html)\n\n  Returns properties of a given object. Object group of the result is inherited from the target object.\n- [`Runtime.releaseObject`](struct.ReleaseObjectCommand.html)\n\n  Releases remote object with given id.\n- [`Runtime.releaseObjectGroup`](struct.ReleaseObjectGroupCommand.html)\n\n  Releases all remote objects that belong to a given group.\n- [`Runtime.runIfWaitingForDebugger`](struct.RunIfWaitingForDebuggerCommand.html)\n\n  Tells inspected instance to run if it was waiting for debugger to attach.\n- [`Runtime.enable`](struct.EnableCommand.html)\n\n  Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.\n- [`Runtime.disable`](struct.DisableCommand.html)\n\n  Disables reporting of execution contexts creation.\n- [`Runtime.discardConsoleEntries`](struct.DiscardConsoleEntriesCommand.html)\n\n  Discards collected exceptions and console API calls.\n- [`Runtime.setCustomObjectFormatterEnabled`](struct.SetCustomObjectFormatterEnabledCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`Runtime.compileScript`](struct.CompileScriptCommand.html)\n\n  Compiles expression.\n- [`Runtime.runScript`](struct.RunScriptCommand.html)\n\n  Runs script with given id in a given context.\n\n## Events\n\n- [`Runtime.executionContextCreated`](struct.ExecutionContextCreatedEvent.html)\n\n  Issued when new execution context is created.\n- [`Runtime.executionContextDestroyed`](struct.ExecutionContextDestroyedEvent.html)\n\n  Issued when execution context is destroyed.\n- [`Runtime.executionContextsCleared`](struct.ExecutionContextsClearedEvent.html)\n\n  Issued when all executionContexts were cleared in browser\n- [`Runtime.exceptionThrown`](struct.ExceptionThrownEvent.html)\n\n  Issued when exception was thrown and unhandled.\n- [`Runtime.exceptionRevoked`](struct.ExceptionRevokedEvent.html)\n\n  Issued when unhandled exception was revoked.\n- [`Runtime.consoleAPICalled`](struct.ConsoleApiCalledEvent.html)\n\n  Issued when console API was called.\n- [`Runtime.inspectRequested`](struct.InspectRequestedEvent.html)\n\n  Issued when object should be inspected \\(for example, as a result of inspect\\(\\) command line API call\\).\n\n##Types\n\n- [`ScriptId`](type.ScriptId.html)\n\n  Unique script identifier.\n- [`RemoteObjectId`](type.RemoteObjectId.html)\n\n  Unique object identifier.\n- [`UnserializableValue`](enum.UnserializableValue.html)\n\n  Primitive value which cannot be JSON-stringified.\n- [`RemoteObject`](struct.RemoteObject.html)\n\n  Mirror object referencing original JavaScript object.\n- [`CustomPreview`](struct.CustomPreview.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`ObjectPreview`](struct.ObjectPreview.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Object containing abbreviated remote object value.\n- [`PropertyPreview`](struct.PropertyPreview.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`EntryPreview`](struct.EntryPreview.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`PropertyDescriptor`](struct.PropertyDescriptor.html)\n\n  Object property descriptor.\n- [`InternalPropertyDescriptor`](struct.InternalPropertyDescriptor.html)\n\n  Object internal property descriptor. This property isn't normally visible in JavaScript code.\n- [`CallArgument`](struct.CallArgument.html)\n\n  Represents function call argument. Either remote object id <code>objectId</code>, primitive <code>value</code>, unserializable primitive value or neither of \\(for undefined\\) them should be specified.\n- [`ExecutionContextId`](type.ExecutionContextId.html)\n\n  Id of an execution context.\n- [`ExecutionContextDescription`](struct.ExecutionContextDescription.html)\n\n  Description of an isolated world.\n- [`ExceptionDetails`](struct.ExceptionDetails.html)\n\n  Detailed information about exception \\(or error\\) that was thrown during script compilation or execution.\n- [`Timestamp`](type.Timestamp.html)\n\n  Number of milliseconds since epoch.\n- [`CallFrame`](struct.CallFrame.html)\n\n  Stack entry for runtime errors and assertions.\n- [`StackTrace`](struct.StackTrace.html)\n\n  Call frames for assertions or error messages.\n"]
pub mod runtime {
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Evaluates expression on global object.\n\n# Command `Runtime.evaluate`\n\n*Domain Module:* [`cdp::proto::runtime`](index.html)  \n*Command Struct:* [`cdp::proto::runtime::EvaluateCommand`](struct.EvaluateCommand.html)  \n*Response Struct:* [`cdp::proto::runtime::EvaluateResponse`](struct.EvaluateResponse.html)"]
    pub struct EvaluateCommand<'a> {
        #[serde(rename = "expression")]
        #[doc = "Expression to evaluate."]
        pub expression: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "objectGroup", skip_serializing_if = "Option::is_none")]
        #[doc = "Symbolic group name that can be used to release multiple objects."]
        pub object_group: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "includeCommandLineAPI", skip_serializing_if = "Option::is_none")]
        #[doc = "Determines whether Command Line API should be available during the evaluation."]
        pub include_command_line_api: Option<bool>,
        #[serde(rename = "silent", skip_serializing_if = "Option::is_none")]
        #[doc = "In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides <code>setPauseOnException</code> state."]
        pub silent: Option<bool>,
        #[serde(rename = "contextId", skip_serializing_if = "Option::is_none")]
        #[doc = "Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page."]
        pub context_id: Option<::proto::runtime::ExecutionContextId>,
        #[serde(rename = "returnByValue", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether the result is expected to be a JSON object that should be sent by value."]
        pub return_by_value: Option<bool>,
        #[serde(rename = "generatePreview", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Whether preview should be generated for the result."]
        pub generate_preview: Option<bool>,
        #[serde(rename = "userGesture", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Whether execution should be treated as initiated by user in the UI."]
        pub user_gesture: Option<bool>,
        #[serde(rename = "awaitPromise", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether execution should wait for promise to be resolved. If the result of evaluation is not a Promise, it's considered to be an error."]
        pub await_promise: Option<bool>,
    }
    impl<'a> ::traits::SerializeCdpCommand for EvaluateCommand<'a> {
        fn command_name(&self) -> &str {
            "Runtime.evaluate"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for EvaluateCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Runtime.evaluate" {
                Ok(
                    <EvaluateCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Evaluates expression on global object.\n\n# Command `Runtime.evaluate`\n\n*Domain Module:* [`cdp::proto::runtime`](index.html)  \n*Command Struct:* [`cdp::proto::runtime::EvaluateCommand`](struct.EvaluateCommand.html)  \n*Response Struct:* [`cdp::proto::runtime::EvaluateResponse`](struct.EvaluateResponse.html)"]
    pub struct EvaluateResponse<'a> {
        #[serde(rename = "result")]
        #[doc = "Evaluation result."]
        pub result: ::proto::runtime::RemoteObject<'a>,
        #[serde(rename = "exceptionDetails", skip_serializing_if = "Option::is_none")]
        #[doc = "Exception details."]
        pub exception_details: Option<::proto::runtime::ExceptionDetails<'a>>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for EvaluateCommand<'a> {
        type Response = EvaluateResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for EvaluateResponse<'a> {
        type Command = EvaluateCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Add handler to promise with given promise object id.\n\n# Command `Runtime.awaitPromise`\n\n*Domain Module:* [`cdp::proto::runtime`](index.html)  \n*Command Struct:* [`cdp::proto::runtime::AwaitPromiseCommand`](struct.AwaitPromiseCommand.html)  \n*Response Struct:* [`cdp::proto::runtime::AwaitPromiseResponse`](struct.AwaitPromiseResponse.html)"]
    pub struct AwaitPromiseCommand<'a> {
        #[serde(rename = "promiseObjectId")]
        #[doc = "Identifier of the promise."]
        pub promise_object_id: ::proto::runtime::RemoteObjectId<'a>,
        #[serde(rename = "returnByValue", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether the result is expected to be a JSON object that should be sent by value."]
        pub return_by_value: Option<bool>,
        #[serde(rename = "generatePreview", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether preview should be generated for the result."]
        pub generate_preview: Option<bool>,
    }
    impl<'a> ::traits::SerializeCdpCommand for AwaitPromiseCommand<'a> {
        fn command_name(&self) -> &str {
            "Runtime.awaitPromise"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for AwaitPromiseCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Runtime.awaitPromise" {
                Ok(
                    <AwaitPromiseCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Add handler to promise with given promise object id.\n\n# Command `Runtime.awaitPromise`\n\n*Domain Module:* [`cdp::proto::runtime`](index.html)  \n*Command Struct:* [`cdp::proto::runtime::AwaitPromiseCommand`](struct.AwaitPromiseCommand.html)  \n*Response Struct:* [`cdp::proto::runtime::AwaitPromiseResponse`](struct.AwaitPromiseResponse.html)"]
    pub struct AwaitPromiseResponse<'a> {
        #[serde(rename = "result")]
        #[doc = "Promise result. Will contain rejected value if promise was rejected."]
        pub result: ::proto::runtime::RemoteObject<'a>,
        #[serde(rename = "exceptionDetails", skip_serializing_if = "Option::is_none")]
        #[doc = "Exception details if stack strace is available."]
        pub exception_details: Option<::proto::runtime::ExceptionDetails<'a>>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for AwaitPromiseCommand<'a> {
        type Response = AwaitPromiseResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for AwaitPromiseResponse<'a> {
        type Command = AwaitPromiseCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Calls function with given declaration on the given object. Object group of the result is inherited from the target object.\n\n# Command `Runtime.callFunctionOn`\n\n*Domain Module:* [`cdp::proto::runtime`](index.html)  \n*Command Struct:* [`cdp::proto::runtime::CallFunctionOnCommand`](struct.CallFunctionOnCommand.html)  \n*Response Struct:* [`cdp::proto::runtime::CallFunctionOnResponse`](struct.CallFunctionOnResponse.html)"]
    pub struct CallFunctionOnCommand<'a> {
        #[serde(rename = "objectId")]
        #[doc = "Identifier of the object to call function on."]
        pub object_id: ::proto::runtime::RemoteObjectId<'a>,
        #[serde(rename = "functionDeclaration")]
        #[doc = "Declaration of the function to call."]
        pub function_declaration: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "arguments", skip_serializing_if = "Option::is_none")]
        #[doc = "Call arguments. All call arguments must belong to the same JavaScript world as the target object."]
        pub arguments: Option<Vec<::proto::runtime::CallArgument<'a>>>,
        #[serde(rename = "silent", skip_serializing_if = "Option::is_none")]
        #[doc = "In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides <code>setPauseOnException</code> state."]
        pub silent: Option<bool>,
        #[serde(rename = "returnByValue", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether the result is expected to be a JSON object which should be sent by value."]
        pub return_by_value: Option<bool>,
        #[serde(rename = "generatePreview", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Whether preview should be generated for the result."]
        pub generate_preview: Option<bool>,
        #[serde(rename = "userGesture", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Whether execution should be treated as initiated by user in the UI."]
        pub user_gesture: Option<bool>,
        #[serde(rename = "awaitPromise", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether execution should wait for promise to be resolved. If the result of evaluation is not a Promise, it's considered to be an error."]
        pub await_promise: Option<bool>,
    }
    impl<'a> ::traits::SerializeCdpCommand for CallFunctionOnCommand<'a> {
        fn command_name(&self) -> &str {
            "Runtime.callFunctionOn"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for CallFunctionOnCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Runtime.callFunctionOn" {
                Ok(
                    <CallFunctionOnCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Calls function with given declaration on the given object. Object group of the result is inherited from the target object.\n\n# Command `Runtime.callFunctionOn`\n\n*Domain Module:* [`cdp::proto::runtime`](index.html)  \n*Command Struct:* [`cdp::proto::runtime::CallFunctionOnCommand`](struct.CallFunctionOnCommand.html)  \n*Response Struct:* [`cdp::proto::runtime::CallFunctionOnResponse`](struct.CallFunctionOnResponse.html)"]
    pub struct CallFunctionOnResponse<'a> {
        #[serde(rename = "result")]
        #[doc = "Call result."]
        pub result: ::proto::runtime::RemoteObject<'a>,
        #[serde(rename = "exceptionDetails", skip_serializing_if = "Option::is_none")]
        #[doc = "Exception details."]
        pub exception_details: Option<::proto::runtime::ExceptionDetails<'a>>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for CallFunctionOnCommand<'a> {
        type Response = CallFunctionOnResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for CallFunctionOnResponse<'a> {
        type Command = CallFunctionOnCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Returns properties of a given object. Object group of the result is inherited from the target object.\n\n# Command `Runtime.getProperties`\n\n*Domain Module:* [`cdp::proto::runtime`](index.html)  \n*Command Struct:* [`cdp::proto::runtime::GetPropertiesCommand`](struct.GetPropertiesCommand.html)  \n*Response Struct:* [`cdp::proto::runtime::GetPropertiesResponse`](struct.GetPropertiesResponse.html)"]
    pub struct GetPropertiesCommand<'a> {
        #[serde(rename = "objectId")]
        #[doc = "Identifier of the object to return properties for."]
        pub object_id: ::proto::runtime::RemoteObjectId<'a>,
        #[serde(rename = "ownProperties", skip_serializing_if = "Option::is_none")]
        #[doc = "If true, returns properties belonging only to the element itself, not to its prototype chain."]
        pub own_properties: Option<bool>,
        #[serde(rename = "accessorPropertiesOnly", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> If true, returns accessor properties \\(with getter/setter\\) only; internal properties are not returned either."]
        pub accessor_properties_only: Option<bool>,
        #[serde(rename = "generatePreview", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Whether preview should be generated for the results."]
        pub generate_preview: Option<bool>,
    }
    impl<'a> ::traits::SerializeCdpCommand for GetPropertiesCommand<'a> {
        fn command_name(&self) -> &str {
            "Runtime.getProperties"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for GetPropertiesCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Runtime.getProperties" {
                Ok(
                    <GetPropertiesCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Returns properties of a given object. Object group of the result is inherited from the target object.\n\n# Command `Runtime.getProperties`\n\n*Domain Module:* [`cdp::proto::runtime`](index.html)  \n*Command Struct:* [`cdp::proto::runtime::GetPropertiesCommand`](struct.GetPropertiesCommand.html)  \n*Response Struct:* [`cdp::proto::runtime::GetPropertiesResponse`](struct.GetPropertiesResponse.html)"]
    pub struct GetPropertiesResponse<'a> {
        #[serde(rename = "result")]
        #[doc = "Object properties."]
        pub result: Vec<::proto::runtime::PropertyDescriptor<'a>>,
        #[serde(rename = "internalProperties", skip_serializing_if = "Option::is_none")]
        #[doc = "Internal object properties \\(only of the element itself\\)."]
        pub internal_properties:
            Option<Vec<::proto::runtime::InternalPropertyDescriptor<'a>>>,
        #[serde(rename = "exceptionDetails", skip_serializing_if = "Option::is_none")]
        #[doc = "Exception details."]
        pub exception_details: Option<::proto::runtime::ExceptionDetails<'a>>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for GetPropertiesCommand<'a> {
        type Response = GetPropertiesResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for GetPropertiesResponse<'a> {
        type Command = GetPropertiesCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Releases remote object with given id.\n\n# Command `Runtime.releaseObject`\n\n*Domain Module:* [`cdp::proto::runtime`](index.html)  \n*Command Struct:* [`cdp::proto::runtime::ReleaseObjectCommand`](struct.ReleaseObjectCommand.html)  \n*Response Struct:* [`cdp::proto::runtime::ReleaseObjectResponse`](struct.ReleaseObjectResponse.html)"]
    pub struct ReleaseObjectCommand<'a> {
        #[serde(rename = "objectId")]
        #[doc = "Identifier of the object to release."]
        pub object_id: ::proto::runtime::RemoteObjectId<'a>,
    }
    impl<'a> ::traits::SerializeCdpCommand for ReleaseObjectCommand<'a> {
        fn command_name(&self) -> &str {
            "Runtime.releaseObject"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for ReleaseObjectCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Runtime.releaseObject" {
                Ok(
                    <ReleaseObjectCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Releases remote object with given id.\n\n# Command `Runtime.releaseObject`\n\n*Domain Module:* [`cdp::proto::runtime`](index.html)  \n*Command Struct:* [`cdp::proto::runtime::ReleaseObjectCommand`](struct.ReleaseObjectCommand.html)  \n*Response Struct:* [`cdp::proto::runtime::ReleaseObjectResponse`](struct.ReleaseObjectResponse.html)"]
    pub struct ReleaseObjectResponse;
    impl ::serde::Serialize for ReleaseObjectResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ReleaseObjectResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ReleaseObjectResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for ReleaseObjectCommand<'a> {
        type Response = ReleaseObjectResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for ReleaseObjectResponse {
        type Command = ReleaseObjectCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Releases all remote objects that belong to a given group.\n\n# Command `Runtime.releaseObjectGroup`\n\n*Domain Module:* [`cdp::proto::runtime`](index.html)  \n*Command Struct:* [`cdp::proto::runtime::ReleaseObjectGroupCommand`](struct.ReleaseObjectGroupCommand.html)  \n*Response Struct:* [`cdp::proto::runtime::ReleaseObjectGroupResponse`](struct.ReleaseObjectGroupResponse.html)"]
    pub struct ReleaseObjectGroupCommand<'a> {
        #[serde(rename = "objectGroup")]
        #[doc = "Symbolic object group name."]
        pub object_group: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpCommand for ReleaseObjectGroupCommand<'a> {
        fn command_name(&self) -> &str {
            "Runtime.releaseObjectGroup"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for ReleaseObjectGroupCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Runtime.releaseObjectGroup" {
                Ok ( < ReleaseObjectGroupCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Releases all remote objects that belong to a given group.\n\n# Command `Runtime.releaseObjectGroup`\n\n*Domain Module:* [`cdp::proto::runtime`](index.html)  \n*Command Struct:* [`cdp::proto::runtime::ReleaseObjectGroupCommand`](struct.ReleaseObjectGroupCommand.html)  \n*Response Struct:* [`cdp::proto::runtime::ReleaseObjectGroupResponse`](struct.ReleaseObjectGroupResponse.html)"]
    pub struct ReleaseObjectGroupResponse;
    impl ::serde::Serialize for ReleaseObjectGroupResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ReleaseObjectGroupResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ReleaseObjectGroupResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for ReleaseObjectGroupCommand<'a> {
        type Response = ReleaseObjectGroupResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for ReleaseObjectGroupResponse {
        type Command = ReleaseObjectGroupCommand<'a>;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Tells inspected instance to run if it was waiting for debugger to attach.\n\n# Command `Runtime.runIfWaitingForDebugger`\n\n*Domain Module:* [`cdp::proto::runtime`](index.html)  \n*Command Struct:* [`cdp::proto::runtime::RunIfWaitingForDebuggerCommand`](struct.RunIfWaitingForDebuggerCommand.html)  \n*Response Struct:* [`cdp::proto::runtime::RunIfWaitingForDebuggerResponse`](struct.RunIfWaitingForDebuggerResponse.html)"]
    pub struct RunIfWaitingForDebuggerCommand;
    impl ::serde::Serialize for RunIfWaitingForDebuggerCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for RunIfWaitingForDebuggerCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| RunIfWaitingForDebuggerCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for RunIfWaitingForDebuggerCommand {
        fn command_name(&self) -> &str {
            "Runtime.runIfWaitingForDebugger"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for RunIfWaitingForDebuggerCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Runtime.runIfWaitingForDebugger" {
                Ok ( < RunIfWaitingForDebuggerCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Tells inspected instance to run if it was waiting for debugger to attach.\n\n# Command `Runtime.runIfWaitingForDebugger`\n\n*Domain Module:* [`cdp::proto::runtime`](index.html)  \n*Command Struct:* [`cdp::proto::runtime::RunIfWaitingForDebuggerCommand`](struct.RunIfWaitingForDebuggerCommand.html)  \n*Response Struct:* [`cdp::proto::runtime::RunIfWaitingForDebuggerResponse`](struct.RunIfWaitingForDebuggerResponse.html)"]
    pub struct RunIfWaitingForDebuggerResponse;
    impl ::serde::Serialize for RunIfWaitingForDebuggerResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for RunIfWaitingForDebuggerResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| RunIfWaitingForDebuggerResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for RunIfWaitingForDebuggerCommand {
        type Response = RunIfWaitingForDebuggerResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for RunIfWaitingForDebuggerResponse {
        type Command = RunIfWaitingForDebuggerCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.\n\n# Command `Runtime.enable`\n\n*Domain Module:* [`cdp::proto::runtime`](index.html)  \n*Command Struct:* [`cdp::proto::runtime::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::proto::runtime::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableCommand;
    impl ::serde::Serialize for EnableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for EnableCommand {
        fn command_name(&self) -> &str {
            "Runtime.enable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for EnableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Runtime.enable" {
                Ok(
                    <EnableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.\n\n# Command `Runtime.enable`\n\n*Domain Module:* [`cdp::proto::runtime`](index.html)  \n*Command Struct:* [`cdp::proto::runtime::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::proto::runtime::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableResponse;
    impl ::serde::Serialize for EnableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for EnableCommand {
        type Response = EnableResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for EnableResponse {
        type Command = EnableCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Disables reporting of execution contexts creation.\n\n# Command `Runtime.disable`\n\n*Domain Module:* [`cdp::proto::runtime`](index.html)  \n*Command Struct:* [`cdp::proto::runtime::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::proto::runtime::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableCommand;
    impl ::serde::Serialize for DisableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for DisableCommand {
        fn command_name(&self) -> &str {
            "Runtime.disable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for DisableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Runtime.disable" {
                Ok(
                    <DisableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Disables reporting of execution contexts creation.\n\n# Command `Runtime.disable`\n\n*Domain Module:* [`cdp::proto::runtime`](index.html)  \n*Command Struct:* [`cdp::proto::runtime::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::proto::runtime::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableResponse;
    impl ::serde::Serialize for DisableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for DisableCommand {
        type Response = DisableResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for DisableResponse {
        type Command = DisableCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Discards collected exceptions and console API calls.\n\n# Command `Runtime.discardConsoleEntries`\n\n*Domain Module:* [`cdp::proto::runtime`](index.html)  \n*Command Struct:* [`cdp::proto::runtime::DiscardConsoleEntriesCommand`](struct.DiscardConsoleEntriesCommand.html)  \n*Response Struct:* [`cdp::proto::runtime::DiscardConsoleEntriesResponse`](struct.DiscardConsoleEntriesResponse.html)"]
    pub struct DiscardConsoleEntriesCommand;
    impl ::serde::Serialize for DiscardConsoleEntriesCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DiscardConsoleEntriesCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DiscardConsoleEntriesCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for DiscardConsoleEntriesCommand {
        fn command_name(&self) -> &str {
            "Runtime.discardConsoleEntries"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for DiscardConsoleEntriesCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Runtime.discardConsoleEntries" {
                Ok ( < DiscardConsoleEntriesCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Discards collected exceptions and console API calls.\n\n# Command `Runtime.discardConsoleEntries`\n\n*Domain Module:* [`cdp::proto::runtime`](index.html)  \n*Command Struct:* [`cdp::proto::runtime::DiscardConsoleEntriesCommand`](struct.DiscardConsoleEntriesCommand.html)  \n*Response Struct:* [`cdp::proto::runtime::DiscardConsoleEntriesResponse`](struct.DiscardConsoleEntriesResponse.html)"]
    pub struct DiscardConsoleEntriesResponse;
    impl ::serde::Serialize for DiscardConsoleEntriesResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DiscardConsoleEntriesResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DiscardConsoleEntriesResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for DiscardConsoleEntriesCommand {
        type Response = DiscardConsoleEntriesResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for DiscardConsoleEntriesResponse {
        type Command = DiscardConsoleEntriesCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `Runtime.setCustomObjectFormatterEnabled`\n\n*Domain Module:* [`cdp::proto::runtime`](index.html)  \n*Command Struct:* [`cdp::proto::runtime::SetCustomObjectFormatterEnabledCommand`](struct.SetCustomObjectFormatterEnabledCommand.html)  \n*Response Struct:* [`cdp::proto::runtime::SetCustomObjectFormatterEnabledResponse`](struct.SetCustomObjectFormatterEnabledResponse.html)"]
    pub struct SetCustomObjectFormatterEnabledCommand {
        #[serde(rename = "enabled")]
        pub enabled: bool,
    }
    impl ::traits::SerializeCdpCommand for SetCustomObjectFormatterEnabledCommand {
        fn command_name(&self) -> &str {
            "Runtime.setCustomObjectFormatterEnabled"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for SetCustomObjectFormatterEnabledCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Runtime.setCustomObjectFormatterEnabled" {
                Ok ( < SetCustomObjectFormatterEnabledCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `Runtime.setCustomObjectFormatterEnabled`\n\n*Domain Module:* [`cdp::proto::runtime`](index.html)  \n*Command Struct:* [`cdp::proto::runtime::SetCustomObjectFormatterEnabledCommand`](struct.SetCustomObjectFormatterEnabledCommand.html)  \n*Response Struct:* [`cdp::proto::runtime::SetCustomObjectFormatterEnabledResponse`](struct.SetCustomObjectFormatterEnabledResponse.html)"]
    pub struct SetCustomObjectFormatterEnabledResponse;
    impl ::serde::Serialize for SetCustomObjectFormatterEnabledResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetCustomObjectFormatterEnabledResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetCustomObjectFormatterEnabledResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetCustomObjectFormatterEnabledCommand {
        type Response = SetCustomObjectFormatterEnabledResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetCustomObjectFormatterEnabledResponse {
        type Command = SetCustomObjectFormatterEnabledCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Compiles expression.\n\n# Command `Runtime.compileScript`\n\n*Domain Module:* [`cdp::proto::runtime`](index.html)  \n*Command Struct:* [`cdp::proto::runtime::CompileScriptCommand`](struct.CompileScriptCommand.html)  \n*Response Struct:* [`cdp::proto::runtime::CompileScriptResponse`](struct.CompileScriptResponse.html)"]
    pub struct CompileScriptCommand<'a> {
        #[serde(rename = "expression")]
        #[doc = "Expression to compile."]
        pub expression: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "sourceURL")]
        #[doc = "Source url to be set for the script."]
        pub source_url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "persistScript")]
        #[doc = "Specifies whether the compiled script should be persisted."]
        pub persist_script: bool,
        #[serde(rename = "executionContextId", skip_serializing_if = "Option::is_none")]
        #[doc = "Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page."]
        pub execution_context_id: Option<::proto::runtime::ExecutionContextId>,
    }
    impl<'a> ::traits::SerializeCdpCommand for CompileScriptCommand<'a> {
        fn command_name(&self) -> &str {
            "Runtime.compileScript"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for CompileScriptCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Runtime.compileScript" {
                Ok(
                    <CompileScriptCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Compiles expression.\n\n# Command `Runtime.compileScript`\n\n*Domain Module:* [`cdp::proto::runtime`](index.html)  \n*Command Struct:* [`cdp::proto::runtime::CompileScriptCommand`](struct.CompileScriptCommand.html)  \n*Response Struct:* [`cdp::proto::runtime::CompileScriptResponse`](struct.CompileScriptResponse.html)"]
    pub struct CompileScriptResponse<'a> {
        #[serde(rename = "scriptId", skip_serializing_if = "Option::is_none")]
        #[doc = "Id of the script."]
        pub script_id: Option<::proto::runtime::ScriptId<'a>>,
        #[serde(rename = "exceptionDetails", skip_serializing_if = "Option::is_none")]
        #[doc = "Exception details."]
        pub exception_details: Option<::proto::runtime::ExceptionDetails<'a>>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for CompileScriptCommand<'a> {
        type Response = CompileScriptResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for CompileScriptResponse<'a> {
        type Command = CompileScriptCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Runs script with given id in a given context.\n\n# Command `Runtime.runScript`\n\n*Domain Module:* [`cdp::proto::runtime`](index.html)  \n*Command Struct:* [`cdp::proto::runtime::RunScriptCommand`](struct.RunScriptCommand.html)  \n*Response Struct:* [`cdp::proto::runtime::RunScriptResponse`](struct.RunScriptResponse.html)"]
    pub struct RunScriptCommand<'a> {
        #[serde(rename = "scriptId")]
        #[doc = "Id of the script to run."]
        pub script_id: ::proto::runtime::ScriptId<'a>,
        #[serde(rename = "executionContextId", skip_serializing_if = "Option::is_none")]
        #[doc = "Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page."]
        pub execution_context_id: Option<::proto::runtime::ExecutionContextId>,
        #[serde(rename = "objectGroup", skip_serializing_if = "Option::is_none")]
        #[doc = "Symbolic group name that can be used to release multiple objects."]
        pub object_group: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "silent", skip_serializing_if = "Option::is_none")]
        #[doc = "In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides <code>setPauseOnException</code> state."]
        pub silent: Option<bool>,
        #[serde(rename = "includeCommandLineAPI", skip_serializing_if = "Option::is_none")]
        #[doc = "Determines whether Command Line API should be available during the evaluation."]
        pub include_command_line_api: Option<bool>,
        #[serde(rename = "returnByValue", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether the result is expected to be a JSON object which should be sent by value."]
        pub return_by_value: Option<bool>,
        #[serde(rename = "generatePreview", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether preview should be generated for the result."]
        pub generate_preview: Option<bool>,
        #[serde(rename = "awaitPromise", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether execution should wait for promise to be resolved. If the result of evaluation is not a Promise, it's considered to be an error."]
        pub await_promise: Option<bool>,
    }
    impl<'a> ::traits::SerializeCdpCommand for RunScriptCommand<'a> {
        fn command_name(&self) -> &str {
            "Runtime.runScript"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for RunScriptCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Runtime.runScript" {
                Ok(
                    <RunScriptCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Runs script with given id in a given context.\n\n# Command `Runtime.runScript`\n\n*Domain Module:* [`cdp::proto::runtime`](index.html)  \n*Command Struct:* [`cdp::proto::runtime::RunScriptCommand`](struct.RunScriptCommand.html)  \n*Response Struct:* [`cdp::proto::runtime::RunScriptResponse`](struct.RunScriptResponse.html)"]
    pub struct RunScriptResponse<'a> {
        #[serde(rename = "result")]
        #[doc = "Run result."]
        pub result: ::proto::runtime::RemoteObject<'a>,
        #[serde(rename = "exceptionDetails", skip_serializing_if = "Option::is_none")]
        #[doc = "Exception details."]
        pub exception_details: Option<::proto::runtime::ExceptionDetails<'a>>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for RunScriptCommand<'a> {
        type Response = RunScriptResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for RunScriptResponse<'a> {
        type Command = RunScriptCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Issued when new execution context is created.\n\n# Event `Runtime.executionContextCreated`\n\n*Domain Module:* [`cdp::proto::runtime`](index.html)  \n*Event Struct:* [`cdp::proto::runtime::ExecutionContextCreatedEvent`](struct.ExecutionContextCreatedEvent.html)"]
    pub struct ExecutionContextCreatedEvent<'a> {
        #[serde(rename = "context")]
        #[doc = "A newly created execution context."]
        pub context: ::proto::runtime::ExecutionContextDescription<'a>,
    }
    impl<'a> ::traits::SerializeCdpEvent for ExecutionContextCreatedEvent<'a> {
        fn event_name(&self) -> &str {
            "Runtime.executionContextCreated"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for ExecutionContextCreatedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Runtime.executionContextCreated" {
                Ok ( < ExecutionContextCreatedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Issued when execution context is destroyed.\n\n# Event `Runtime.executionContextDestroyed`\n\n*Domain Module:* [`cdp::proto::runtime`](index.html)  \n*Event Struct:* [`cdp::proto::runtime::ExecutionContextDestroyedEvent`](struct.ExecutionContextDestroyedEvent.html)"]
    pub struct ExecutionContextDestroyedEvent {
        #[serde(rename = "executionContextId")]
        #[doc = "Id of the destroyed context"]
        pub execution_context_id: ::proto::runtime::ExecutionContextId,
    }
    impl ::traits::SerializeCdpEvent for ExecutionContextDestroyedEvent {
        fn event_name(&self) -> &str {
            "Runtime.executionContextDestroyed"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpEvent<'de> for ExecutionContextDestroyedEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Runtime.executionContextDestroyed" {
                Ok ( < ExecutionContextDestroyedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Issued when all executionContexts were cleared in browser\n\n# Event `Runtime.executionContextsCleared`\n\n*Domain Module:* [`cdp::proto::runtime`](index.html)  \n*Event Struct:* [`cdp::proto::runtime::ExecutionContextsClearedEvent`](struct.ExecutionContextsClearedEvent.html)"]
    pub struct ExecutionContextsClearedEvent;
    impl ::serde::Serialize for ExecutionContextsClearedEvent {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ExecutionContextsClearedEvent {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ExecutionContextsClearedEvent)
        }
    }
    impl ::traits::SerializeCdpEvent for ExecutionContextsClearedEvent {
        fn event_name(&self) -> &str {
            "Runtime.executionContextsCleared"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpEvent<'de> for ExecutionContextsClearedEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Runtime.executionContextsCleared" {
                Ok ( < ExecutionContextsClearedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Issued when exception was thrown and unhandled.\n\n# Event `Runtime.exceptionThrown`\n\n*Domain Module:* [`cdp::proto::runtime`](index.html)  \n*Event Struct:* [`cdp::proto::runtime::ExceptionThrownEvent`](struct.ExceptionThrownEvent.html)"]
    pub struct ExceptionThrownEvent<'a> {
        #[serde(rename = "timestamp")]
        #[doc = "Timestamp of the exception."]
        pub timestamp: ::proto::runtime::Timestamp,
        #[serde(rename = "exceptionDetails")]
        pub exception_details: ::proto::runtime::ExceptionDetails<'a>,
    }
    impl<'a> ::traits::SerializeCdpEvent for ExceptionThrownEvent<'a> {
        fn event_name(&self) -> &str {
            "Runtime.exceptionThrown"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for ExceptionThrownEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Runtime.exceptionThrown" {
                Ok(
                    <ExceptionThrownEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Issued when unhandled exception was revoked.\n\n# Event `Runtime.exceptionRevoked`\n\n*Domain Module:* [`cdp::proto::runtime`](index.html)  \n*Event Struct:* [`cdp::proto::runtime::ExceptionRevokedEvent`](struct.ExceptionRevokedEvent.html)"]
    pub struct ExceptionRevokedEvent<'a> {
        #[serde(rename = "reason")]
        #[doc = "Reason describing why exception was revoked."]
        pub reason: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "exceptionId")]
        #[doc = "The id of revoked exception, as reported in <code>exceptionUnhandled</code>."]
        pub exception_id: i32,
    }
    impl<'a> ::traits::SerializeCdpEvent for ExceptionRevokedEvent<'a> {
        fn event_name(&self) -> &str {
            "Runtime.exceptionRevoked"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for ExceptionRevokedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Runtime.exceptionRevoked" {
                Ok(
                    <ExceptionRevokedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "Used in the type of [`cdp::proto::runtime::ConsoleApiCalledEvent::ty`](struct.ConsoleApiCalledEvent.html#structfield.ty)."]
    pub enum ConsoleApiCalledEventType {
        #[serde(rename = "log")]
        #[doc = "Represented as `\"log\"`."]
        Log,
        #[serde(rename = "debug")]
        #[doc = "Represented as `\"debug\"`."]
        Debug,
        #[serde(rename = "info")]
        #[doc = "Represented as `\"info\"`."]
        Info,
        #[serde(rename = "error")]
        #[doc = "Represented as `\"error\"`."]
        Error,
        #[serde(rename = "warning")]
        #[doc = "Represented as `\"warning\"`."]
        Warning,
        #[serde(rename = "dir")]
        #[doc = "Represented as `\"dir\"`."]
        Dir,
        #[serde(rename = "dirxml")]
        #[doc = "Represented as `\"dirxml\"`."]
        Dirxml,
        #[serde(rename = "table")]
        #[doc = "Represented as `\"table\"`."]
        Table,
        #[serde(rename = "trace")]
        #[doc = "Represented as `\"trace\"`."]
        Trace,
        #[serde(rename = "clear")]
        #[doc = "Represented as `\"clear\"`."]
        Clear,
        #[serde(rename = "startGroup")]
        #[doc = "Represented as `\"startGroup\"`."]
        StartGroup,
        #[serde(rename = "startGroupCollapsed")]
        #[doc = "Represented as `\"startGroupCollapsed\"`."]
        StartGroupCollapsed,
        #[serde(rename = "endGroup")]
        #[doc = "Represented as `\"endGroup\"`."]
        EndGroup,
        #[serde(rename = "assert")]
        #[doc = "Represented as `\"assert\"`."]
        Assert,
        #[serde(rename = "profile")]
        #[doc = "Represented as `\"profile\"`."]
        Profile,
        #[serde(rename = "profileEnd")]
        #[doc = "Represented as `\"profileEnd\"`."]
        ProfileEnd,
        #[serde(rename = "count")]
        #[doc = "Represented as `\"count\"`."]
        Count,
        #[serde(rename = "timeEnd")]
        #[doc = "Represented as `\"timeEnd\"`."]
        TimeEnd,
    }
    impl ConsoleApiCalledEventType {
        pub const ENUM_VALUES: &'static [ConsoleApiCalledEventType] =
            &[
                ConsoleApiCalledEventType::Log,
                ConsoleApiCalledEventType::Debug,
                ConsoleApiCalledEventType::Info,
                ConsoleApiCalledEventType::Error,
                ConsoleApiCalledEventType::Warning,
                ConsoleApiCalledEventType::Dir,
                ConsoleApiCalledEventType::Dirxml,
                ConsoleApiCalledEventType::Table,
                ConsoleApiCalledEventType::Trace,
                ConsoleApiCalledEventType::Clear,
                ConsoleApiCalledEventType::StartGroup,
                ConsoleApiCalledEventType::StartGroupCollapsed,
                ConsoleApiCalledEventType::EndGroup,
                ConsoleApiCalledEventType::Assert,
                ConsoleApiCalledEventType::Profile,
                ConsoleApiCalledEventType::ProfileEnd,
                ConsoleApiCalledEventType::Count,
                ConsoleApiCalledEventType::TimeEnd,
            ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "log",
            "debug",
            "info",
            "error",
            "warning",
            "dir",
            "dirxml",
            "table",
            "trace",
            "clear",
            "startGroup",
            "startGroupCollapsed",
            "endGroup",
            "assert",
            "profile",
            "profileEnd",
            "count",
            "timeEnd",
        ];
    }
    impl ::std::str::FromStr for ConsoleApiCalledEventType {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "log" => Ok(ConsoleApiCalledEventType::Log),
                "debug" => Ok(ConsoleApiCalledEventType::Debug),
                "info" => Ok(ConsoleApiCalledEventType::Info),
                "error" => Ok(ConsoleApiCalledEventType::Error),
                "warning" => Ok(ConsoleApiCalledEventType::Warning),
                "dir" => Ok(ConsoleApiCalledEventType::Dir),
                "dirxml" => Ok(ConsoleApiCalledEventType::Dirxml),
                "table" => Ok(ConsoleApiCalledEventType::Table),
                "trace" => Ok(ConsoleApiCalledEventType::Trace),
                "clear" => Ok(ConsoleApiCalledEventType::Clear),
                "startGroup" => Ok(ConsoleApiCalledEventType::StartGroup),
                "startGroupCollapsed" => Ok(ConsoleApiCalledEventType::StartGroupCollapsed),
                "endGroup" => Ok(ConsoleApiCalledEventType::EndGroup),
                "assert" => Ok(ConsoleApiCalledEventType::Assert),
                "profile" => Ok(ConsoleApiCalledEventType::Profile),
                "profileEnd" => Ok(ConsoleApiCalledEventType::ProfileEnd),
                "count" => Ok(ConsoleApiCalledEventType::Count),
                "timeEnd" => Ok(ConsoleApiCalledEventType::TimeEnd),
                _ => Err(::proto::ParseEnumError {
                    expected: ConsoleApiCalledEventType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for ConsoleApiCalledEventType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    ConsoleApiCalledEventType::Log => "log",
                    ConsoleApiCalledEventType::Debug => "debug",
                    ConsoleApiCalledEventType::Info => "info",
                    ConsoleApiCalledEventType::Error => "error",
                    ConsoleApiCalledEventType::Warning => "warning",
                    ConsoleApiCalledEventType::Dir => "dir",
                    ConsoleApiCalledEventType::Dirxml => "dirxml",
                    ConsoleApiCalledEventType::Table => "table",
                    ConsoleApiCalledEventType::Trace => "trace",
                    ConsoleApiCalledEventType::Clear => "clear",
                    ConsoleApiCalledEventType::StartGroup => "startGroup",
                    ConsoleApiCalledEventType::StartGroupCollapsed => "startGroupCollapsed",
                    ConsoleApiCalledEventType::EndGroup => "endGroup",
                    ConsoleApiCalledEventType::Assert => "assert",
                    ConsoleApiCalledEventType::Profile => "profile",
                    ConsoleApiCalledEventType::ProfileEnd => "profileEnd",
                    ConsoleApiCalledEventType::Count => "count",
                    ConsoleApiCalledEventType::TimeEnd => "timeEnd",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Issued when console API was called.\n\n# Event `Runtime.consoleAPICalled`\n\n*Domain Module:* [`cdp::proto::runtime`](index.html)  \n*Event Struct:* [`cdp::proto::runtime::ConsoleApiCalledEvent`](struct.ConsoleApiCalledEvent.html)"]
    pub struct ConsoleApiCalledEvent<'a> {
        #[serde(rename = "type")]
        #[doc = "Type of the call."]
        pub ty: ::proto::runtime::ConsoleApiCalledEventType,
        #[serde(rename = "args")]
        #[doc = "Call arguments."]
        pub args: Vec<::proto::runtime::RemoteObject<'a>>,
        #[serde(rename = "executionContextId")]
        #[doc = "Identifier of the context where the call was made."]
        pub execution_context_id: ::proto::runtime::ExecutionContextId,
        #[serde(rename = "timestamp")]
        #[doc = "Call timestamp."]
        pub timestamp: ::proto::runtime::Timestamp,
        #[serde(rename = "stackTrace", skip_serializing_if = "Option::is_none")]
        #[doc = "Stack trace captured when the call was made."]
        pub stack_trace: Option<::proto::runtime::StackTrace<'a>>,
        #[serde(rename = "context", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Console context descriptor for calls on non-default console context \\(not console.\\*\\): 'anonymous#unique-logger-id' for call on unnamed context, 'name#unique-logger-id' for call on named context."]
        pub context: Option<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::traits::SerializeCdpEvent for ConsoleApiCalledEvent<'a> {
        fn event_name(&self) -> &str {
            "Runtime.consoleAPICalled"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for ConsoleApiCalledEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Runtime.consoleAPICalled" {
                Ok(
                    <ConsoleApiCalledEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Issued when object should be inspected \\(for example, as a result of inspect\\(\\) command line API call\\).\n\n# Event `Runtime.inspectRequested`\n\n*Domain Module:* [`cdp::proto::runtime`](index.html)  \n*Event Struct:* [`cdp::proto::runtime::InspectRequestedEvent`](struct.InspectRequestedEvent.html)"]
    pub struct InspectRequestedEvent<'a> {
        #[serde(rename = "object")]
        pub object: ::proto::runtime::RemoteObject<'a>,
        #[serde(rename = "hints")]
        pub hints: ::proto::Empty,
    }
    impl<'a> ::traits::SerializeCdpEvent for InspectRequestedEvent<'a> {
        fn event_name(&self) -> &str {
            "Runtime.inspectRequested"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for InspectRequestedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Runtime.inspectRequested" {
                Ok(
                    <InspectRequestedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[doc = "Unique script identifier."]
    pub type ScriptId<'a> = ::std::borrow::Cow<'a, str>;
    #[doc = "Unique object identifier."]
    pub type RemoteObjectId<'a> = ::std::borrow::Cow<'a, str>;
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "Primitive value which cannot be JSON-stringified."]
    pub enum UnserializableValue {
        #[serde(rename = "Infinity")]
        #[doc = "Represented as `\"Infinity\"`."]
        Infinity,
        #[serde(rename = "NaN")]
        #[doc = "Represented as `\"NaN\"`."]
        NaN,
        #[serde(rename = "-Infinity")]
        #[doc = "Represented as `\"-Infinity\"`."]
        NegativeInfinity,
        #[serde(rename = "-0")]
        #[doc = "Represented as `\"-0\"`."]
        Negative0,
    }
    impl UnserializableValue {
        pub const ENUM_VALUES: &'static [UnserializableValue] =
            &[
                UnserializableValue::Infinity,
                UnserializableValue::NaN,
                UnserializableValue::NegativeInfinity,
                UnserializableValue::Negative0,
            ];
        pub const STR_VALUES: &'static [&'static str] = &["Infinity", "NaN", "-Infinity", "-0"];
    }
    impl ::std::str::FromStr for UnserializableValue {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "Infinity" => Ok(UnserializableValue::Infinity),
                "NaN" => Ok(UnserializableValue::NaN),
                "-Infinity" => Ok(UnserializableValue::NegativeInfinity),
                "-0" => Ok(UnserializableValue::Negative0),
                _ => Err(::proto::ParseEnumError {
                    expected: UnserializableValue::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for UnserializableValue {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    UnserializableValue::Infinity => "Infinity",
                    UnserializableValue::NaN => "NaN",
                    UnserializableValue::NegativeInfinity => "-Infinity",
                    UnserializableValue::Negative0 => "-0",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "Used in the type of [`cdp::proto::runtime::RemoteObject::ty`](struct.RemoteObject.html#structfield.ty)."]
    pub enum RemoteObjectType {
        #[serde(rename = "object")]
        #[doc = "Represented as `\"object\"`."]
        Object,
        #[serde(rename = "function")]
        #[doc = "Represented as `\"function\"`."]
        Function,
        #[serde(rename = "undefined")]
        #[doc = "Represented as `\"undefined\"`."]
        Undefined,
        #[serde(rename = "string")]
        #[doc = "Represented as `\"string\"`."]
        String,
        #[serde(rename = "number")]
        #[doc = "Represented as `\"number\"`."]
        Number,
        #[serde(rename = "boolean")]
        #[doc = "Represented as `\"boolean\"`."]
        Boolean,
        #[serde(rename = "symbol")]
        #[doc = "Represented as `\"symbol\"`."]
        Symbol,
    }
    impl RemoteObjectType {
        pub const ENUM_VALUES: &'static [RemoteObjectType] = &[
            RemoteObjectType::Object,
            RemoteObjectType::Function,
            RemoteObjectType::Undefined,
            RemoteObjectType::String,
            RemoteObjectType::Number,
            RemoteObjectType::Boolean,
            RemoteObjectType::Symbol,
        ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "object",
            "function",
            "undefined",
            "string",
            "number",
            "boolean",
            "symbol",
        ];
    }
    impl ::std::str::FromStr for RemoteObjectType {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "object" => Ok(RemoteObjectType::Object),
                "function" => Ok(RemoteObjectType::Function),
                "undefined" => Ok(RemoteObjectType::Undefined),
                "string" => Ok(RemoteObjectType::String),
                "number" => Ok(RemoteObjectType::Number),
                "boolean" => Ok(RemoteObjectType::Boolean),
                "symbol" => Ok(RemoteObjectType::Symbol),
                _ => Err(::proto::ParseEnumError {
                    expected: RemoteObjectType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for RemoteObjectType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    RemoteObjectType::Object => "object",
                    RemoteObjectType::Function => "function",
                    RemoteObjectType::Undefined => "undefined",
                    RemoteObjectType::String => "string",
                    RemoteObjectType::Number => "number",
                    RemoteObjectType::Boolean => "boolean",
                    RemoteObjectType::Symbol => "symbol",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "Used in the type of [`cdp::proto::runtime::RemoteObject::subtype`](struct.RemoteObject.html#structfield.subtype)."]
    pub enum RemoteObjectSubtype {
        #[serde(rename = "array")]
        #[doc = "Represented as `\"array\"`."]
        Array,
        #[serde(rename = "null")]
        #[doc = "Represented as `\"null\"`."]
        Null,
        #[serde(rename = "node")]
        #[doc = "Represented as `\"node\"`."]
        Node,
        #[serde(rename = "regexp")]
        #[doc = "Represented as `\"regexp\"`."]
        Regexp,
        #[serde(rename = "date")]
        #[doc = "Represented as `\"date\"`."]
        Date,
        #[serde(rename = "map")]
        #[doc = "Represented as `\"map\"`."]
        Map,
        #[serde(rename = "set")]
        #[doc = "Represented as `\"set\"`."]
        Set,
        #[serde(rename = "weakmap")]
        #[doc = "Represented as `\"weakmap\"`."]
        Weakmap,
        #[serde(rename = "weakset")]
        #[doc = "Represented as `\"weakset\"`."]
        Weakset,
        #[serde(rename = "iterator")]
        #[doc = "Represented as `\"iterator\"`."]
        Iterator,
        #[serde(rename = "generator")]
        #[doc = "Represented as `\"generator\"`."]
        Generator,
        #[serde(rename = "error")]
        #[doc = "Represented as `\"error\"`."]
        Error,
        #[serde(rename = "proxy")]
        #[doc = "Represented as `\"proxy\"`."]
        Proxy,
        #[serde(rename = "promise")]
        #[doc = "Represented as `\"promise\"`."]
        Promise,
        #[serde(rename = "typedarray")]
        #[doc = "Represented as `\"typedarray\"`."]
        Typedarray,
    }
    impl RemoteObjectSubtype {
        pub const ENUM_VALUES: &'static [RemoteObjectSubtype] = &[
            RemoteObjectSubtype::Array,
            RemoteObjectSubtype::Null,
            RemoteObjectSubtype::Node,
            RemoteObjectSubtype::Regexp,
            RemoteObjectSubtype::Date,
            RemoteObjectSubtype::Map,
            RemoteObjectSubtype::Set,
            RemoteObjectSubtype::Weakmap,
            RemoteObjectSubtype::Weakset,
            RemoteObjectSubtype::Iterator,
            RemoteObjectSubtype::Generator,
            RemoteObjectSubtype::Error,
            RemoteObjectSubtype::Proxy,
            RemoteObjectSubtype::Promise,
            RemoteObjectSubtype::Typedarray,
        ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "array",
            "null",
            "node",
            "regexp",
            "date",
            "map",
            "set",
            "weakmap",
            "weakset",
            "iterator",
            "generator",
            "error",
            "proxy",
            "promise",
            "typedarray",
        ];
    }
    impl ::std::str::FromStr for RemoteObjectSubtype {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "array" => Ok(RemoteObjectSubtype::Array),
                "null" => Ok(RemoteObjectSubtype::Null),
                "node" => Ok(RemoteObjectSubtype::Node),
                "regexp" => Ok(RemoteObjectSubtype::Regexp),
                "date" => Ok(RemoteObjectSubtype::Date),
                "map" => Ok(RemoteObjectSubtype::Map),
                "set" => Ok(RemoteObjectSubtype::Set),
                "weakmap" => Ok(RemoteObjectSubtype::Weakmap),
                "weakset" => Ok(RemoteObjectSubtype::Weakset),
                "iterator" => Ok(RemoteObjectSubtype::Iterator),
                "generator" => Ok(RemoteObjectSubtype::Generator),
                "error" => Ok(RemoteObjectSubtype::Error),
                "proxy" => Ok(RemoteObjectSubtype::Proxy),
                "promise" => Ok(RemoteObjectSubtype::Promise),
                "typedarray" => Ok(RemoteObjectSubtype::Typedarray),
                _ => Err(::proto::ParseEnumError {
                    expected: RemoteObjectSubtype::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for RemoteObjectSubtype {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    RemoteObjectSubtype::Array => "array",
                    RemoteObjectSubtype::Null => "null",
                    RemoteObjectSubtype::Node => "node",
                    RemoteObjectSubtype::Regexp => "regexp",
                    RemoteObjectSubtype::Date => "date",
                    RemoteObjectSubtype::Map => "map",
                    RemoteObjectSubtype::Set => "set",
                    RemoteObjectSubtype::Weakmap => "weakmap",
                    RemoteObjectSubtype::Weakset => "weakset",
                    RemoteObjectSubtype::Iterator => "iterator",
                    RemoteObjectSubtype::Generator => "generator",
                    RemoteObjectSubtype::Error => "error",
                    RemoteObjectSubtype::Proxy => "proxy",
                    RemoteObjectSubtype::Promise => "promise",
                    RemoteObjectSubtype::Typedarray => "typedarray",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Mirror object referencing original JavaScript object."]
    pub struct RemoteObject<'a> {
        #[serde(rename = "type")]
        #[doc = "Object type."]
        pub ty: ::proto::runtime::RemoteObjectType,
        #[serde(rename = "subtype", skip_serializing_if = "Option::is_none")]
        #[doc = "Object subtype hint. Specified for <code>object</code> type values only."]
        pub subtype: Option<::proto::runtime::RemoteObjectSubtype>,
        #[serde(rename = "className", skip_serializing_if = "Option::is_none")]
        #[doc = "Object class \\(constructor\\) name. Specified for <code>object</code> type values only."]
        pub class_name: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "value", skip_serializing_if = "Option::is_none")]
        #[doc = "Remote object value in case of primitive values or JSON values \\(if it was requested\\)."]
        pub value: Option<::serde_json::Value>,
        #[serde(rename = "unserializableValue", skip_serializing_if = "Option::is_none")]
        #[doc = "Primitive value which can not be JSON-stringified does not have <code>value</code>, but gets this property."]
        pub unserializable_value: Option<::proto::runtime::UnserializableValue>,
        #[serde(rename = "description", skip_serializing_if = "Option::is_none")]
        #[doc = "String representation of the object."]
        pub description: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "objectId", skip_serializing_if = "Option::is_none")]
        #[doc = "Unique object identifier \\(for non-primitive values\\)."]
        pub object_id: Option<::proto::runtime::RemoteObjectId<'a>>,
        #[serde(rename = "preview", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Preview containing abbreviated property values. Specified for <code>object</code> type values only."]
        pub preview: Option<::proto::runtime::ObjectPreview<'a>>,
        #[serde(rename = "customPreview", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span>"]
        pub custom_preview: Option<::proto::runtime::CustomPreview<'a>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>"]
    pub struct CustomPreview<'a> {
        #[serde(rename = "header")]
        pub header: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "hasBody")]
        pub has_body: bool,
        #[serde(rename = "formatterObjectId")]
        pub formatter_object_id: ::proto::runtime::RemoteObjectId<'a>,
        #[serde(rename = "bindRemoteObjectFunctionId")]
        pub bind_remote_object_function_id: ::proto::runtime::RemoteObjectId<'a>,
        #[serde(rename = "configObjectId", skip_serializing_if = "Option::is_none")]
        pub config_object_id: Option<::proto::runtime::RemoteObjectId<'a>>,
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\nUsed in the type of [`cdp::proto::runtime::ObjectPreview::ty`](struct.ObjectPreview.html#structfield.ty)."]
    pub enum ObjectPreviewType {
        #[serde(rename = "object")]
        #[doc = "Represented as `\"object\"`."]
        Object,
        #[serde(rename = "function")]
        #[doc = "Represented as `\"function\"`."]
        Function,
        #[serde(rename = "undefined")]
        #[doc = "Represented as `\"undefined\"`."]
        Undefined,
        #[serde(rename = "string")]
        #[doc = "Represented as `\"string\"`."]
        String,
        #[serde(rename = "number")]
        #[doc = "Represented as `\"number\"`."]
        Number,
        #[serde(rename = "boolean")]
        #[doc = "Represented as `\"boolean\"`."]
        Boolean,
        #[serde(rename = "symbol")]
        #[doc = "Represented as `\"symbol\"`."]
        Symbol,
    }
    impl ObjectPreviewType {
        pub const ENUM_VALUES: &'static [ObjectPreviewType] = &[
            ObjectPreviewType::Object,
            ObjectPreviewType::Function,
            ObjectPreviewType::Undefined,
            ObjectPreviewType::String,
            ObjectPreviewType::Number,
            ObjectPreviewType::Boolean,
            ObjectPreviewType::Symbol,
        ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "object",
            "function",
            "undefined",
            "string",
            "number",
            "boolean",
            "symbol",
        ];
    }
    impl ::std::str::FromStr for ObjectPreviewType {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "object" => Ok(ObjectPreviewType::Object),
                "function" => Ok(ObjectPreviewType::Function),
                "undefined" => Ok(ObjectPreviewType::Undefined),
                "string" => Ok(ObjectPreviewType::String),
                "number" => Ok(ObjectPreviewType::Number),
                "boolean" => Ok(ObjectPreviewType::Boolean),
                "symbol" => Ok(ObjectPreviewType::Symbol),
                _ => Err(::proto::ParseEnumError {
                    expected: ObjectPreviewType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for ObjectPreviewType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    ObjectPreviewType::Object => "object",
                    ObjectPreviewType::Function => "function",
                    ObjectPreviewType::Undefined => "undefined",
                    ObjectPreviewType::String => "string",
                    ObjectPreviewType::Number => "number",
                    ObjectPreviewType::Boolean => "boolean",
                    ObjectPreviewType::Symbol => "symbol",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\nUsed in the type of [`cdp::proto::runtime::ObjectPreview::subtype`](struct.ObjectPreview.html#structfield.subtype)."]
    pub enum ObjectPreviewSubtype {
        #[serde(rename = "array")]
        #[doc = "Represented as `\"array\"`."]
        Array,
        #[serde(rename = "null")]
        #[doc = "Represented as `\"null\"`."]
        Null,
        #[serde(rename = "node")]
        #[doc = "Represented as `\"node\"`."]
        Node,
        #[serde(rename = "regexp")]
        #[doc = "Represented as `\"regexp\"`."]
        Regexp,
        #[serde(rename = "date")]
        #[doc = "Represented as `\"date\"`."]
        Date,
        #[serde(rename = "map")]
        #[doc = "Represented as `\"map\"`."]
        Map,
        #[serde(rename = "set")]
        #[doc = "Represented as `\"set\"`."]
        Set,
        #[serde(rename = "weakmap")]
        #[doc = "Represented as `\"weakmap\"`."]
        Weakmap,
        #[serde(rename = "weakset")]
        #[doc = "Represented as `\"weakset\"`."]
        Weakset,
        #[serde(rename = "iterator")]
        #[doc = "Represented as `\"iterator\"`."]
        Iterator,
        #[serde(rename = "generator")]
        #[doc = "Represented as `\"generator\"`."]
        Generator,
        #[serde(rename = "error")]
        #[doc = "Represented as `\"error\"`."]
        Error,
    }
    impl ObjectPreviewSubtype {
        pub const ENUM_VALUES: &'static [ObjectPreviewSubtype] = &[
            ObjectPreviewSubtype::Array,
            ObjectPreviewSubtype::Null,
            ObjectPreviewSubtype::Node,
            ObjectPreviewSubtype::Regexp,
            ObjectPreviewSubtype::Date,
            ObjectPreviewSubtype::Map,
            ObjectPreviewSubtype::Set,
            ObjectPreviewSubtype::Weakmap,
            ObjectPreviewSubtype::Weakset,
            ObjectPreviewSubtype::Iterator,
            ObjectPreviewSubtype::Generator,
            ObjectPreviewSubtype::Error,
        ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "array",
            "null",
            "node",
            "regexp",
            "date",
            "map",
            "set",
            "weakmap",
            "weakset",
            "iterator",
            "generator",
            "error",
        ];
    }
    impl ::std::str::FromStr for ObjectPreviewSubtype {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "array" => Ok(ObjectPreviewSubtype::Array),
                "null" => Ok(ObjectPreviewSubtype::Null),
                "node" => Ok(ObjectPreviewSubtype::Node),
                "regexp" => Ok(ObjectPreviewSubtype::Regexp),
                "date" => Ok(ObjectPreviewSubtype::Date),
                "map" => Ok(ObjectPreviewSubtype::Map),
                "set" => Ok(ObjectPreviewSubtype::Set),
                "weakmap" => Ok(ObjectPreviewSubtype::Weakmap),
                "weakset" => Ok(ObjectPreviewSubtype::Weakset),
                "iterator" => Ok(ObjectPreviewSubtype::Iterator),
                "generator" => Ok(ObjectPreviewSubtype::Generator),
                "error" => Ok(ObjectPreviewSubtype::Error),
                _ => Err(::proto::ParseEnumError {
                    expected: ObjectPreviewSubtype::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for ObjectPreviewSubtype {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    ObjectPreviewSubtype::Array => "array",
                    ObjectPreviewSubtype::Null => "null",
                    ObjectPreviewSubtype::Node => "node",
                    ObjectPreviewSubtype::Regexp => "regexp",
                    ObjectPreviewSubtype::Date => "date",
                    ObjectPreviewSubtype::Map => "map",
                    ObjectPreviewSubtype::Set => "set",
                    ObjectPreviewSubtype::Weakmap => "weakmap",
                    ObjectPreviewSubtype::Weakset => "weakset",
                    ObjectPreviewSubtype::Iterator => "iterator",
                    ObjectPreviewSubtype::Generator => "generator",
                    ObjectPreviewSubtype::Error => "error",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Object containing abbreviated remote object value."]
    pub struct ObjectPreview<'a> {
        #[serde(rename = "type")]
        #[doc = "Object type."]
        pub ty: ::proto::runtime::ObjectPreviewType,
        #[serde(rename = "subtype", skip_serializing_if = "Option::is_none")]
        #[doc = "Object subtype hint. Specified for <code>object</code> type values only."]
        pub subtype: Option<::proto::runtime::ObjectPreviewSubtype>,
        #[serde(rename = "description", skip_serializing_if = "Option::is_none")]
        #[doc = "String representation of the object."]
        pub description: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "overflow")]
        #[doc = "True iff some of the properties or entries of the original object did not fit."]
        pub overflow: bool,
        #[serde(rename = "properties")]
        #[doc = "List of the properties."]
        pub properties: Vec<::proto::runtime::PropertyPreview<'a>>,
        #[serde(rename = "entries", skip_serializing_if = "Option::is_none")]
        #[doc = "List of the entries. Specified for <code>map</code> and <code>set</code> subtype values only."]
        pub entries: Option<Vec<::proto::runtime::EntryPreview<'a>>>,
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\nUsed in the type of [`cdp::proto::runtime::PropertyPreview::ty`](struct.PropertyPreview.html#structfield.ty)."]
    pub enum PropertyPreviewType {
        #[serde(rename = "object")]
        #[doc = "Represented as `\"object\"`."]
        Object,
        #[serde(rename = "function")]
        #[doc = "Represented as `\"function\"`."]
        Function,
        #[serde(rename = "undefined")]
        #[doc = "Represented as `\"undefined\"`."]
        Undefined,
        #[serde(rename = "string")]
        #[doc = "Represented as `\"string\"`."]
        String,
        #[serde(rename = "number")]
        #[doc = "Represented as `\"number\"`."]
        Number,
        #[serde(rename = "boolean")]
        #[doc = "Represented as `\"boolean\"`."]
        Boolean,
        #[serde(rename = "symbol")]
        #[doc = "Represented as `\"symbol\"`."]
        Symbol,
        #[serde(rename = "accessor")]
        #[doc = "Represented as `\"accessor\"`."]
        Accessor,
    }
    impl PropertyPreviewType {
        pub const ENUM_VALUES: &'static [PropertyPreviewType] = &[
            PropertyPreviewType::Object,
            PropertyPreviewType::Function,
            PropertyPreviewType::Undefined,
            PropertyPreviewType::String,
            PropertyPreviewType::Number,
            PropertyPreviewType::Boolean,
            PropertyPreviewType::Symbol,
            PropertyPreviewType::Accessor,
        ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "object",
            "function",
            "undefined",
            "string",
            "number",
            "boolean",
            "symbol",
            "accessor",
        ];
    }
    impl ::std::str::FromStr for PropertyPreviewType {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "object" => Ok(PropertyPreviewType::Object),
                "function" => Ok(PropertyPreviewType::Function),
                "undefined" => Ok(PropertyPreviewType::Undefined),
                "string" => Ok(PropertyPreviewType::String),
                "number" => Ok(PropertyPreviewType::Number),
                "boolean" => Ok(PropertyPreviewType::Boolean),
                "symbol" => Ok(PropertyPreviewType::Symbol),
                "accessor" => Ok(PropertyPreviewType::Accessor),
                _ => Err(::proto::ParseEnumError {
                    expected: PropertyPreviewType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for PropertyPreviewType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    PropertyPreviewType::Object => "object",
                    PropertyPreviewType::Function => "function",
                    PropertyPreviewType::Undefined => "undefined",
                    PropertyPreviewType::String => "string",
                    PropertyPreviewType::Number => "number",
                    PropertyPreviewType::Boolean => "boolean",
                    PropertyPreviewType::Symbol => "symbol",
                    PropertyPreviewType::Accessor => "accessor",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\nUsed in the type of [`cdp::proto::runtime::PropertyPreview::subtype`](struct.PropertyPreview.html#structfield.subtype)."]
    pub enum PropertyPreviewSubtype {
        #[serde(rename = "array")]
        #[doc = "Represented as `\"array\"`."]
        Array,
        #[serde(rename = "null")]
        #[doc = "Represented as `\"null\"`."]
        Null,
        #[serde(rename = "node")]
        #[doc = "Represented as `\"node\"`."]
        Node,
        #[serde(rename = "regexp")]
        #[doc = "Represented as `\"regexp\"`."]
        Regexp,
        #[serde(rename = "date")]
        #[doc = "Represented as `\"date\"`."]
        Date,
        #[serde(rename = "map")]
        #[doc = "Represented as `\"map\"`."]
        Map,
        #[serde(rename = "set")]
        #[doc = "Represented as `\"set\"`."]
        Set,
        #[serde(rename = "weakmap")]
        #[doc = "Represented as `\"weakmap\"`."]
        Weakmap,
        #[serde(rename = "weakset")]
        #[doc = "Represented as `\"weakset\"`."]
        Weakset,
        #[serde(rename = "iterator")]
        #[doc = "Represented as `\"iterator\"`."]
        Iterator,
        #[serde(rename = "generator")]
        #[doc = "Represented as `\"generator\"`."]
        Generator,
        #[serde(rename = "error")]
        #[doc = "Represented as `\"error\"`."]
        Error,
    }
    impl PropertyPreviewSubtype {
        pub const ENUM_VALUES: &'static [PropertyPreviewSubtype] =
            &[
                PropertyPreviewSubtype::Array,
                PropertyPreviewSubtype::Null,
                PropertyPreviewSubtype::Node,
                PropertyPreviewSubtype::Regexp,
                PropertyPreviewSubtype::Date,
                PropertyPreviewSubtype::Map,
                PropertyPreviewSubtype::Set,
                PropertyPreviewSubtype::Weakmap,
                PropertyPreviewSubtype::Weakset,
                PropertyPreviewSubtype::Iterator,
                PropertyPreviewSubtype::Generator,
                PropertyPreviewSubtype::Error,
            ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "array",
            "null",
            "node",
            "regexp",
            "date",
            "map",
            "set",
            "weakmap",
            "weakset",
            "iterator",
            "generator",
            "error",
        ];
    }
    impl ::std::str::FromStr for PropertyPreviewSubtype {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "array" => Ok(PropertyPreviewSubtype::Array),
                "null" => Ok(PropertyPreviewSubtype::Null),
                "node" => Ok(PropertyPreviewSubtype::Node),
                "regexp" => Ok(PropertyPreviewSubtype::Regexp),
                "date" => Ok(PropertyPreviewSubtype::Date),
                "map" => Ok(PropertyPreviewSubtype::Map),
                "set" => Ok(PropertyPreviewSubtype::Set),
                "weakmap" => Ok(PropertyPreviewSubtype::Weakmap),
                "weakset" => Ok(PropertyPreviewSubtype::Weakset),
                "iterator" => Ok(PropertyPreviewSubtype::Iterator),
                "generator" => Ok(PropertyPreviewSubtype::Generator),
                "error" => Ok(PropertyPreviewSubtype::Error),
                _ => Err(::proto::ParseEnumError {
                    expected: PropertyPreviewSubtype::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for PropertyPreviewSubtype {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    PropertyPreviewSubtype::Array => "array",
                    PropertyPreviewSubtype::Null => "null",
                    PropertyPreviewSubtype::Node => "node",
                    PropertyPreviewSubtype::Regexp => "regexp",
                    PropertyPreviewSubtype::Date => "date",
                    PropertyPreviewSubtype::Map => "map",
                    PropertyPreviewSubtype::Set => "set",
                    PropertyPreviewSubtype::Weakmap => "weakmap",
                    PropertyPreviewSubtype::Weakset => "weakset",
                    PropertyPreviewSubtype::Iterator => "iterator",
                    PropertyPreviewSubtype::Generator => "generator",
                    PropertyPreviewSubtype::Error => "error",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>"]
    pub struct PropertyPreview<'a> {
        #[serde(rename = "name")]
        #[doc = "Property name."]
        pub name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "type")]
        #[doc = "Object type. Accessor means that the property itself is an accessor property."]
        pub ty: ::proto::runtime::PropertyPreviewType,
        #[serde(rename = "value", skip_serializing_if = "Option::is_none")]
        #[doc = "User-friendly property value string."]
        pub value: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "valuePreview", skip_serializing_if = "Option::is_none")]
        #[doc = "Nested value preview."]
        pub value_preview: Option<::proto::runtime::ObjectPreview<'a>>,
        #[serde(rename = "subtype", skip_serializing_if = "Option::is_none")]
        #[doc = "Object subtype hint. Specified for <code>object</code> type values only."]
        pub subtype: Option<::proto::runtime::PropertyPreviewSubtype>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>"]
    pub struct EntryPreview<'a> {
        #[serde(rename = "key", skip_serializing_if = "Option::is_none")]
        #[doc = "Preview of the key. Specified for map-like collection entries."]
        pub key: Option<::proto::runtime::ObjectPreview<'a>>,
        #[serde(rename = "value")]
        #[doc = "Preview of the value."]
        pub value: ::proto::runtime::ObjectPreview<'a>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Object property descriptor."]
    pub struct PropertyDescriptor<'a> {
        #[serde(rename = "name")]
        #[doc = "Property name or symbol description."]
        pub name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "value", skip_serializing_if = "Option::is_none")]
        #[doc = "The value associated with the property."]
        pub value: Option<::proto::runtime::RemoteObject<'a>>,
        #[serde(rename = "writable", skip_serializing_if = "Option::is_none")]
        #[doc = "True if the value associated with the property may be changed \\(data descriptors only\\)."]
        pub writable: Option<bool>,
        #[serde(rename = "get", skip_serializing_if = "Option::is_none")]
        #[doc = "A function which serves as a getter for the property, or <code>undefined</code> if there is no getter \\(accessor descriptors only\\)."]
        pub get: Option<::proto::runtime::RemoteObject<'a>>,
        #[serde(rename = "set", skip_serializing_if = "Option::is_none")]
        #[doc = "A function which serves as a setter for the property, or <code>undefined</code> if there is no setter \\(accessor descriptors only\\)."]
        pub set: Option<::proto::runtime::RemoteObject<'a>>,
        #[serde(rename = "configurable")]
        #[doc = "True if the type of this property descriptor may be changed and if the property may be deleted from the corresponding object."]
        pub configurable: bool,
        #[serde(rename = "enumerable")]
        #[doc = "True if this property shows up during enumeration of the properties on the corresponding object."]
        pub enumerable: bool,
        #[serde(rename = "wasThrown", skip_serializing_if = "Option::is_none")]
        #[doc = "True if the result was thrown during the evaluation."]
        pub was_thrown: Option<bool>,
        #[serde(rename = "isOwn", skip_serializing_if = "Option::is_none")]
        #[doc = "True if the property is owned for the object."]
        pub is_own: Option<bool>,
        #[serde(rename = "symbol", skip_serializing_if = "Option::is_none")]
        #[doc = "Property symbol object, if the property is of the <code>symbol</code> type."]
        pub symbol: Option<::proto::runtime::RemoteObject<'a>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Object internal property descriptor. This property isn't normally visible in JavaScript code."]
    pub struct InternalPropertyDescriptor<'a> {
        #[serde(rename = "name")]
        #[doc = "Conventional property name."]
        pub name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "value", skip_serializing_if = "Option::is_none")]
        #[doc = "The value associated with the property."]
        pub value: Option<::proto::runtime::RemoteObject<'a>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Represents function call argument. Either remote object id <code>objectId</code>, primitive <code>value</code>, unserializable primitive value or neither of \\(for undefined\\) them should be specified."]
    pub struct CallArgument<'a> {
        #[serde(rename = "value", skip_serializing_if = "Option::is_none")]
        #[doc = "Primitive value."]
        pub value: Option<::serde_json::Value>,
        #[serde(rename = "unserializableValue", skip_serializing_if = "Option::is_none")]
        #[doc = "Primitive value which can not be JSON-stringified."]
        pub unserializable_value: Option<::proto::runtime::UnserializableValue>,
        #[serde(rename = "objectId", skip_serializing_if = "Option::is_none")]
        #[doc = "Remote object handle."]
        pub object_id: Option<::proto::runtime::RemoteObjectId<'a>>,
    }
    #[doc = "Id of an execution context."]
    pub type ExecutionContextId = i32;
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Description of an isolated world."]
    pub struct ExecutionContextDescription<'a> {
        #[serde(rename = "id")]
        #[doc = "Unique id of the execution context. It can be used to specify in which execution context script evaluation should be performed."]
        pub id: ::proto::runtime::ExecutionContextId,
        #[serde(rename = "origin")]
        #[doc = "Execution context origin."]
        pub origin: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "name")]
        #[doc = "Human readable name describing given context."]
        pub name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "auxData", skip_serializing_if = "Option::is_none")]
        #[doc = "Embedder-specific auxiliary data."]
        pub aux_data: Option<::proto::Empty>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Detailed information about exception \\(or error\\) that was thrown during script compilation or execution."]
    pub struct ExceptionDetails<'a> {
        #[serde(rename = "exceptionId")]
        #[doc = "Exception id."]
        pub exception_id: i32,
        #[serde(rename = "text")]
        #[doc = "Exception text, which should be used together with exception object when available."]
        pub text: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "lineNumber")]
        #[doc = "Line number of the exception location \\(0-based\\)."]
        pub line_number: i32,
        #[serde(rename = "columnNumber")]
        #[doc = "Column number of the exception location \\(0-based\\)."]
        pub column_number: i32,
        #[serde(rename = "scriptId", skip_serializing_if = "Option::is_none")]
        #[doc = "Script ID of the exception location."]
        pub script_id: Option<::proto::runtime::ScriptId<'a>>,
        #[serde(rename = "url", skip_serializing_if = "Option::is_none")]
        #[doc = "URL of the exception location, to be used when the script was not reported."]
        pub url: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "stackTrace", skip_serializing_if = "Option::is_none")]
        #[doc = "JavaScript stack trace if available."]
        pub stack_trace: Option<::proto::runtime::StackTrace<'a>>,
        #[serde(rename = "exception", skip_serializing_if = "Option::is_none")]
        #[doc = "Exception object if available."]
        pub exception: Option<::proto::runtime::RemoteObject<'a>>,
        #[serde(rename = "executionContextId", skip_serializing_if = "Option::is_none")]
        #[doc = "Identifier of the context where exception happened."]
        pub execution_context_id: Option<::proto::runtime::ExecutionContextId>,
    }
    #[doc = "Number of milliseconds since epoch."]
    pub type Timestamp = f64;
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Stack entry for runtime errors and assertions."]
    pub struct CallFrame<'a> {
        #[serde(rename = "functionName")]
        #[doc = "JavaScript function name."]
        pub function_name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "scriptId")]
        #[doc = "JavaScript script id."]
        pub script_id: ::proto::runtime::ScriptId<'a>,
        #[serde(rename = "url")]
        #[doc = "JavaScript script name or url."]
        pub url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "lineNumber")]
        #[doc = "JavaScript script line number \\(0-based\\)."]
        pub line_number: i32,
        #[serde(rename = "columnNumber")]
        #[doc = "JavaScript script column number \\(0-based\\)."]
        pub column_number: i32,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Call frames for assertions or error messages."]
    pub struct StackTrace<'a> {
        #[serde(rename = "description", skip_serializing_if = "Option::is_none")]
        #[doc = "String label of this stack trace. For async traces this may be a name of the function that initiated the async call."]
        pub description: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "callFrames")]
        #[doc = "JavaScript function name."]
        pub call_frames: Vec<::proto::runtime::CallFrame<'a>>,
        #[serde(rename = "parent", skip_serializing_if = "Option::is_none")]
        #[doc = "Asynchronous JavaScript stack trace that preceded this stack, if available."]
        pub parent: Option<Box<::proto::runtime::StackTrace<'a>>>,
        #[serde(rename = "promiseCreationFrame", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Creation frame of the Promise which produced the next synchronous trace when resolved, if available."]
        pub promise_creation_frame: Option<::proto::runtime::CallFrame<'a>>,
    }
}
#[doc = "Debugger domain exposes JavaScript debugging capabilities. It allows setting and removing breakpoints, stepping through execution, exploring stack traces, etc.\n\n# Debugger\n\n## Commands\n\n- [`Debugger.enable`](struct.EnableCommand.html)\n\n  Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.\n- [`Debugger.disable`](struct.DisableCommand.html)\n\n  Disables debugger for given page.\n- [`Debugger.setBreakpointsActive`](struct.SetBreakpointsActiveCommand.html)\n\n  Activates / deactivates all breakpoints on the page.\n- [`Debugger.setSkipAllPauses`](struct.SetSkipAllPausesCommand.html)\n\n  Makes page not interrupt on any pauses \\(breakpoint, exception, dom exception etc\\).\n- [`Debugger.setBreakpointByUrl`](struct.SetBreakpointByUrlCommand.html)\n\n  Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.\n- [`Debugger.setBreakpoint`](struct.SetBreakpointCommand.html)\n\n  Sets JavaScript breakpoint at a given location.\n- [`Debugger.removeBreakpoint`](struct.RemoveBreakpointCommand.html)\n\n  Removes JavaScript breakpoint.\n- [`Debugger.getPossibleBreakpoints`](struct.GetPossibleBreakpointsCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.\n- [`Debugger.continueToLocation`](struct.ContinueToLocationCommand.html)\n\n  Continues execution until specific location is reached.\n- [`Debugger.stepOver`](struct.StepOverCommand.html)\n\n  Steps over the statement.\n- [`Debugger.stepInto`](struct.StepIntoCommand.html)\n\n  Steps into the function call.\n- [`Debugger.stepOut`](struct.StepOutCommand.html)\n\n  Steps out of the function call.\n- [`Debugger.pause`](struct.PauseCommand.html)\n\n  Stops on the next JavaScript statement.\n- [`Debugger.scheduleStepIntoAsync`](struct.ScheduleStepIntoAsyncCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.\n- [`Debugger.resume`](struct.ResumeCommand.html)\n\n  Resumes JavaScript execution.\n- [`Debugger.searchInContent`](struct.SearchInContentCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Searches for given string in script content.\n- [`Debugger.setScriptSource`](struct.SetScriptSourceCommand.html)\n\n  Edits JavaScript source live.\n- [`Debugger.restartFrame`](struct.RestartFrameCommand.html)\n\n  Restarts particular call frame from the beginning.\n- [`Debugger.getScriptSource`](struct.GetScriptSourceCommand.html)\n\n  Returns source for the script with given id.\n- [`Debugger.setPauseOnExceptions`](struct.SetPauseOnExceptionsCommand.html)\n\n  Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.\n- [`Debugger.evaluateOnCallFrame`](struct.EvaluateOnCallFrameCommand.html)\n\n  Evaluates expression on a given call frame.\n- [`Debugger.setVariableValue`](struct.SetVariableValueCommand.html)\n\n  Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.\n- [`Debugger.setAsyncCallStackDepth`](struct.SetAsyncCallStackDepthCommand.html)\n\n  Enables or disables async call stacks tracking.\n- [`Debugger.setBlackboxPatterns`](struct.SetBlackboxPatternsCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.\n- [`Debugger.setBlackboxedRanges`](struct.SetBlackboxedRangesCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.\n\n## Events\n\n- [`Debugger.scriptParsed`](struct.ScriptParsedEvent.html)\n\n  Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.\n- [`Debugger.scriptFailedToParse`](struct.ScriptFailedToParseEvent.html)\n\n  Fired when virtual machine fails to parse the script.\n- [`Debugger.breakpointResolved`](struct.BreakpointResolvedEvent.html)\n\n  Fired when breakpoint is resolved to an actual script and location.\n- [`Debugger.paused`](struct.PausedEvent.html)\n\n  Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.\n- [`Debugger.resumed`](struct.ResumedEvent.html)\n\n  Fired when the virtual machine resumed execution.\n\n##Types\n\n- [`BreakpointId`](type.BreakpointId.html)\n\n  Breakpoint identifier.\n- [`CallFrameId`](type.CallFrameId.html)\n\n  Call frame identifier.\n- [`Location`](struct.Location.html)\n\n  Location in the source code.\n- [`ScriptPosition`](struct.ScriptPosition.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Location in the source code.\n- [`CallFrame`](struct.CallFrame.html)\n\n  JavaScript call frame. Array of call frames form the call stack.\n- [`Scope`](struct.Scope.html)\n\n  Scope description.\n- [`SearchMatch`](struct.SearchMatch.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Search match for resource.\n- [`BreakLocation`](struct.BreakLocation.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n"]
pub mod debugger {
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.\n\n# Command `Debugger.enable`\n\n*Domain Module:* [`cdp::proto::debugger`](index.html)  \n*Command Struct:* [`cdp::proto::debugger::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::proto::debugger::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableCommand;
    impl ::serde::Serialize for EnableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for EnableCommand {
        fn command_name(&self) -> &str {
            "Debugger.enable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for EnableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.enable" {
                Ok(
                    <EnableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.\n\n# Command `Debugger.enable`\n\n*Domain Module:* [`cdp::proto::debugger`](index.html)  \n*Command Struct:* [`cdp::proto::debugger::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::proto::debugger::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableResponse;
    impl ::serde::Serialize for EnableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for EnableCommand {
        type Response = EnableResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for EnableResponse {
        type Command = EnableCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Disables debugger for given page.\n\n# Command `Debugger.disable`\n\n*Domain Module:* [`cdp::proto::debugger`](index.html)  \n*Command Struct:* [`cdp::proto::debugger::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::proto::debugger::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableCommand;
    impl ::serde::Serialize for DisableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for DisableCommand {
        fn command_name(&self) -> &str {
            "Debugger.disable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for DisableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.disable" {
                Ok(
                    <DisableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Disables debugger for given page.\n\n# Command `Debugger.disable`\n\n*Domain Module:* [`cdp::proto::debugger`](index.html)  \n*Command Struct:* [`cdp::proto::debugger::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::proto::debugger::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableResponse;
    impl ::serde::Serialize for DisableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for DisableCommand {
        type Response = DisableResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for DisableResponse {
        type Command = DisableCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Activates / deactivates all breakpoints on the page.\n\n# Command `Debugger.setBreakpointsActive`\n\n*Domain Module:* [`cdp::proto::debugger`](index.html)  \n*Command Struct:* [`cdp::proto::debugger::SetBreakpointsActiveCommand`](struct.SetBreakpointsActiveCommand.html)  \n*Response Struct:* [`cdp::proto::debugger::SetBreakpointsActiveResponse`](struct.SetBreakpointsActiveResponse.html)"]
    pub struct SetBreakpointsActiveCommand {
        #[serde(rename = "active")]
        #[doc = "New value for breakpoints active state."]
        pub active: bool,
    }
    impl ::traits::SerializeCdpCommand for SetBreakpointsActiveCommand {
        fn command_name(&self) -> &str {
            "Debugger.setBreakpointsActive"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for SetBreakpointsActiveCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.setBreakpointsActive" {
                Ok ( < SetBreakpointsActiveCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Activates / deactivates all breakpoints on the page.\n\n# Command `Debugger.setBreakpointsActive`\n\n*Domain Module:* [`cdp::proto::debugger`](index.html)  \n*Command Struct:* [`cdp::proto::debugger::SetBreakpointsActiveCommand`](struct.SetBreakpointsActiveCommand.html)  \n*Response Struct:* [`cdp::proto::debugger::SetBreakpointsActiveResponse`](struct.SetBreakpointsActiveResponse.html)"]
    pub struct SetBreakpointsActiveResponse;
    impl ::serde::Serialize for SetBreakpointsActiveResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetBreakpointsActiveResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetBreakpointsActiveResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetBreakpointsActiveCommand {
        type Response = SetBreakpointsActiveResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetBreakpointsActiveResponse {
        type Command = SetBreakpointsActiveCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Makes page not interrupt on any pauses \\(breakpoint, exception, dom exception etc\\).\n\n# Command `Debugger.setSkipAllPauses`\n\n*Domain Module:* [`cdp::proto::debugger`](index.html)  \n*Command Struct:* [`cdp::proto::debugger::SetSkipAllPausesCommand`](struct.SetSkipAllPausesCommand.html)  \n*Response Struct:* [`cdp::proto::debugger::SetSkipAllPausesResponse`](struct.SetSkipAllPausesResponse.html)"]
    pub struct SetSkipAllPausesCommand {
        #[serde(rename = "skip")]
        #[doc = "New value for skip pauses state."]
        pub skip: bool,
    }
    impl ::traits::SerializeCdpCommand for SetSkipAllPausesCommand {
        fn command_name(&self) -> &str {
            "Debugger.setSkipAllPauses"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for SetSkipAllPausesCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.setSkipAllPauses" {
                Ok ( < SetSkipAllPausesCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Makes page not interrupt on any pauses \\(breakpoint, exception, dom exception etc\\).\n\n# Command `Debugger.setSkipAllPauses`\n\n*Domain Module:* [`cdp::proto::debugger`](index.html)  \n*Command Struct:* [`cdp::proto::debugger::SetSkipAllPausesCommand`](struct.SetSkipAllPausesCommand.html)  \n*Response Struct:* [`cdp::proto::debugger::SetSkipAllPausesResponse`](struct.SetSkipAllPausesResponse.html)"]
    pub struct SetSkipAllPausesResponse;
    impl ::serde::Serialize for SetSkipAllPausesResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetSkipAllPausesResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetSkipAllPausesResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetSkipAllPausesCommand {
        type Response = SetSkipAllPausesResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetSkipAllPausesResponse {
        type Command = SetSkipAllPausesCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.\n\n# Command `Debugger.setBreakpointByUrl`\n\n*Domain Module:* [`cdp::proto::debugger`](index.html)  \n*Command Struct:* [`cdp::proto::debugger::SetBreakpointByUrlCommand`](struct.SetBreakpointByUrlCommand.html)  \n*Response Struct:* [`cdp::proto::debugger::SetBreakpointByUrlResponse`](struct.SetBreakpointByUrlResponse.html)"]
    pub struct SetBreakpointByUrlCommand<'a> {
        #[serde(rename = "lineNumber")]
        #[doc = "Line number to set breakpoint at."]
        pub line_number: i32,
        #[serde(rename = "url", skip_serializing_if = "Option::is_none")]
        #[doc = "URL of the resources to set breakpoint on."]
        pub url: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "urlRegex", skip_serializing_if = "Option::is_none")]
        #[doc = "Regex pattern for the URLs of the resources to set breakpoints on. Either <code>url</code> or <code>urlRegex</code> must be specified."]
        pub url_regex: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "columnNumber", skip_serializing_if = "Option::is_none")]
        #[doc = "Offset in the line to set breakpoint at."]
        pub column_number: Option<i32>,
        #[serde(rename = "condition", skip_serializing_if = "Option::is_none")]
        #[doc = "Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true."]
        pub condition: Option<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::traits::SerializeCdpCommand for SetBreakpointByUrlCommand<'a> {
        fn command_name(&self) -> &str {
            "Debugger.setBreakpointByUrl"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for SetBreakpointByUrlCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.setBreakpointByUrl" {
                Ok ( < SetBreakpointByUrlCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.\n\n# Command `Debugger.setBreakpointByUrl`\n\n*Domain Module:* [`cdp::proto::debugger`](index.html)  \n*Command Struct:* [`cdp::proto::debugger::SetBreakpointByUrlCommand`](struct.SetBreakpointByUrlCommand.html)  \n*Response Struct:* [`cdp::proto::debugger::SetBreakpointByUrlResponse`](struct.SetBreakpointByUrlResponse.html)"]
    pub struct SetBreakpointByUrlResponse<'a> {
        #[serde(rename = "breakpointId")]
        #[doc = "Id of the created breakpoint for further reference."]
        pub breakpoint_id: ::proto::debugger::BreakpointId<'a>,
        #[serde(rename = "locations")]
        #[doc = "List of the locations this breakpoint resolved into upon addition."]
        pub locations: Vec<::proto::debugger::Location<'a>>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetBreakpointByUrlCommand<'a> {
        type Response = SetBreakpointByUrlResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetBreakpointByUrlResponse<'a> {
        type Command = SetBreakpointByUrlCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Sets JavaScript breakpoint at a given location.\n\n# Command `Debugger.setBreakpoint`\n\n*Domain Module:* [`cdp::proto::debugger`](index.html)  \n*Command Struct:* [`cdp::proto::debugger::SetBreakpointCommand`](struct.SetBreakpointCommand.html)  \n*Response Struct:* [`cdp::proto::debugger::SetBreakpointResponse`](struct.SetBreakpointResponse.html)"]
    pub struct SetBreakpointCommand<'a> {
        #[serde(rename = "location")]
        #[doc = "Location to set breakpoint in."]
        pub location: ::proto::debugger::Location<'a>,
        #[serde(rename = "condition", skip_serializing_if = "Option::is_none")]
        #[doc = "Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true."]
        pub condition: Option<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::traits::SerializeCdpCommand for SetBreakpointCommand<'a> {
        fn command_name(&self) -> &str {
            "Debugger.setBreakpoint"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for SetBreakpointCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.setBreakpoint" {
                Ok(
                    <SetBreakpointCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Sets JavaScript breakpoint at a given location.\n\n# Command `Debugger.setBreakpoint`\n\n*Domain Module:* [`cdp::proto::debugger`](index.html)  \n*Command Struct:* [`cdp::proto::debugger::SetBreakpointCommand`](struct.SetBreakpointCommand.html)  \n*Response Struct:* [`cdp::proto::debugger::SetBreakpointResponse`](struct.SetBreakpointResponse.html)"]
    pub struct SetBreakpointResponse<'a> {
        #[serde(rename = "breakpointId")]
        #[doc = "Id of the created breakpoint for further reference."]
        pub breakpoint_id: ::proto::debugger::BreakpointId<'a>,
        #[serde(rename = "actualLocation")]
        #[doc = "Location this breakpoint resolved into."]
        pub actual_location: ::proto::debugger::Location<'a>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetBreakpointCommand<'a> {
        type Response = SetBreakpointResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetBreakpointResponse<'a> {
        type Command = SetBreakpointCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Removes JavaScript breakpoint.\n\n# Command `Debugger.removeBreakpoint`\n\n*Domain Module:* [`cdp::proto::debugger`](index.html)  \n*Command Struct:* [`cdp::proto::debugger::RemoveBreakpointCommand`](struct.RemoveBreakpointCommand.html)  \n*Response Struct:* [`cdp::proto::debugger::RemoveBreakpointResponse`](struct.RemoveBreakpointResponse.html)"]
    pub struct RemoveBreakpointCommand<'a> {
        #[serde(rename = "breakpointId")]
        pub breakpoint_id: ::proto::debugger::BreakpointId<'a>,
    }
    impl<'a> ::traits::SerializeCdpCommand for RemoveBreakpointCommand<'a> {
        fn command_name(&self) -> &str {
            "Debugger.removeBreakpoint"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for RemoveBreakpointCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.removeBreakpoint" {
                Ok ( < RemoveBreakpointCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Removes JavaScript breakpoint.\n\n# Command `Debugger.removeBreakpoint`\n\n*Domain Module:* [`cdp::proto::debugger`](index.html)  \n*Command Struct:* [`cdp::proto::debugger::RemoveBreakpointCommand`](struct.RemoveBreakpointCommand.html)  \n*Response Struct:* [`cdp::proto::debugger::RemoveBreakpointResponse`](struct.RemoveBreakpointResponse.html)"]
    pub struct RemoveBreakpointResponse;
    impl ::serde::Serialize for RemoveBreakpointResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for RemoveBreakpointResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| RemoveBreakpointResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for RemoveBreakpointCommand<'a> {
        type Response = RemoveBreakpointResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for RemoveBreakpointResponse {
        type Command = RemoveBreakpointCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.\n\n# Command `Debugger.getPossibleBreakpoints`\n\n*Domain Module:* [`cdp::proto::debugger`](index.html)  \n*Command Struct:* [`cdp::proto::debugger::GetPossibleBreakpointsCommand`](struct.GetPossibleBreakpointsCommand.html)  \n*Response Struct:* [`cdp::proto::debugger::GetPossibleBreakpointsResponse`](struct.GetPossibleBreakpointsResponse.html)"]
    pub struct GetPossibleBreakpointsCommand<'a> {
        #[serde(rename = "start")]
        #[doc = "Start of range to search possible breakpoint locations in."]
        pub start: ::proto::debugger::Location<'a>,
        #[serde(rename = "end", skip_serializing_if = "Option::is_none")]
        #[doc = "End of range to search possible breakpoint locations in \\(excluding\\). When not specified, end of scripts is used as end of range."]
        pub end: Option<::proto::debugger::Location<'a>>,
        #[serde(rename = "restrictToFunction", skip_serializing_if = "Option::is_none")]
        #[doc = "Only consider locations which are in the same \\(non-nested\\) function as start."]
        pub restrict_to_function: Option<bool>,
    }
    impl<'a> ::traits::SerializeCdpCommand for GetPossibleBreakpointsCommand<'a> {
        fn command_name(&self) -> &str {
            "Debugger.getPossibleBreakpoints"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for GetPossibleBreakpointsCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.getPossibleBreakpoints" {
                Ok ( < GetPossibleBreakpointsCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.\n\n# Command `Debugger.getPossibleBreakpoints`\n\n*Domain Module:* [`cdp::proto::debugger`](index.html)  \n*Command Struct:* [`cdp::proto::debugger::GetPossibleBreakpointsCommand`](struct.GetPossibleBreakpointsCommand.html)  \n*Response Struct:* [`cdp::proto::debugger::GetPossibleBreakpointsResponse`](struct.GetPossibleBreakpointsResponse.html)"]
    pub struct GetPossibleBreakpointsResponse<'a> {
        #[serde(rename = "locations")]
        #[doc = "List of the possible breakpoint locations."]
        pub locations: Vec<::proto::debugger::BreakLocation<'a>>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for GetPossibleBreakpointsCommand<'a> {
        type Response = GetPossibleBreakpointsResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for GetPossibleBreakpointsResponse<'a> {
        type Command = GetPossibleBreakpointsCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "Used in the type of [`cdp::proto::debugger::ContinueToLocationCommand::target_call_frames`](struct.ContinueToLocationCommand.html#structfield.target_call_frames)."]
    pub enum ContinueToLocationCommandTargetCallFrames {
        #[serde(rename = "any")]
        #[doc = "Represented as `\"any\"`."]
        Any,
        #[serde(rename = "current")]
        #[doc = "Represented as `\"current\"`."]
        Current,
    }
    impl ContinueToLocationCommandTargetCallFrames {
        pub const ENUM_VALUES: &'static [ContinueToLocationCommandTargetCallFrames] =
            &[
                ContinueToLocationCommandTargetCallFrames::Any,
                ContinueToLocationCommandTargetCallFrames::Current,
            ];
        pub const STR_VALUES: &'static [&'static str] = &["any", "current"];
    }
    impl ::std::str::FromStr for ContinueToLocationCommandTargetCallFrames {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "any" => Ok(ContinueToLocationCommandTargetCallFrames::Any),
                "current" => Ok(ContinueToLocationCommandTargetCallFrames::Current),
                _ => Err(::proto::ParseEnumError {
                    expected: ContinueToLocationCommandTargetCallFrames::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for ContinueToLocationCommandTargetCallFrames {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    ContinueToLocationCommandTargetCallFrames::Any => "any",
                    ContinueToLocationCommandTargetCallFrames::Current => "current",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Continues execution until specific location is reached.\n\n# Command `Debugger.continueToLocation`\n\n*Domain Module:* [`cdp::proto::debugger`](index.html)  \n*Command Struct:* [`cdp::proto::debugger::ContinueToLocationCommand`](struct.ContinueToLocationCommand.html)  \n*Response Struct:* [`cdp::proto::debugger::ContinueToLocationResponse`](struct.ContinueToLocationResponse.html)"]
    pub struct ContinueToLocationCommand<'a> {
        #[serde(rename = "location")]
        #[doc = "Location to continue to."]
        pub location: ::proto::debugger::Location<'a>,
        #[serde(rename = "targetCallFrames", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span>"]
        pub target_call_frames:
            Option<::proto::debugger::ContinueToLocationCommandTargetCallFrames>,
    }
    impl<'a> ::traits::SerializeCdpCommand for ContinueToLocationCommand<'a> {
        fn command_name(&self) -> &str {
            "Debugger.continueToLocation"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for ContinueToLocationCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.continueToLocation" {
                Ok ( < ContinueToLocationCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Continues execution until specific location is reached.\n\n# Command `Debugger.continueToLocation`\n\n*Domain Module:* [`cdp::proto::debugger`](index.html)  \n*Command Struct:* [`cdp::proto::debugger::ContinueToLocationCommand`](struct.ContinueToLocationCommand.html)  \n*Response Struct:* [`cdp::proto::debugger::ContinueToLocationResponse`](struct.ContinueToLocationResponse.html)"]
    pub struct ContinueToLocationResponse;
    impl ::serde::Serialize for ContinueToLocationResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ContinueToLocationResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ContinueToLocationResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for ContinueToLocationCommand<'a> {
        type Response = ContinueToLocationResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for ContinueToLocationResponse {
        type Command = ContinueToLocationCommand<'a>;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Steps over the statement.\n\n# Command `Debugger.stepOver`\n\n*Domain Module:* [`cdp::proto::debugger`](index.html)  \n*Command Struct:* [`cdp::proto::debugger::StepOverCommand`](struct.StepOverCommand.html)  \n*Response Struct:* [`cdp::proto::debugger::StepOverResponse`](struct.StepOverResponse.html)"]
    pub struct StepOverCommand;
    impl ::serde::Serialize for StepOverCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StepOverCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StepOverCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for StepOverCommand {
        fn command_name(&self) -> &str {
            "Debugger.stepOver"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for StepOverCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.stepOver" {
                Ok(
                    <StepOverCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Steps over the statement.\n\n# Command `Debugger.stepOver`\n\n*Domain Module:* [`cdp::proto::debugger`](index.html)  \n*Command Struct:* [`cdp::proto::debugger::StepOverCommand`](struct.StepOverCommand.html)  \n*Response Struct:* [`cdp::proto::debugger::StepOverResponse`](struct.StepOverResponse.html)"]
    pub struct StepOverResponse;
    impl ::serde::Serialize for StepOverResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StepOverResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StepOverResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for StepOverCommand {
        type Response = StepOverResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for StepOverResponse {
        type Command = StepOverCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Steps into the function call.\n\n# Command `Debugger.stepInto`\n\n*Domain Module:* [`cdp::proto::debugger`](index.html)  \n*Command Struct:* [`cdp::proto::debugger::StepIntoCommand`](struct.StepIntoCommand.html)  \n*Response Struct:* [`cdp::proto::debugger::StepIntoResponse`](struct.StepIntoResponse.html)"]
    pub struct StepIntoCommand;
    impl ::serde::Serialize for StepIntoCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StepIntoCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StepIntoCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for StepIntoCommand {
        fn command_name(&self) -> &str {
            "Debugger.stepInto"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for StepIntoCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.stepInto" {
                Ok(
                    <StepIntoCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Steps into the function call.\n\n# Command `Debugger.stepInto`\n\n*Domain Module:* [`cdp::proto::debugger`](index.html)  \n*Command Struct:* [`cdp::proto::debugger::StepIntoCommand`](struct.StepIntoCommand.html)  \n*Response Struct:* [`cdp::proto::debugger::StepIntoResponse`](struct.StepIntoResponse.html)"]
    pub struct StepIntoResponse;
    impl ::serde::Serialize for StepIntoResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StepIntoResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StepIntoResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for StepIntoCommand {
        type Response = StepIntoResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for StepIntoResponse {
        type Command = StepIntoCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Steps out of the function call.\n\n# Command `Debugger.stepOut`\n\n*Domain Module:* [`cdp::proto::debugger`](index.html)  \n*Command Struct:* [`cdp::proto::debugger::StepOutCommand`](struct.StepOutCommand.html)  \n*Response Struct:* [`cdp::proto::debugger::StepOutResponse`](struct.StepOutResponse.html)"]
    pub struct StepOutCommand;
    impl ::serde::Serialize for StepOutCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StepOutCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StepOutCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for StepOutCommand {
        fn command_name(&self) -> &str {
            "Debugger.stepOut"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for StepOutCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.stepOut" {
                Ok(
                    <StepOutCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Steps out of the function call.\n\n# Command `Debugger.stepOut`\n\n*Domain Module:* [`cdp::proto::debugger`](index.html)  \n*Command Struct:* [`cdp::proto::debugger::StepOutCommand`](struct.StepOutCommand.html)  \n*Response Struct:* [`cdp::proto::debugger::StepOutResponse`](struct.StepOutResponse.html)"]
    pub struct StepOutResponse;
    impl ::serde::Serialize for StepOutResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StepOutResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StepOutResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for StepOutCommand {
        type Response = StepOutResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for StepOutResponse {
        type Command = StepOutCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Stops on the next JavaScript statement.\n\n# Command `Debugger.pause`\n\n*Domain Module:* [`cdp::proto::debugger`](index.html)  \n*Command Struct:* [`cdp::proto::debugger::PauseCommand`](struct.PauseCommand.html)  \n*Response Struct:* [`cdp::proto::debugger::PauseResponse`](struct.PauseResponse.html)"]
    pub struct PauseCommand;
    impl ::serde::Serialize for PauseCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PauseCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| PauseCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for PauseCommand {
        fn command_name(&self) -> &str {
            "Debugger.pause"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for PauseCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.pause" {
                Ok(
                    <PauseCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Stops on the next JavaScript statement.\n\n# Command `Debugger.pause`\n\n*Domain Module:* [`cdp::proto::debugger`](index.html)  \n*Command Struct:* [`cdp::proto::debugger::PauseCommand`](struct.PauseCommand.html)  \n*Response Struct:* [`cdp::proto::debugger::PauseResponse`](struct.PauseResponse.html)"]
    pub struct PauseResponse;
    impl ::serde::Serialize for PauseResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PauseResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| PauseResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for PauseCommand {
        type Response = PauseResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for PauseResponse {
        type Command = PauseCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.\n\n# Command `Debugger.scheduleStepIntoAsync`\n\n*Domain Module:* [`cdp::proto::debugger`](index.html)  \n*Command Struct:* [`cdp::proto::debugger::ScheduleStepIntoAsyncCommand`](struct.ScheduleStepIntoAsyncCommand.html)  \n*Response Struct:* [`cdp::proto::debugger::ScheduleStepIntoAsyncResponse`](struct.ScheduleStepIntoAsyncResponse.html)"]
    pub struct ScheduleStepIntoAsyncCommand;
    impl ::serde::Serialize for ScheduleStepIntoAsyncCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ScheduleStepIntoAsyncCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ScheduleStepIntoAsyncCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for ScheduleStepIntoAsyncCommand {
        fn command_name(&self) -> &str {
            "Debugger.scheduleStepIntoAsync"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for ScheduleStepIntoAsyncCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.scheduleStepIntoAsync" {
                Ok ( < ScheduleStepIntoAsyncCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.\n\n# Command `Debugger.scheduleStepIntoAsync`\n\n*Domain Module:* [`cdp::proto::debugger`](index.html)  \n*Command Struct:* [`cdp::proto::debugger::ScheduleStepIntoAsyncCommand`](struct.ScheduleStepIntoAsyncCommand.html)  \n*Response Struct:* [`cdp::proto::debugger::ScheduleStepIntoAsyncResponse`](struct.ScheduleStepIntoAsyncResponse.html)"]
    pub struct ScheduleStepIntoAsyncResponse;
    impl ::serde::Serialize for ScheduleStepIntoAsyncResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ScheduleStepIntoAsyncResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ScheduleStepIntoAsyncResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for ScheduleStepIntoAsyncCommand {
        type Response = ScheduleStepIntoAsyncResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for ScheduleStepIntoAsyncResponse {
        type Command = ScheduleStepIntoAsyncCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Resumes JavaScript execution.\n\n# Command `Debugger.resume`\n\n*Domain Module:* [`cdp::proto::debugger`](index.html)  \n*Command Struct:* [`cdp::proto::debugger::ResumeCommand`](struct.ResumeCommand.html)  \n*Response Struct:* [`cdp::proto::debugger::ResumeResponse`](struct.ResumeResponse.html)"]
    pub struct ResumeCommand;
    impl ::serde::Serialize for ResumeCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ResumeCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ResumeCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for ResumeCommand {
        fn command_name(&self) -> &str {
            "Debugger.resume"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for ResumeCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.resume" {
                Ok(
                    <ResumeCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Resumes JavaScript execution.\n\n# Command `Debugger.resume`\n\n*Domain Module:* [`cdp::proto::debugger`](index.html)  \n*Command Struct:* [`cdp::proto::debugger::ResumeCommand`](struct.ResumeCommand.html)  \n*Response Struct:* [`cdp::proto::debugger::ResumeResponse`](struct.ResumeResponse.html)"]
    pub struct ResumeResponse;
    impl ::serde::Serialize for ResumeResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ResumeResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ResumeResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for ResumeCommand {
        type Response = ResumeResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for ResumeResponse {
        type Command = ResumeCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Searches for given string in script content.\n\n# Command `Debugger.searchInContent`\n\n*Domain Module:* [`cdp::proto::debugger`](index.html)  \n*Command Struct:* [`cdp::proto::debugger::SearchInContentCommand`](struct.SearchInContentCommand.html)  \n*Response Struct:* [`cdp::proto::debugger::SearchInContentResponse`](struct.SearchInContentResponse.html)"]
    pub struct SearchInContentCommand<'a> {
        #[serde(rename = "scriptId")]
        #[doc = "Id of the script to search in."]
        pub script_id: ::proto::runtime::ScriptId<'a>,
        #[serde(rename = "query")]
        #[doc = "String to search for."]
        pub query: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "caseSensitive", skip_serializing_if = "Option::is_none")]
        #[doc = "If true, search is case sensitive."]
        pub case_sensitive: Option<bool>,
        #[serde(rename = "isRegex", skip_serializing_if = "Option::is_none")]
        #[doc = "If true, treats string parameter as regex."]
        pub is_regex: Option<bool>,
    }
    impl<'a> ::traits::SerializeCdpCommand for SearchInContentCommand<'a> {
        fn command_name(&self) -> &str {
            "Debugger.searchInContent"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for SearchInContentCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.searchInContent" {
                Ok(
                    <SearchInContentCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Searches for given string in script content.\n\n# Command `Debugger.searchInContent`\n\n*Domain Module:* [`cdp::proto::debugger`](index.html)  \n*Command Struct:* [`cdp::proto::debugger::SearchInContentCommand`](struct.SearchInContentCommand.html)  \n*Response Struct:* [`cdp::proto::debugger::SearchInContentResponse`](struct.SearchInContentResponse.html)"]
    pub struct SearchInContentResponse<'a> {
        #[serde(rename = "result")]
        #[doc = "List of search matches."]
        pub result: Vec<::proto::debugger::SearchMatch<'a>>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SearchInContentCommand<'a> {
        type Response = SearchInContentResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SearchInContentResponse<'a> {
        type Command = SearchInContentCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Edits JavaScript source live.\n\n# Command `Debugger.setScriptSource`\n\n*Domain Module:* [`cdp::proto::debugger`](index.html)  \n*Command Struct:* [`cdp::proto::debugger::SetScriptSourceCommand`](struct.SetScriptSourceCommand.html)  \n*Response Struct:* [`cdp::proto::debugger::SetScriptSourceResponse`](struct.SetScriptSourceResponse.html)"]
    pub struct SetScriptSourceCommand<'a> {
        #[serde(rename = "scriptId")]
        #[doc = "Id of the script to edit."]
        pub script_id: ::proto::runtime::ScriptId<'a>,
        #[serde(rename = "scriptSource")]
        #[doc = "New content of the script."]
        pub script_source: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "dryRun", skip_serializing_if = "Option::is_none")]
        #[doc = " If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code."]
        pub dry_run: Option<bool>,
    }
    impl<'a> ::traits::SerializeCdpCommand for SetScriptSourceCommand<'a> {
        fn command_name(&self) -> &str {
            "Debugger.setScriptSource"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for SetScriptSourceCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.setScriptSource" {
                Ok(
                    <SetScriptSourceCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Edits JavaScript source live.\n\n# Command `Debugger.setScriptSource`\n\n*Domain Module:* [`cdp::proto::debugger`](index.html)  \n*Command Struct:* [`cdp::proto::debugger::SetScriptSourceCommand`](struct.SetScriptSourceCommand.html)  \n*Response Struct:* [`cdp::proto::debugger::SetScriptSourceResponse`](struct.SetScriptSourceResponse.html)"]
    pub struct SetScriptSourceResponse<'a> {
        #[serde(rename = "callFrames", skip_serializing_if = "Option::is_none")]
        #[doc = "New stack trace in case editing has happened while VM was stopped."]
        pub call_frames: Option<Vec<::proto::debugger::CallFrame<'a>>>,
        #[serde(rename = "stackChanged", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether current call stack  was modified after applying the changes."]
        pub stack_changed: Option<bool>,
        #[serde(rename = "asyncStackTrace", skip_serializing_if = "Option::is_none")]
        #[doc = "Async stack trace, if any."]
        pub async_stack_trace: Option<::proto::runtime::StackTrace<'a>>,
        #[serde(rename = "exceptionDetails", skip_serializing_if = "Option::is_none")]
        #[doc = "Exception details if any."]
        pub exception_details: Option<::proto::runtime::ExceptionDetails<'a>>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetScriptSourceCommand<'a> {
        type Response = SetScriptSourceResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetScriptSourceResponse<'a> {
        type Command = SetScriptSourceCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Restarts particular call frame from the beginning.\n\n# Command `Debugger.restartFrame`\n\n*Domain Module:* [`cdp::proto::debugger`](index.html)  \n*Command Struct:* [`cdp::proto::debugger::RestartFrameCommand`](struct.RestartFrameCommand.html)  \n*Response Struct:* [`cdp::proto::debugger::RestartFrameResponse`](struct.RestartFrameResponse.html)"]
    pub struct RestartFrameCommand<'a> {
        #[serde(rename = "callFrameId")]
        #[doc = "Call frame identifier to evaluate on."]
        pub call_frame_id: ::proto::debugger::CallFrameId<'a>,
    }
    impl<'a> ::traits::SerializeCdpCommand for RestartFrameCommand<'a> {
        fn command_name(&self) -> &str {
            "Debugger.restartFrame"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for RestartFrameCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.restartFrame" {
                Ok(
                    <RestartFrameCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Restarts particular call frame from the beginning.\n\n# Command `Debugger.restartFrame`\n\n*Domain Module:* [`cdp::proto::debugger`](index.html)  \n*Command Struct:* [`cdp::proto::debugger::RestartFrameCommand`](struct.RestartFrameCommand.html)  \n*Response Struct:* [`cdp::proto::debugger::RestartFrameResponse`](struct.RestartFrameResponse.html)"]
    pub struct RestartFrameResponse<'a> {
        #[serde(rename = "callFrames")]
        #[doc = "New stack trace."]
        pub call_frames: Vec<::proto::debugger::CallFrame<'a>>,
        #[serde(rename = "asyncStackTrace", skip_serializing_if = "Option::is_none")]
        #[doc = "Async stack trace, if any."]
        pub async_stack_trace: Option<::proto::runtime::StackTrace<'a>>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for RestartFrameCommand<'a> {
        type Response = RestartFrameResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for RestartFrameResponse<'a> {
        type Command = RestartFrameCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Returns source for the script with given id.\n\n# Command `Debugger.getScriptSource`\n\n*Domain Module:* [`cdp::proto::debugger`](index.html)  \n*Command Struct:* [`cdp::proto::debugger::GetScriptSourceCommand`](struct.GetScriptSourceCommand.html)  \n*Response Struct:* [`cdp::proto::debugger::GetScriptSourceResponse`](struct.GetScriptSourceResponse.html)"]
    pub struct GetScriptSourceCommand<'a> {
        #[serde(rename = "scriptId")]
        #[doc = "Id of the script to get source for."]
        pub script_id: ::proto::runtime::ScriptId<'a>,
    }
    impl<'a> ::traits::SerializeCdpCommand for GetScriptSourceCommand<'a> {
        fn command_name(&self) -> &str {
            "Debugger.getScriptSource"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for GetScriptSourceCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.getScriptSource" {
                Ok(
                    <GetScriptSourceCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Returns source for the script with given id.\n\n# Command `Debugger.getScriptSource`\n\n*Domain Module:* [`cdp::proto::debugger`](index.html)  \n*Command Struct:* [`cdp::proto::debugger::GetScriptSourceCommand`](struct.GetScriptSourceCommand.html)  \n*Response Struct:* [`cdp::proto::debugger::GetScriptSourceResponse`](struct.GetScriptSourceResponse.html)"]
    pub struct GetScriptSourceResponse<'a> {
        #[serde(rename = "scriptSource")]
        #[doc = "Script source."]
        pub script_source: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for GetScriptSourceCommand<'a> {
        type Response = GetScriptSourceResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for GetScriptSourceResponse<'a> {
        type Command = GetScriptSourceCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "Used in the type of [`cdp::proto::debugger::SetPauseOnExceptionsCommand::state`](struct.SetPauseOnExceptionsCommand.html#structfield.state)."]
    pub enum SetPauseOnExceptionsCommandState {
        #[serde(rename = "none")]
        #[doc = "Represented as `\"none\"`."]
        None,
        #[serde(rename = "uncaught")]
        #[doc = "Represented as `\"uncaught\"`."]
        Uncaught,
        #[serde(rename = "all")]
        #[doc = "Represented as `\"all\"`."]
        All,
    }
    impl SetPauseOnExceptionsCommandState {
        pub const ENUM_VALUES: &'static [SetPauseOnExceptionsCommandState] =
            &[
                SetPauseOnExceptionsCommandState::None,
                SetPauseOnExceptionsCommandState::Uncaught,
                SetPauseOnExceptionsCommandState::All,
            ];
        pub const STR_VALUES: &'static [&'static str] = &["none", "uncaught", "all"];
    }
    impl ::std::str::FromStr for SetPauseOnExceptionsCommandState {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "none" => Ok(SetPauseOnExceptionsCommandState::None),
                "uncaught" => Ok(SetPauseOnExceptionsCommandState::Uncaught),
                "all" => Ok(SetPauseOnExceptionsCommandState::All),
                _ => Err(::proto::ParseEnumError {
                    expected: SetPauseOnExceptionsCommandState::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for SetPauseOnExceptionsCommandState {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    SetPauseOnExceptionsCommandState::None => "none",
                    SetPauseOnExceptionsCommandState::Uncaught => "uncaught",
                    SetPauseOnExceptionsCommandState::All => "all",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.\n\n# Command `Debugger.setPauseOnExceptions`\n\n*Domain Module:* [`cdp::proto::debugger`](index.html)  \n*Command Struct:* [`cdp::proto::debugger::SetPauseOnExceptionsCommand`](struct.SetPauseOnExceptionsCommand.html)  \n*Response Struct:* [`cdp::proto::debugger::SetPauseOnExceptionsResponse`](struct.SetPauseOnExceptionsResponse.html)"]
    pub struct SetPauseOnExceptionsCommand {
        #[serde(rename = "state")]
        #[doc = "Pause on exceptions mode."]
        pub state: ::proto::debugger::SetPauseOnExceptionsCommandState,
    }
    impl ::traits::SerializeCdpCommand for SetPauseOnExceptionsCommand {
        fn command_name(&self) -> &str {
            "Debugger.setPauseOnExceptions"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for SetPauseOnExceptionsCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.setPauseOnExceptions" {
                Ok ( < SetPauseOnExceptionsCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.\n\n# Command `Debugger.setPauseOnExceptions`\n\n*Domain Module:* [`cdp::proto::debugger`](index.html)  \n*Command Struct:* [`cdp::proto::debugger::SetPauseOnExceptionsCommand`](struct.SetPauseOnExceptionsCommand.html)  \n*Response Struct:* [`cdp::proto::debugger::SetPauseOnExceptionsResponse`](struct.SetPauseOnExceptionsResponse.html)"]
    pub struct SetPauseOnExceptionsResponse;
    impl ::serde::Serialize for SetPauseOnExceptionsResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetPauseOnExceptionsResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetPauseOnExceptionsResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetPauseOnExceptionsCommand {
        type Response = SetPauseOnExceptionsResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetPauseOnExceptionsResponse {
        type Command = SetPauseOnExceptionsCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Evaluates expression on a given call frame.\n\n# Command `Debugger.evaluateOnCallFrame`\n\n*Domain Module:* [`cdp::proto::debugger`](index.html)  \n*Command Struct:* [`cdp::proto::debugger::EvaluateOnCallFrameCommand`](struct.EvaluateOnCallFrameCommand.html)  \n*Response Struct:* [`cdp::proto::debugger::EvaluateOnCallFrameResponse`](struct.EvaluateOnCallFrameResponse.html)"]
    pub struct EvaluateOnCallFrameCommand<'a> {
        #[serde(rename = "callFrameId")]
        #[doc = "Call frame identifier to evaluate on."]
        pub call_frame_id: ::proto::debugger::CallFrameId<'a>,
        #[serde(rename = "expression")]
        #[doc = "Expression to evaluate."]
        pub expression: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "objectGroup", skip_serializing_if = "Option::is_none")]
        #[doc = "String object group name to put result into \\(allows rapid releasing resulting object handles using <code>releaseObjectGroup</code>\\)."]
        pub object_group: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "includeCommandLineAPI", skip_serializing_if = "Option::is_none")]
        #[doc = "Specifies whether command line API should be available to the evaluated expression, defaults to false."]
        pub include_command_line_api: Option<bool>,
        #[serde(rename = "silent", skip_serializing_if = "Option::is_none")]
        #[doc = "In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides <code>setPauseOnException</code> state."]
        pub silent: Option<bool>,
        #[serde(rename = "returnByValue", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether the result is expected to be a JSON object that should be sent by value."]
        pub return_by_value: Option<bool>,
        #[serde(rename = "generatePreview", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Whether preview should be generated for the result."]
        pub generate_preview: Option<bool>,
        #[serde(rename = "throwOnSideEffect", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Whether to throw an exception if side effect cannot be ruled out during evaluation."]
        pub throw_on_side_effect: Option<bool>,
    }
    impl<'a> ::traits::SerializeCdpCommand for EvaluateOnCallFrameCommand<'a> {
        fn command_name(&self) -> &str {
            "Debugger.evaluateOnCallFrame"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for EvaluateOnCallFrameCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.evaluateOnCallFrame" {
                Ok ( < EvaluateOnCallFrameCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Evaluates expression on a given call frame.\n\n# Command `Debugger.evaluateOnCallFrame`\n\n*Domain Module:* [`cdp::proto::debugger`](index.html)  \n*Command Struct:* [`cdp::proto::debugger::EvaluateOnCallFrameCommand`](struct.EvaluateOnCallFrameCommand.html)  \n*Response Struct:* [`cdp::proto::debugger::EvaluateOnCallFrameResponse`](struct.EvaluateOnCallFrameResponse.html)"]
    pub struct EvaluateOnCallFrameResponse<'a> {
        #[serde(rename = "result")]
        #[doc = "Object wrapper for the evaluation result."]
        pub result: ::proto::runtime::RemoteObject<'a>,
        #[serde(rename = "exceptionDetails", skip_serializing_if = "Option::is_none")]
        #[doc = "Exception details."]
        pub exception_details: Option<::proto::runtime::ExceptionDetails<'a>>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for EvaluateOnCallFrameCommand<'a> {
        type Response = EvaluateOnCallFrameResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for EvaluateOnCallFrameResponse<'a> {
        type Command = EvaluateOnCallFrameCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.\n\n# Command `Debugger.setVariableValue`\n\n*Domain Module:* [`cdp::proto::debugger`](index.html)  \n*Command Struct:* [`cdp::proto::debugger::SetVariableValueCommand`](struct.SetVariableValueCommand.html)  \n*Response Struct:* [`cdp::proto::debugger::SetVariableValueResponse`](struct.SetVariableValueResponse.html)"]
    pub struct SetVariableValueCommand<'a> {
        #[serde(rename = "scopeNumber")]
        #[doc = "0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch' scope types are allowed. Other scopes could be manipulated manually."]
        pub scope_number: i32,
        #[serde(rename = "variableName")]
        #[doc = "Variable name."]
        pub variable_name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "newValue")]
        #[doc = "New variable value."]
        pub new_value: ::proto::runtime::CallArgument<'a>,
        #[serde(rename = "callFrameId")]
        #[doc = "Id of callframe that holds variable."]
        pub call_frame_id: ::proto::debugger::CallFrameId<'a>,
    }
    impl<'a> ::traits::SerializeCdpCommand for SetVariableValueCommand<'a> {
        fn command_name(&self) -> &str {
            "Debugger.setVariableValue"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for SetVariableValueCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.setVariableValue" {
                Ok ( < SetVariableValueCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.\n\n# Command `Debugger.setVariableValue`\n\n*Domain Module:* [`cdp::proto::debugger`](index.html)  \n*Command Struct:* [`cdp::proto::debugger::SetVariableValueCommand`](struct.SetVariableValueCommand.html)  \n*Response Struct:* [`cdp::proto::debugger::SetVariableValueResponse`](struct.SetVariableValueResponse.html)"]
    pub struct SetVariableValueResponse;
    impl ::serde::Serialize for SetVariableValueResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetVariableValueResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetVariableValueResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetVariableValueCommand<'a> {
        type Response = SetVariableValueResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetVariableValueResponse {
        type Command = SetVariableValueCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Enables or disables async call stacks tracking.\n\n# Command `Debugger.setAsyncCallStackDepth`\n\n*Domain Module:* [`cdp::proto::debugger`](index.html)  \n*Command Struct:* [`cdp::proto::debugger::SetAsyncCallStackDepthCommand`](struct.SetAsyncCallStackDepthCommand.html)  \n*Response Struct:* [`cdp::proto::debugger::SetAsyncCallStackDepthResponse`](struct.SetAsyncCallStackDepthResponse.html)"]
    pub struct SetAsyncCallStackDepthCommand {
        #[serde(rename = "maxDepth")]
        #[doc = "Maximum depth of async call stacks. Setting to <code>0</code> will effectively disable collecting async call stacks \\(default\\)."]
        pub max_depth: i32,
    }
    impl ::traits::SerializeCdpCommand for SetAsyncCallStackDepthCommand {
        fn command_name(&self) -> &str {
            "Debugger.setAsyncCallStackDepth"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for SetAsyncCallStackDepthCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.setAsyncCallStackDepth" {
                Ok ( < SetAsyncCallStackDepthCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Enables or disables async call stacks tracking.\n\n# Command `Debugger.setAsyncCallStackDepth`\n\n*Domain Module:* [`cdp::proto::debugger`](index.html)  \n*Command Struct:* [`cdp::proto::debugger::SetAsyncCallStackDepthCommand`](struct.SetAsyncCallStackDepthCommand.html)  \n*Response Struct:* [`cdp::proto::debugger::SetAsyncCallStackDepthResponse`](struct.SetAsyncCallStackDepthResponse.html)"]
    pub struct SetAsyncCallStackDepthResponse;
    impl ::serde::Serialize for SetAsyncCallStackDepthResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetAsyncCallStackDepthResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetAsyncCallStackDepthResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetAsyncCallStackDepthCommand {
        type Response = SetAsyncCallStackDepthResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetAsyncCallStackDepthResponse {
        type Command = SetAsyncCallStackDepthCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.\n\n# Command `Debugger.setBlackboxPatterns`\n\n*Domain Module:* [`cdp::proto::debugger`](index.html)  \n*Command Struct:* [`cdp::proto::debugger::SetBlackboxPatternsCommand`](struct.SetBlackboxPatternsCommand.html)  \n*Response Struct:* [`cdp::proto::debugger::SetBlackboxPatternsResponse`](struct.SetBlackboxPatternsResponse.html)"]
    pub struct SetBlackboxPatternsCommand<'a> {
        #[serde(rename = "patterns")]
        #[doc = "Array of regexps that will be used to check script url for blackbox state."]
        pub patterns: Vec<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::traits::SerializeCdpCommand for SetBlackboxPatternsCommand<'a> {
        fn command_name(&self) -> &str {
            "Debugger.setBlackboxPatterns"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for SetBlackboxPatternsCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.setBlackboxPatterns" {
                Ok ( < SetBlackboxPatternsCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.\n\n# Command `Debugger.setBlackboxPatterns`\n\n*Domain Module:* [`cdp::proto::debugger`](index.html)  \n*Command Struct:* [`cdp::proto::debugger::SetBlackboxPatternsCommand`](struct.SetBlackboxPatternsCommand.html)  \n*Response Struct:* [`cdp::proto::debugger::SetBlackboxPatternsResponse`](struct.SetBlackboxPatternsResponse.html)"]
    pub struct SetBlackboxPatternsResponse;
    impl ::serde::Serialize for SetBlackboxPatternsResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetBlackboxPatternsResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetBlackboxPatternsResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetBlackboxPatternsCommand<'a> {
        type Response = SetBlackboxPatternsResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetBlackboxPatternsResponse {
        type Command = SetBlackboxPatternsCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.\n\n# Command `Debugger.setBlackboxedRanges`\n\n*Domain Module:* [`cdp::proto::debugger`](index.html)  \n*Command Struct:* [`cdp::proto::debugger::SetBlackboxedRangesCommand`](struct.SetBlackboxedRangesCommand.html)  \n*Response Struct:* [`cdp::proto::debugger::SetBlackboxedRangesResponse`](struct.SetBlackboxedRangesResponse.html)"]
    pub struct SetBlackboxedRangesCommand<'a> {
        #[serde(rename = "scriptId")]
        #[doc = "Id of the script."]
        pub script_id: ::proto::runtime::ScriptId<'a>,
        #[serde(rename = "positions")]
        pub positions: Vec<::proto::debugger::ScriptPosition>,
    }
    impl<'a> ::traits::SerializeCdpCommand for SetBlackboxedRangesCommand<'a> {
        fn command_name(&self) -> &str {
            "Debugger.setBlackboxedRanges"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for SetBlackboxedRangesCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.setBlackboxedRanges" {
                Ok ( < SetBlackboxedRangesCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.\n\n# Command `Debugger.setBlackboxedRanges`\n\n*Domain Module:* [`cdp::proto::debugger`](index.html)  \n*Command Struct:* [`cdp::proto::debugger::SetBlackboxedRangesCommand`](struct.SetBlackboxedRangesCommand.html)  \n*Response Struct:* [`cdp::proto::debugger::SetBlackboxedRangesResponse`](struct.SetBlackboxedRangesResponse.html)"]
    pub struct SetBlackboxedRangesResponse;
    impl ::serde::Serialize for SetBlackboxedRangesResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetBlackboxedRangesResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetBlackboxedRangesResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetBlackboxedRangesCommand<'a> {
        type Response = SetBlackboxedRangesResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetBlackboxedRangesResponse {
        type Command = SetBlackboxedRangesCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.\n\n# Event `Debugger.scriptParsed`\n\n*Domain Module:* [`cdp::proto::debugger`](index.html)  \n*Event Struct:* [`cdp::proto::debugger::ScriptParsedEvent`](struct.ScriptParsedEvent.html)"]
    pub struct ScriptParsedEvent<'a> {
        #[serde(rename = "scriptId")]
        #[doc = "Identifier of the script parsed."]
        pub script_id: ::proto::runtime::ScriptId<'a>,
        #[serde(rename = "url")]
        #[doc = "URL or name of the script parsed \\(if any\\)."]
        pub url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "startLine")]
        #[doc = "Line offset of the script within the resource with given URL \\(for script tags\\)."]
        pub start_line: i32,
        #[serde(rename = "startColumn")]
        #[doc = "Column offset of the script within the resource with given URL."]
        pub start_column: i32,
        #[serde(rename = "endLine")]
        #[doc = "Last line of the script."]
        pub end_line: i32,
        #[serde(rename = "endColumn")]
        #[doc = "Length of the last line of the script."]
        pub end_column: i32,
        #[serde(rename = "executionContextId")]
        #[doc = "Specifies script creation context."]
        pub execution_context_id: ::proto::runtime::ExecutionContextId,
        #[serde(rename = "hash")]
        #[doc = "Content hash of the script."]
        pub hash: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "executionContextAuxData", skip_serializing_if = "Option::is_none")]
        #[doc = "Embedder-specific auxiliary data."]
        pub execution_context_aux_data: Option<::proto::Empty>,
        #[serde(rename = "isLiveEdit", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> True, if this script is generated as a result of the live edit operation."]
        pub is_live_edit: Option<bool>,
        #[serde(rename = "sourceMapURL", skip_serializing_if = "Option::is_none")]
        #[doc = "URL of source map associated with script \\(if any\\)."]
        pub source_map_url: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "hasSourceURL", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> True, if this script has sourceURL."]
        pub has_source_url: Option<bool>,
        #[serde(rename = "isModule", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> True, if this script is ES6 module."]
        pub is_module: Option<bool>,
        #[serde(rename = "length", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> This script length."]
        pub length: Option<i32>,
        #[serde(rename = "stackTrace", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> JavaScript top stack frame of where the script parsed event was triggered if available."]
        pub stack_trace: Option<::proto::runtime::StackTrace<'a>>,
    }
    impl<'a> ::traits::SerializeCdpEvent for ScriptParsedEvent<'a> {
        fn event_name(&self) -> &str {
            "Debugger.scriptParsed"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for ScriptParsedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.scriptParsed" {
                Ok(
                    <ScriptParsedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Fired when virtual machine fails to parse the script.\n\n# Event `Debugger.scriptFailedToParse`\n\n*Domain Module:* [`cdp::proto::debugger`](index.html)  \n*Event Struct:* [`cdp::proto::debugger::ScriptFailedToParseEvent`](struct.ScriptFailedToParseEvent.html)"]
    pub struct ScriptFailedToParseEvent<'a> {
        #[serde(rename = "scriptId")]
        #[doc = "Identifier of the script parsed."]
        pub script_id: ::proto::runtime::ScriptId<'a>,
        #[serde(rename = "url")]
        #[doc = "URL or name of the script parsed \\(if any\\)."]
        pub url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "startLine")]
        #[doc = "Line offset of the script within the resource with given URL \\(for script tags\\)."]
        pub start_line: i32,
        #[serde(rename = "startColumn")]
        #[doc = "Column offset of the script within the resource with given URL."]
        pub start_column: i32,
        #[serde(rename = "endLine")]
        #[doc = "Last line of the script."]
        pub end_line: i32,
        #[serde(rename = "endColumn")]
        #[doc = "Length of the last line of the script."]
        pub end_column: i32,
        #[serde(rename = "executionContextId")]
        #[doc = "Specifies script creation context."]
        pub execution_context_id: ::proto::runtime::ExecutionContextId,
        #[serde(rename = "hash")]
        #[doc = "Content hash of the script."]
        pub hash: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "executionContextAuxData", skip_serializing_if = "Option::is_none")]
        #[doc = "Embedder-specific auxiliary data."]
        pub execution_context_aux_data: Option<::proto::Empty>,
        #[serde(rename = "sourceMapURL", skip_serializing_if = "Option::is_none")]
        #[doc = "URL of source map associated with script \\(if any\\)."]
        pub source_map_url: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "hasSourceURL", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> True, if this script has sourceURL."]
        pub has_source_url: Option<bool>,
        #[serde(rename = "isModule", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> True, if this script is ES6 module."]
        pub is_module: Option<bool>,
        #[serde(rename = "length", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> This script length."]
        pub length: Option<i32>,
        #[serde(rename = "stackTrace", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> JavaScript top stack frame of where the script parsed event was triggered if available."]
        pub stack_trace: Option<::proto::runtime::StackTrace<'a>>,
    }
    impl<'a> ::traits::SerializeCdpEvent for ScriptFailedToParseEvent<'a> {
        fn event_name(&self) -> &str {
            "Debugger.scriptFailedToParse"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for ScriptFailedToParseEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.scriptFailedToParse" {
                Ok ( < ScriptFailedToParseEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Fired when breakpoint is resolved to an actual script and location.\n\n# Event `Debugger.breakpointResolved`\n\n*Domain Module:* [`cdp::proto::debugger`](index.html)  \n*Event Struct:* [`cdp::proto::debugger::BreakpointResolvedEvent`](struct.BreakpointResolvedEvent.html)"]
    pub struct BreakpointResolvedEvent<'a> {
        #[serde(rename = "breakpointId")]
        #[doc = "Breakpoint unique identifier."]
        pub breakpoint_id: ::proto::debugger::BreakpointId<'a>,
        #[serde(rename = "location")]
        #[doc = "Actual breakpoint location."]
        pub location: ::proto::debugger::Location<'a>,
    }
    impl<'a> ::traits::SerializeCdpEvent for BreakpointResolvedEvent<'a> {
        fn event_name(&self) -> &str {
            "Debugger.breakpointResolved"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for BreakpointResolvedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.breakpointResolved" {
                Ok ( < BreakpointResolvedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "Used in the type of [`cdp::proto::debugger::PausedEvent::reason`](struct.PausedEvent.html#structfield.reason)."]
    pub enum PausedEventReason {
        #[serde(rename = "XHR")]
        #[doc = "Represented as `\"XHR\"`."]
        Xhr,
        #[serde(rename = "DOM")]
        #[doc = "Represented as `\"DOM\"`."]
        Dom,
        #[serde(rename = "EventListener")]
        #[doc = "Represented as `\"EventListener\"`."]
        EventListener,
        #[serde(rename = "exception")]
        #[doc = "Represented as `\"exception\"`."]
        Exception,
        #[serde(rename = "assert")]
        #[doc = "Represented as `\"assert\"`."]
        Assert,
        #[serde(rename = "debugCommand")]
        #[doc = "Represented as `\"debugCommand\"`."]
        DebugCommand,
        #[serde(rename = "promiseRejection")]
        #[doc = "Represented as `\"promiseRejection\"`."]
        PromiseRejection,
        #[serde(rename = "OOM")]
        #[doc = "Represented as `\"OOM\"`."]
        Oom,
        #[serde(rename = "other")]
        #[doc = "Represented as `\"other\"`."]
        Other,
        #[serde(rename = "ambiguous")]
        #[doc = "Represented as `\"ambiguous\"`."]
        Ambiguous,
    }
    impl PausedEventReason {
        pub const ENUM_VALUES: &'static [PausedEventReason] = &[
            PausedEventReason::Xhr,
            PausedEventReason::Dom,
            PausedEventReason::EventListener,
            PausedEventReason::Exception,
            PausedEventReason::Assert,
            PausedEventReason::DebugCommand,
            PausedEventReason::PromiseRejection,
            PausedEventReason::Oom,
            PausedEventReason::Other,
            PausedEventReason::Ambiguous,
        ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "XHR",
            "DOM",
            "EventListener",
            "exception",
            "assert",
            "debugCommand",
            "promiseRejection",
            "OOM",
            "other",
            "ambiguous",
        ];
    }
    impl ::std::str::FromStr for PausedEventReason {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "XHR" => Ok(PausedEventReason::Xhr),
                "DOM" => Ok(PausedEventReason::Dom),
                "EventListener" => Ok(PausedEventReason::EventListener),
                "exception" => Ok(PausedEventReason::Exception),
                "assert" => Ok(PausedEventReason::Assert),
                "debugCommand" => Ok(PausedEventReason::DebugCommand),
                "promiseRejection" => Ok(PausedEventReason::PromiseRejection),
                "OOM" => Ok(PausedEventReason::Oom),
                "other" => Ok(PausedEventReason::Other),
                "ambiguous" => Ok(PausedEventReason::Ambiguous),
                _ => Err(::proto::ParseEnumError {
                    expected: PausedEventReason::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for PausedEventReason {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    PausedEventReason::Xhr => "XHR",
                    PausedEventReason::Dom => "DOM",
                    PausedEventReason::EventListener => "EventListener",
                    PausedEventReason::Exception => "exception",
                    PausedEventReason::Assert => "assert",
                    PausedEventReason::DebugCommand => "debugCommand",
                    PausedEventReason::PromiseRejection => "promiseRejection",
                    PausedEventReason::Oom => "OOM",
                    PausedEventReason::Other => "other",
                    PausedEventReason::Ambiguous => "ambiguous",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.\n\n# Event `Debugger.paused`\n\n*Domain Module:* [`cdp::proto::debugger`](index.html)  \n*Event Struct:* [`cdp::proto::debugger::PausedEvent`](struct.PausedEvent.html)"]
    pub struct PausedEvent<'a> {
        #[serde(rename = "callFrames")]
        #[doc = "Call stack the virtual machine stopped on."]
        pub call_frames: Vec<::proto::debugger::CallFrame<'a>>,
        #[serde(rename = "reason")]
        #[doc = "Pause reason."]
        pub reason: ::proto::debugger::PausedEventReason,
        #[serde(rename = "data", skip_serializing_if = "Option::is_none")]
        #[doc = "Object containing break-specific auxiliary properties."]
        pub data: Option<::proto::Empty>,
        #[serde(rename = "hitBreakpoints", skip_serializing_if = "Option::is_none")]
        #[doc = "Hit breakpoints IDs"]
        pub hit_breakpoints: Option<Vec<::std::borrow::Cow<'a, str>>>,
        #[serde(rename = "asyncStackTrace", skip_serializing_if = "Option::is_none")]
        #[doc = "Async stack trace, if any."]
        pub async_stack_trace: Option<::proto::runtime::StackTrace<'a>>,
    }
    impl<'a> ::traits::SerializeCdpEvent for PausedEvent<'a> {
        fn event_name(&self) -> &str {
            "Debugger.paused"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for PausedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.paused" {
                Ok(
                    <PausedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Fired when the virtual machine resumed execution.\n\n# Event `Debugger.resumed`\n\n*Domain Module:* [`cdp::proto::debugger`](index.html)  \n*Event Struct:* [`cdp::proto::debugger::ResumedEvent`](struct.ResumedEvent.html)"]
    pub struct ResumedEvent;
    impl ::serde::Serialize for ResumedEvent {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ResumedEvent {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ResumedEvent)
        }
    }
    impl ::traits::SerializeCdpEvent for ResumedEvent {
        fn event_name(&self) -> &str {
            "Debugger.resumed"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpEvent<'de> for ResumedEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.resumed" {
                Ok(
                    <ResumedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[doc = "Breakpoint identifier."]
    pub type BreakpointId<'a> = ::std::borrow::Cow<'a, str>;
    #[doc = "Call frame identifier."]
    pub type CallFrameId<'a> = ::std::borrow::Cow<'a, str>;
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Location in the source code."]
    pub struct Location<'a> {
        #[serde(rename = "scriptId")]
        #[doc = "Script identifier as reported in the <code>Debugger.scriptParsed</code>."]
        pub script_id: ::proto::runtime::ScriptId<'a>,
        #[serde(rename = "lineNumber")]
        #[doc = "Line number in the script \\(0-based\\)."]
        pub line_number: i32,
        #[serde(rename = "columnNumber", skip_serializing_if = "Option::is_none")]
        #[doc = "Column number in the script \\(0-based\\)."]
        pub column_number: Option<i32>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Location in the source code."]
    pub struct ScriptPosition {
        #[serde(rename = "lineNumber")]
        pub line_number: i32,
        #[serde(rename = "columnNumber")]
        pub column_number: i32,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "JavaScript call frame. Array of call frames form the call stack."]
    pub struct CallFrame<'a> {
        #[serde(rename = "callFrameId")]
        #[doc = "Call frame identifier. This identifier is only valid while the virtual machine is paused."]
        pub call_frame_id: ::proto::debugger::CallFrameId<'a>,
        #[serde(rename = "functionName")]
        #[doc = "Name of the JavaScript function called on this call frame."]
        pub function_name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "functionLocation", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Location in the source code."]
        pub function_location: Option<::proto::debugger::Location<'a>>,
        #[serde(rename = "location")]
        #[doc = "Location in the source code."]
        pub location: ::proto::debugger::Location<'a>,
        #[serde(rename = "scopeChain")]
        #[doc = "Scope chain for this call frame."]
        pub scope_chain: Vec<::proto::debugger::Scope<'a>>,
        #[serde(rename = "this")]
        #[doc = "<code>this</code> object for this call frame."]
        pub this: ::proto::runtime::RemoteObject<'a>,
        #[serde(rename = "returnValue", skip_serializing_if = "Option::is_none")]
        #[doc = "The value being returned, if the function is at return point."]
        pub return_value: Option<::proto::runtime::RemoteObject<'a>>,
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "Used in the type of [`cdp::proto::debugger::Scope::ty`](struct.Scope.html#structfield.ty)."]
    pub enum ScopeType {
        #[serde(rename = "global")]
        #[doc = "Represented as `\"global\"`."]
        Global,
        #[serde(rename = "local")]
        #[doc = "Represented as `\"local\"`."]
        Local,
        #[serde(rename = "with")]
        #[doc = "Represented as `\"with\"`."]
        With,
        #[serde(rename = "closure")]
        #[doc = "Represented as `\"closure\"`."]
        Closure,
        #[serde(rename = "catch")]
        #[doc = "Represented as `\"catch\"`."]
        Catch,
        #[serde(rename = "block")]
        #[doc = "Represented as `\"block\"`."]
        Block,
        #[serde(rename = "script")]
        #[doc = "Represented as `\"script\"`."]
        Script,
        #[serde(rename = "eval")]
        #[doc = "Represented as `\"eval\"`."]
        Eval,
        #[serde(rename = "module")]
        #[doc = "Represented as `\"module\"`."]
        Module,
    }
    impl ScopeType {
        pub const ENUM_VALUES: &'static [ScopeType] = &[
            ScopeType::Global,
            ScopeType::Local,
            ScopeType::With,
            ScopeType::Closure,
            ScopeType::Catch,
            ScopeType::Block,
            ScopeType::Script,
            ScopeType::Eval,
            ScopeType::Module,
        ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "global",
            "local",
            "with",
            "closure",
            "catch",
            "block",
            "script",
            "eval",
            "module",
        ];
    }
    impl ::std::str::FromStr for ScopeType {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "global" => Ok(ScopeType::Global),
                "local" => Ok(ScopeType::Local),
                "with" => Ok(ScopeType::With),
                "closure" => Ok(ScopeType::Closure),
                "catch" => Ok(ScopeType::Catch),
                "block" => Ok(ScopeType::Block),
                "script" => Ok(ScopeType::Script),
                "eval" => Ok(ScopeType::Eval),
                "module" => Ok(ScopeType::Module),
                _ => Err(::proto::ParseEnumError {
                    expected: ScopeType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for ScopeType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    ScopeType::Global => "global",
                    ScopeType::Local => "local",
                    ScopeType::With => "with",
                    ScopeType::Closure => "closure",
                    ScopeType::Catch => "catch",
                    ScopeType::Block => "block",
                    ScopeType::Script => "script",
                    ScopeType::Eval => "eval",
                    ScopeType::Module => "module",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Scope description."]
    pub struct Scope<'a> {
        #[serde(rename = "type")]
        #[doc = "Scope type."]
        pub ty: ::proto::debugger::ScopeType,
        #[serde(rename = "object")]
        #[doc = "Object representing the scope. For <code>global</code> and <code>with</code> scopes it represents the actual object; for the rest of the scopes, it is artificial transient object enumerating scope variables as its properties."]
        pub object: ::proto::runtime::RemoteObject<'a>,
        #[serde(rename = "name", skip_serializing_if = "Option::is_none")]
        pub name: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "startLocation", skip_serializing_if = "Option::is_none")]
        #[doc = "Location in the source code where scope starts"]
        pub start_location: Option<::proto::debugger::Location<'a>>,
        #[serde(rename = "endLocation", skip_serializing_if = "Option::is_none")]
        #[doc = "Location in the source code where scope ends"]
        pub end_location: Option<::proto::debugger::Location<'a>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Search match for resource."]
    pub struct SearchMatch<'a> {
        #[serde(rename = "lineNumber")]
        #[doc = "Line number in resource content."]
        pub line_number: f64,
        #[serde(rename = "lineContent")]
        #[doc = "Line with match content."]
        pub line_content: ::std::borrow::Cow<'a, str>,
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\nUsed in the type of [`cdp::proto::debugger::BreakLocation::ty`](struct.BreakLocation.html#structfield.ty)."]
    pub enum BreakLocationType {
        #[serde(rename = "debuggerStatement")]
        #[doc = "Represented as `\"debuggerStatement\"`."]
        DebuggerStatement,
        #[serde(rename = "call")]
        #[doc = "Represented as `\"call\"`."]
        Call,
        #[serde(rename = "return")]
        #[doc = "Represented as `\"return\"`."]
        Return,
    }
    impl BreakLocationType {
        pub const ENUM_VALUES: &'static [BreakLocationType] = &[
            BreakLocationType::DebuggerStatement,
            BreakLocationType::Call,
            BreakLocationType::Return,
        ];
        pub const STR_VALUES: &'static [&'static str] = &["debuggerStatement", "call", "return"];
    }
    impl ::std::str::FromStr for BreakLocationType {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "debuggerStatement" => Ok(BreakLocationType::DebuggerStatement),
                "call" => Ok(BreakLocationType::Call),
                "return" => Ok(BreakLocationType::Return),
                _ => Err(::proto::ParseEnumError {
                    expected: BreakLocationType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for BreakLocationType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    BreakLocationType::DebuggerStatement => "debuggerStatement",
                    BreakLocationType::Call => "call",
                    BreakLocationType::Return => "return",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>"]
    pub struct BreakLocation<'a> {
        #[serde(rename = "scriptId")]
        #[doc = "Script identifier as reported in the <code>Debugger.scriptParsed</code>."]
        pub script_id: ::proto::runtime::ScriptId<'a>,
        #[serde(rename = "lineNumber")]
        #[doc = "Line number in the script \\(0-based\\)."]
        pub line_number: i32,
        #[serde(rename = "columnNumber", skip_serializing_if = "Option::is_none")]
        #[doc = "Column number in the script \\(0-based\\)."]
        pub column_number: Option<i32>,
        #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
        pub ty: Option<::proto::debugger::BreakLocationType>,
    }
}
#[doc = "# Console\n\n## Commands\n\n- [`Console.enable`](struct.EnableCommand.html)\n  \n  <span class=\"stab deprecated\">This domain is deprecated - use Runtime or Log instead.</span>\n\n  Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.\n- [`Console.disable`](struct.DisableCommand.html)\n  \n  <span class=\"stab deprecated\">This domain is deprecated - use Runtime or Log instead.</span>\n\n  Disables console domain, prevents further console messages from being reported to the client.\n- [`Console.clearMessages`](struct.ClearMessagesCommand.html)\n  \n  <span class=\"stab deprecated\">This domain is deprecated - use Runtime or Log instead.</span>\n\n  Does nothing.\n\n## Events\n\n- [`Console.messageAdded`](struct.MessageAddedEvent.html)\n  \n  <span class=\"stab deprecated\">This domain is deprecated - use Runtime or Log instead.</span>\n\n  Issued when new console message is added.\n\n##Types\n\n- [`ConsoleMessage`](struct.ConsoleMessage.html)\n  \n  <span class=\"stab deprecated\">This domain is deprecated - use Runtime or Log instead.</span>\n\n  Console message.\n"]
#[deprecated(note = "This domain is deprecated - use Runtime or Log instead.")]
pub mod console {
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.\n\n# Command `Console.enable`\n\n*Domain Module:* [`cdp::proto::console`](index.html)  \n*Command Struct:* [`cdp::proto::console::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::proto::console::EnableResponse`](struct.EnableResponse.html)"]
    #[deprecated(note = "This domain is deprecated - use Runtime or Log instead.")]
    pub struct EnableCommand;
    impl ::serde::Serialize for EnableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for EnableCommand {
        fn command_name(&self) -> &str {
            "Console.enable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for EnableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Console.enable" {
                Ok(
                    <EnableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.\n\n# Command `Console.enable`\n\n*Domain Module:* [`cdp::proto::console`](index.html)  \n*Command Struct:* [`cdp::proto::console::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::proto::console::EnableResponse`](struct.EnableResponse.html)"]
    #[deprecated(note = "This domain is deprecated - use Runtime or Log instead.")]
    pub struct EnableResponse;
    impl ::serde::Serialize for EnableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for EnableCommand {
        type Response = EnableResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for EnableResponse {
        type Command = EnableCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Disables console domain, prevents further console messages from being reported to the client.\n\n# Command `Console.disable`\n\n*Domain Module:* [`cdp::proto::console`](index.html)  \n*Command Struct:* [`cdp::proto::console::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::proto::console::DisableResponse`](struct.DisableResponse.html)"]
    #[deprecated(note = "This domain is deprecated - use Runtime or Log instead.")]
    pub struct DisableCommand;
    impl ::serde::Serialize for DisableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for DisableCommand {
        fn command_name(&self) -> &str {
            "Console.disable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for DisableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Console.disable" {
                Ok(
                    <DisableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Disables console domain, prevents further console messages from being reported to the client.\n\n# Command `Console.disable`\n\n*Domain Module:* [`cdp::proto::console`](index.html)  \n*Command Struct:* [`cdp::proto::console::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::proto::console::DisableResponse`](struct.DisableResponse.html)"]
    #[deprecated(note = "This domain is deprecated - use Runtime or Log instead.")]
    pub struct DisableResponse;
    impl ::serde::Serialize for DisableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for DisableCommand {
        type Response = DisableResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for DisableResponse {
        type Command = DisableCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Does nothing.\n\n# Command `Console.clearMessages`\n\n*Domain Module:* [`cdp::proto::console`](index.html)  \n*Command Struct:* [`cdp::proto::console::ClearMessagesCommand`](struct.ClearMessagesCommand.html)  \n*Response Struct:* [`cdp::proto::console::ClearMessagesResponse`](struct.ClearMessagesResponse.html)"]
    #[deprecated(note = "This domain is deprecated - use Runtime or Log instead.")]
    pub struct ClearMessagesCommand;
    impl ::serde::Serialize for ClearMessagesCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ClearMessagesCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ClearMessagesCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for ClearMessagesCommand {
        fn command_name(&self) -> &str {
            "Console.clearMessages"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for ClearMessagesCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Console.clearMessages" {
                Ok(
                    <ClearMessagesCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Does nothing.\n\n# Command `Console.clearMessages`\n\n*Domain Module:* [`cdp::proto::console`](index.html)  \n*Command Struct:* [`cdp::proto::console::ClearMessagesCommand`](struct.ClearMessagesCommand.html)  \n*Response Struct:* [`cdp::proto::console::ClearMessagesResponse`](struct.ClearMessagesResponse.html)"]
    #[deprecated(note = "This domain is deprecated - use Runtime or Log instead.")]
    pub struct ClearMessagesResponse;
    impl ::serde::Serialize for ClearMessagesResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ClearMessagesResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ClearMessagesResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for ClearMessagesCommand {
        type Response = ClearMessagesResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for ClearMessagesResponse {
        type Command = ClearMessagesCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Issued when new console message is added.\n\n# Event `Console.messageAdded`\n\n*Domain Module:* [`cdp::proto::console`](index.html)  \n*Event Struct:* [`cdp::proto::console::MessageAddedEvent`](struct.MessageAddedEvent.html)"]
    #[deprecated(note = "This domain is deprecated - use Runtime or Log instead.")]
    pub struct MessageAddedEvent<'a> {
        #[serde(rename = "message")]
        #[doc = "Console message that has been added."]
        pub message: ::proto::console::ConsoleMessage<'a>,
    }
    impl<'a> ::traits::SerializeCdpEvent for MessageAddedEvent<'a> {
        fn event_name(&self) -> &str {
            "Console.messageAdded"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for MessageAddedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Console.messageAdded" {
                Ok(
                    <MessageAddedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "Used in the type of [`cdp::proto::console::ConsoleMessage::source`](struct.ConsoleMessage.html#structfield.source)."]
    #[deprecated(note = "This domain is deprecated - use Runtime or Log instead.")]
    pub enum ConsoleMessageSource {
        #[serde(rename = "xml")]
        #[doc = "Represented as `\"xml\"`."]
        Xml,
        #[serde(rename = "javascript")]
        #[doc = "Represented as `\"javascript\"`."]
        Javascript,
        #[serde(rename = "network")]
        #[doc = "Represented as `\"network\"`."]
        Network,
        #[serde(rename = "console-api")]
        #[doc = "Represented as `\"console-api\"`."]
        ConsoleApi,
        #[serde(rename = "storage")]
        #[doc = "Represented as `\"storage\"`."]
        Storage,
        #[serde(rename = "appcache")]
        #[doc = "Represented as `\"appcache\"`."]
        Appcache,
        #[serde(rename = "rendering")]
        #[doc = "Represented as `\"rendering\"`."]
        Rendering,
        #[serde(rename = "security")]
        #[doc = "Represented as `\"security\"`."]
        Security,
        #[serde(rename = "other")]
        #[doc = "Represented as `\"other\"`."]
        Other,
        #[serde(rename = "deprecation")]
        #[doc = "Represented as `\"deprecation\"`."]
        Deprecation,
        #[serde(rename = "worker")]
        #[doc = "Represented as `\"worker\"`."]
        Worker,
    }
    impl ConsoleMessageSource {
        pub const ENUM_VALUES: &'static [ConsoleMessageSource] = &[
            ConsoleMessageSource::Xml,
            ConsoleMessageSource::Javascript,
            ConsoleMessageSource::Network,
            ConsoleMessageSource::ConsoleApi,
            ConsoleMessageSource::Storage,
            ConsoleMessageSource::Appcache,
            ConsoleMessageSource::Rendering,
            ConsoleMessageSource::Security,
            ConsoleMessageSource::Other,
            ConsoleMessageSource::Deprecation,
            ConsoleMessageSource::Worker,
        ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "xml",
            "javascript",
            "network",
            "console-api",
            "storage",
            "appcache",
            "rendering",
            "security",
            "other",
            "deprecation",
            "worker",
        ];
    }
    impl ::std::str::FromStr for ConsoleMessageSource {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "xml" => Ok(ConsoleMessageSource::Xml),
                "javascript" => Ok(ConsoleMessageSource::Javascript),
                "network" => Ok(ConsoleMessageSource::Network),
                "console-api" => Ok(ConsoleMessageSource::ConsoleApi),
                "storage" => Ok(ConsoleMessageSource::Storage),
                "appcache" => Ok(ConsoleMessageSource::Appcache),
                "rendering" => Ok(ConsoleMessageSource::Rendering),
                "security" => Ok(ConsoleMessageSource::Security),
                "other" => Ok(ConsoleMessageSource::Other),
                "deprecation" => Ok(ConsoleMessageSource::Deprecation),
                "worker" => Ok(ConsoleMessageSource::Worker),
                _ => Err(::proto::ParseEnumError {
                    expected: ConsoleMessageSource::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for ConsoleMessageSource {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    ConsoleMessageSource::Xml => "xml",
                    ConsoleMessageSource::Javascript => "javascript",
                    ConsoleMessageSource::Network => "network",
                    ConsoleMessageSource::ConsoleApi => "console-api",
                    ConsoleMessageSource::Storage => "storage",
                    ConsoleMessageSource::Appcache => "appcache",
                    ConsoleMessageSource::Rendering => "rendering",
                    ConsoleMessageSource::Security => "security",
                    ConsoleMessageSource::Other => "other",
                    ConsoleMessageSource::Deprecation => "deprecation",
                    ConsoleMessageSource::Worker => "worker",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "Used in the type of [`cdp::proto::console::ConsoleMessage::level`](struct.ConsoleMessage.html#structfield.level)."]
    #[deprecated(note = "This domain is deprecated - use Runtime or Log instead.")]
    pub enum ConsoleMessageLevel {
        #[serde(rename = "log")]
        #[doc = "Represented as `\"log\"`."]
        Log,
        #[serde(rename = "warning")]
        #[doc = "Represented as `\"warning\"`."]
        Warning,
        #[serde(rename = "error")]
        #[doc = "Represented as `\"error\"`."]
        Error,
        #[serde(rename = "debug")]
        #[doc = "Represented as `\"debug\"`."]
        Debug,
        #[serde(rename = "info")]
        #[doc = "Represented as `\"info\"`."]
        Info,
    }
    impl ConsoleMessageLevel {
        pub const ENUM_VALUES: &'static [ConsoleMessageLevel] = &[
            ConsoleMessageLevel::Log,
            ConsoleMessageLevel::Warning,
            ConsoleMessageLevel::Error,
            ConsoleMessageLevel::Debug,
            ConsoleMessageLevel::Info,
        ];
        pub const STR_VALUES: &'static [&'static str] =
            &["log", "warning", "error", "debug", "info"];
    }
    impl ::std::str::FromStr for ConsoleMessageLevel {
        type Err = ::proto::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "log" => Ok(ConsoleMessageLevel::Log),
                "warning" => Ok(ConsoleMessageLevel::Warning),
                "error" => Ok(ConsoleMessageLevel::Error),
                "debug" => Ok(ConsoleMessageLevel::Debug),
                "info" => Ok(ConsoleMessageLevel::Info),
                _ => Err(::proto::ParseEnumError {
                    expected: ConsoleMessageLevel::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for ConsoleMessageLevel {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    ConsoleMessageLevel::Log => "log",
                    ConsoleMessageLevel::Warning => "warning",
                    ConsoleMessageLevel::Error => "error",
                    ConsoleMessageLevel::Debug => "debug",
                    ConsoleMessageLevel::Info => "info",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Console message."]
    #[deprecated(note = "This domain is deprecated - use Runtime or Log instead.")]
    pub struct ConsoleMessage<'a> {
        #[serde(rename = "source")]
        #[doc = "Message source."]
        pub source: ::proto::console::ConsoleMessageSource,
        #[serde(rename = "level")]
        #[doc = "Message severity."]
        pub level: ::proto::console::ConsoleMessageLevel,
        #[serde(rename = "text")]
        #[doc = "Message text."]
        pub text: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "url", skip_serializing_if = "Option::is_none")]
        #[doc = "URL of the message origin."]
        pub url: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "line", skip_serializing_if = "Option::is_none")]
        #[doc = "Line number in the resource that generated this message \\(1-based\\)."]
        pub line: Option<i32>,
        #[serde(rename = "column", skip_serializing_if = "Option::is_none")]
        #[doc = "Column number in the resource that generated this message \\(1-based\\)."]
        pub column: Option<i32>,
    }
}
#[doc = "# Profiler\n\n## Commands\n\n- [`Profiler.enable`](struct.EnableCommand.html)\n- [`Profiler.disable`](struct.DisableCommand.html)\n- [`Profiler.setSamplingInterval`](struct.SetSamplingIntervalCommand.html)\n\n  Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.\n- [`Profiler.start`](struct.StartCommand.html)\n- [`Profiler.stop`](struct.StopCommand.html)\n- [`Profiler.startPreciseCoverage`](struct.StartPreciseCoverageCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.\n- [`Profiler.stopPreciseCoverage`](struct.StopPreciseCoverageCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.\n- [`Profiler.takePreciseCoverage`](struct.TakePreciseCoverageCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.\n- [`Profiler.getBestEffortCoverage`](struct.GetBestEffortCoverageCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.\n\n## Events\n\n- [`Profiler.consoleProfileStarted`](struct.ConsoleProfileStartedEvent.html)\n\n  Sent when new profile recording is started using console.profile\\(\\) call.\n- [`Profiler.consoleProfileFinished`](struct.ConsoleProfileFinishedEvent.html)\n\n##Types\n\n- [`ProfileNode`](struct.ProfileNode.html)\n\n  Profile node. Holds callsite information, execution statistics and child nodes.\n- [`Profile`](struct.Profile.html)\n\n  Profile.\n- [`PositionTickInfo`](struct.PositionTickInfo.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Specifies a number of samples attributed to a certain source position.\n- [`CoverageRange`](struct.CoverageRange.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Coverage data for a source range.\n- [`FunctionCoverage`](struct.FunctionCoverage.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Coverage data for a JavaScript function.\n- [`ScriptCoverage`](struct.ScriptCoverage.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Coverage data for a JavaScript script.\n"]
pub mod profiler {
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "# Command `Profiler.enable`\n\n*Domain Module:* [`cdp::proto::profiler`](index.html)  \n*Command Struct:* [`cdp::proto::profiler::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::proto::profiler::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableCommand;
    impl ::serde::Serialize for EnableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for EnableCommand {
        fn command_name(&self) -> &str {
            "Profiler.enable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for EnableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Profiler.enable" {
                Ok(
                    <EnableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "# Command `Profiler.enable`\n\n*Domain Module:* [`cdp::proto::profiler`](index.html)  \n*Command Struct:* [`cdp::proto::profiler::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::proto::profiler::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableResponse;
    impl ::serde::Serialize for EnableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for EnableCommand {
        type Response = EnableResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for EnableResponse {
        type Command = EnableCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "# Command `Profiler.disable`\n\n*Domain Module:* [`cdp::proto::profiler`](index.html)  \n*Command Struct:* [`cdp::proto::profiler::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::proto::profiler::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableCommand;
    impl ::serde::Serialize for DisableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for DisableCommand {
        fn command_name(&self) -> &str {
            "Profiler.disable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for DisableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Profiler.disable" {
                Ok(
                    <DisableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "# Command `Profiler.disable`\n\n*Domain Module:* [`cdp::proto::profiler`](index.html)  \n*Command Struct:* [`cdp::proto::profiler::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::proto::profiler::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableResponse;
    impl ::serde::Serialize for DisableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for DisableCommand {
        type Response = DisableResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for DisableResponse {
        type Command = DisableCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.\n\n# Command `Profiler.setSamplingInterval`\n\n*Domain Module:* [`cdp::proto::profiler`](index.html)  \n*Command Struct:* [`cdp::proto::profiler::SetSamplingIntervalCommand`](struct.SetSamplingIntervalCommand.html)  \n*Response Struct:* [`cdp::proto::profiler::SetSamplingIntervalResponse`](struct.SetSamplingIntervalResponse.html)"]
    pub struct SetSamplingIntervalCommand {
        #[serde(rename = "interval")]
        #[doc = "New sampling interval in microseconds."]
        pub interval: i32,
    }
    impl ::traits::SerializeCdpCommand for SetSamplingIntervalCommand {
        fn command_name(&self) -> &str {
            "Profiler.setSamplingInterval"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for SetSamplingIntervalCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Profiler.setSamplingInterval" {
                Ok ( < SetSamplingIntervalCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.\n\n# Command `Profiler.setSamplingInterval`\n\n*Domain Module:* [`cdp::proto::profiler`](index.html)  \n*Command Struct:* [`cdp::proto::profiler::SetSamplingIntervalCommand`](struct.SetSamplingIntervalCommand.html)  \n*Response Struct:* [`cdp::proto::profiler::SetSamplingIntervalResponse`](struct.SetSamplingIntervalResponse.html)"]
    pub struct SetSamplingIntervalResponse;
    impl ::serde::Serialize for SetSamplingIntervalResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetSamplingIntervalResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetSamplingIntervalResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for SetSamplingIntervalCommand {
        type Response = SetSamplingIntervalResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for SetSamplingIntervalResponse {
        type Command = SetSamplingIntervalCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "# Command `Profiler.start`\n\n*Domain Module:* [`cdp::proto::profiler`](index.html)  \n*Command Struct:* [`cdp::proto::profiler::StartCommand`](struct.StartCommand.html)  \n*Response Struct:* [`cdp::proto::profiler::StartResponse`](struct.StartResponse.html)"]
    pub struct StartCommand;
    impl ::serde::Serialize for StartCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StartCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StartCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for StartCommand {
        fn command_name(&self) -> &str {
            "Profiler.start"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for StartCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Profiler.start" {
                Ok(
                    <StartCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "# Command `Profiler.start`\n\n*Domain Module:* [`cdp::proto::profiler`](index.html)  \n*Command Struct:* [`cdp::proto::profiler::StartCommand`](struct.StartCommand.html)  \n*Response Struct:* [`cdp::proto::profiler::StartResponse`](struct.StartResponse.html)"]
    pub struct StartResponse;
    impl ::serde::Serialize for StartResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StartResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StartResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for StartCommand {
        type Response = StartResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for StartResponse {
        type Command = StartCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "# Command `Profiler.stop`\n\n*Domain Module:* [`cdp::proto::profiler`](index.html)  \n*Command Struct:* [`cdp::proto::profiler::StopCommand`](struct.StopCommand.html)  \n*Response Struct:* [`cdp::proto::profiler::StopResponse`](struct.StopResponse.html)"]
    pub struct StopCommand;
    impl ::serde::Serialize for StopCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StopCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StopCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for StopCommand {
        fn command_name(&self) -> &str {
            "Profiler.stop"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for StopCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Profiler.stop" {
                Ok(
                    <StopCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "# Command `Profiler.stop`\n\n*Domain Module:* [`cdp::proto::profiler`](index.html)  \n*Command Struct:* [`cdp::proto::profiler::StopCommand`](struct.StopCommand.html)  \n*Response Struct:* [`cdp::proto::profiler::StopResponse`](struct.StopResponse.html)"]
    pub struct StopResponse<'a> {
        #[serde(rename = "profile")]
        #[doc = "Recorded profile."]
        pub profile: ::proto::profiler::Profile<'a>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for StopCommand {
        type Response = StopResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for StopResponse<'a> {
        type Command = StopCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.\n\n# Command `Profiler.startPreciseCoverage`\n\n*Domain Module:* [`cdp::proto::profiler`](index.html)  \n*Command Struct:* [`cdp::proto::profiler::StartPreciseCoverageCommand`](struct.StartPreciseCoverageCommand.html)  \n*Response Struct:* [`cdp::proto::profiler::StartPreciseCoverageResponse`](struct.StartPreciseCoverageResponse.html)"]
    pub struct StartPreciseCoverageCommand {
        #[serde(rename = "callCount", skip_serializing_if = "Option::is_none")]
        #[doc = "Collect accurate call counts beyond simple 'covered' or 'not covered'."]
        pub call_count: Option<bool>,
    }
    impl ::traits::SerializeCdpCommand for StartPreciseCoverageCommand {
        fn command_name(&self) -> &str {
            "Profiler.startPreciseCoverage"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for StartPreciseCoverageCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Profiler.startPreciseCoverage" {
                Ok ( < StartPreciseCoverageCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.\n\n# Command `Profiler.startPreciseCoverage`\n\n*Domain Module:* [`cdp::proto::profiler`](index.html)  \n*Command Struct:* [`cdp::proto::profiler::StartPreciseCoverageCommand`](struct.StartPreciseCoverageCommand.html)  \n*Response Struct:* [`cdp::proto::profiler::StartPreciseCoverageResponse`](struct.StartPreciseCoverageResponse.html)"]
    pub struct StartPreciseCoverageResponse;
    impl ::serde::Serialize for StartPreciseCoverageResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StartPreciseCoverageResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StartPreciseCoverageResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for StartPreciseCoverageCommand {
        type Response = StartPreciseCoverageResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for StartPreciseCoverageResponse {
        type Command = StartPreciseCoverageCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.\n\n# Command `Profiler.stopPreciseCoverage`\n\n*Domain Module:* [`cdp::proto::profiler`](index.html)  \n*Command Struct:* [`cdp::proto::profiler::StopPreciseCoverageCommand`](struct.StopPreciseCoverageCommand.html)  \n*Response Struct:* [`cdp::proto::profiler::StopPreciseCoverageResponse`](struct.StopPreciseCoverageResponse.html)"]
    pub struct StopPreciseCoverageCommand;
    impl ::serde::Serialize for StopPreciseCoverageCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StopPreciseCoverageCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StopPreciseCoverageCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for StopPreciseCoverageCommand {
        fn command_name(&self) -> &str {
            "Profiler.stopPreciseCoverage"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for StopPreciseCoverageCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Profiler.stopPreciseCoverage" {
                Ok ( < StopPreciseCoverageCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.\n\n# Command `Profiler.stopPreciseCoverage`\n\n*Domain Module:* [`cdp::proto::profiler`](index.html)  \n*Command Struct:* [`cdp::proto::profiler::StopPreciseCoverageCommand`](struct.StopPreciseCoverageCommand.html)  \n*Response Struct:* [`cdp::proto::profiler::StopPreciseCoverageResponse`](struct.StopPreciseCoverageResponse.html)"]
    pub struct StopPreciseCoverageResponse;
    impl ::serde::Serialize for StopPreciseCoverageResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StopPreciseCoverageResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StopPreciseCoverageResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for StopPreciseCoverageCommand {
        type Response = StopPreciseCoverageResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for StopPreciseCoverageResponse {
        type Command = StopPreciseCoverageCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.\n\n# Command `Profiler.takePreciseCoverage`\n\n*Domain Module:* [`cdp::proto::profiler`](index.html)  \n*Command Struct:* [`cdp::proto::profiler::TakePreciseCoverageCommand`](struct.TakePreciseCoverageCommand.html)  \n*Response Struct:* [`cdp::proto::profiler::TakePreciseCoverageResponse`](struct.TakePreciseCoverageResponse.html)"]
    pub struct TakePreciseCoverageCommand;
    impl ::serde::Serialize for TakePreciseCoverageCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for TakePreciseCoverageCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| TakePreciseCoverageCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for TakePreciseCoverageCommand {
        fn command_name(&self) -> &str {
            "Profiler.takePreciseCoverage"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for TakePreciseCoverageCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Profiler.takePreciseCoverage" {
                Ok ( < TakePreciseCoverageCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.\n\n# Command `Profiler.takePreciseCoverage`\n\n*Domain Module:* [`cdp::proto::profiler`](index.html)  \n*Command Struct:* [`cdp::proto::profiler::TakePreciseCoverageCommand`](struct.TakePreciseCoverageCommand.html)  \n*Response Struct:* [`cdp::proto::profiler::TakePreciseCoverageResponse`](struct.TakePreciseCoverageResponse.html)"]
    pub struct TakePreciseCoverageResponse<'a> {
        #[serde(rename = "result")]
        #[doc = "Coverage data for the current isolate."]
        pub result: Vec<::proto::profiler::ScriptCoverage<'a>>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for TakePreciseCoverageCommand {
        type Response = TakePreciseCoverageResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for TakePreciseCoverageResponse<'a> {
        type Command = TakePreciseCoverageCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.\n\n# Command `Profiler.getBestEffortCoverage`\n\n*Domain Module:* [`cdp::proto::profiler`](index.html)  \n*Command Struct:* [`cdp::proto::profiler::GetBestEffortCoverageCommand`](struct.GetBestEffortCoverageCommand.html)  \n*Response Struct:* [`cdp::proto::profiler::GetBestEffortCoverageResponse`](struct.GetBestEffortCoverageResponse.html)"]
    pub struct GetBestEffortCoverageCommand;
    impl ::serde::Serialize for GetBestEffortCoverageCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetBestEffortCoverageCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| GetBestEffortCoverageCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for GetBestEffortCoverageCommand {
        fn command_name(&self) -> &str {
            "Profiler.getBestEffortCoverage"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for GetBestEffortCoverageCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Profiler.getBestEffortCoverage" {
                Ok ( < GetBestEffortCoverageCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.\n\n# Command `Profiler.getBestEffortCoverage`\n\n*Domain Module:* [`cdp::proto::profiler`](index.html)  \n*Command Struct:* [`cdp::proto::profiler::GetBestEffortCoverageCommand`](struct.GetBestEffortCoverageCommand.html)  \n*Response Struct:* [`cdp::proto::profiler::GetBestEffortCoverageResponse`](struct.GetBestEffortCoverageResponse.html)"]
    pub struct GetBestEffortCoverageResponse<'a> {
        #[serde(rename = "result")]
        #[doc = "Coverage data for the current isolate."]
        pub result: Vec<::proto::profiler::ScriptCoverage<'a>>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for GetBestEffortCoverageCommand {
        type Response = GetBestEffortCoverageResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for GetBestEffortCoverageResponse<'a> {
        type Command = GetBestEffortCoverageCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Sent when new profile recording is started using console.profile\\(\\) call.\n\n# Event `Profiler.consoleProfileStarted`\n\n*Domain Module:* [`cdp::proto::profiler`](index.html)  \n*Event Struct:* [`cdp::proto::profiler::ConsoleProfileStartedEvent`](struct.ConsoleProfileStartedEvent.html)"]
    pub struct ConsoleProfileStartedEvent<'a> {
        #[serde(rename = "id")]
        pub id: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "location")]
        #[doc = "Location of console.profile\\(\\)."]
        pub location: ::proto::debugger::Location<'a>,
        #[serde(rename = "title", skip_serializing_if = "Option::is_none")]
        #[doc = "Profile title passed as an argument to console.profile\\(\\)."]
        pub title: Option<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::traits::SerializeCdpEvent for ConsoleProfileStartedEvent<'a> {
        fn event_name(&self) -> &str {
            "Profiler.consoleProfileStarted"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for ConsoleProfileStartedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Profiler.consoleProfileStarted" {
                Ok ( < ConsoleProfileStartedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "# Event `Profiler.consoleProfileFinished`\n\n*Domain Module:* [`cdp::proto::profiler`](index.html)  \n*Event Struct:* [`cdp::proto::profiler::ConsoleProfileFinishedEvent`](struct.ConsoleProfileFinishedEvent.html)"]
    pub struct ConsoleProfileFinishedEvent<'a> {
        #[serde(rename = "id")]
        pub id: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "location")]
        #[doc = "Location of console.profileEnd\\(\\)."]
        pub location: ::proto::debugger::Location<'a>,
        #[serde(rename = "profile")]
        pub profile: ::proto::profiler::Profile<'a>,
        #[serde(rename = "title", skip_serializing_if = "Option::is_none")]
        #[doc = "Profile title passed as an argument to console.profile\\(\\)."]
        pub title: Option<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::traits::SerializeCdpEvent for ConsoleProfileFinishedEvent<'a> {
        fn event_name(&self) -> &str {
            "Profiler.consoleProfileFinished"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for ConsoleProfileFinishedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Profiler.consoleProfileFinished" {
                Ok ( < ConsoleProfileFinishedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Profile node. Holds callsite information, execution statistics and child nodes."]
    pub struct ProfileNode<'a> {
        #[serde(rename = "id")]
        #[doc = "Unique id of the node."]
        pub id: i32,
        #[serde(rename = "callFrame")]
        #[doc = "Function location."]
        pub call_frame: ::proto::runtime::CallFrame<'a>,
        #[serde(rename = "hitCount", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Number of samples where this node was on top of the call stack."]
        pub hit_count: Option<i32>,
        #[serde(rename = "children", skip_serializing_if = "Option::is_none")]
        #[doc = "Child node ids."]
        pub children: Option<Vec<i32>>,
        #[serde(rename = "deoptReason", skip_serializing_if = "Option::is_none")]
        #[doc = "The reason of being not optimized. The function may be deoptimized or marked as don't optimize."]
        pub deopt_reason: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "positionTicks", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> An array of source position ticks."]
        pub position_ticks: Option<Vec<::proto::profiler::PositionTickInfo>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Profile."]
    pub struct Profile<'a> {
        #[serde(rename = "nodes")]
        #[doc = "The list of profile nodes. First item is the root node."]
        pub nodes: Vec<::proto::profiler::ProfileNode<'a>>,
        #[serde(rename = "startTime")]
        #[doc = "Profiling start timestamp in microseconds."]
        pub start_time: f64,
        #[serde(rename = "endTime")]
        #[doc = "Profiling end timestamp in microseconds."]
        pub end_time: f64,
        #[serde(rename = "samples", skip_serializing_if = "Option::is_none")]
        #[doc = "Ids of samples top nodes."]
        pub samples: Option<Vec<i32>>,
        #[serde(rename = "timeDeltas", skip_serializing_if = "Option::is_none")]
        #[doc = "Time intervals between adjacent samples in microseconds. The first delta is relative to the profile startTime."]
        pub time_deltas: Option<Vec<i32>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Specifies a number of samples attributed to a certain source position."]
    pub struct PositionTickInfo {
        #[serde(rename = "line")]
        #[doc = "Source line number \\(1-based\\)."]
        pub line: i32,
        #[serde(rename = "ticks")]
        #[doc = "Number of samples attributed to the source line."]
        pub ticks: i32,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Coverage data for a source range."]
    pub struct CoverageRange {
        #[serde(rename = "startOffset")]
        #[doc = "JavaScript script source offset for the range start."]
        pub start_offset: i32,
        #[serde(rename = "endOffset")]
        #[doc = "JavaScript script source offset for the range end."]
        pub end_offset: i32,
        #[serde(rename = "count")]
        #[doc = "Collected execution count of the source range."]
        pub count: i32,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Coverage data for a JavaScript function."]
    pub struct FunctionCoverage<'a> {
        #[serde(rename = "functionName")]
        #[doc = "JavaScript function name."]
        pub function_name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "ranges")]
        #[doc = "Source ranges inside the function with coverage data."]
        pub ranges: Vec<::proto::profiler::CoverageRange>,
        #[serde(rename = "isBlockCoverage")]
        #[doc = "Whether coverage data for this function has block granularity."]
        pub is_block_coverage: bool,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Coverage data for a JavaScript script."]
    pub struct ScriptCoverage<'a> {
        #[serde(rename = "scriptId")]
        #[doc = "JavaScript script id."]
        pub script_id: ::proto::runtime::ScriptId<'a>,
        #[serde(rename = "url")]
        #[doc = "JavaScript script name or url."]
        pub url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "functions")]
        #[doc = "Functions contained in the script that has coverage data."]
        pub functions: Vec<::proto::profiler::FunctionCoverage<'a>>,
    }
}
#[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# HeapProfiler\n\n## Commands\n\n- [`HeapProfiler.enable`](struct.EnableCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`HeapProfiler.disable`](struct.DisableCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`HeapProfiler.startTrackingHeapObjects`](struct.StartTrackingHeapObjectsCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`HeapProfiler.stopTrackingHeapObjects`](struct.StopTrackingHeapObjectsCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`HeapProfiler.takeHeapSnapshot`](struct.TakeHeapSnapshotCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`HeapProfiler.collectGarbage`](struct.CollectGarbageCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`HeapProfiler.getObjectByHeapObjectId`](struct.GetObjectByHeapObjectIdCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`HeapProfiler.addInspectedHeapObject`](struct.AddInspectedHeapObjectCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Enables console to refer to the node with given id via $x \\(see Command Line API for more details $x functions\\).\n- [`HeapProfiler.getHeapObjectId`](struct.GetHeapObjectIdCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`HeapProfiler.startSampling`](struct.StartSamplingCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`HeapProfiler.stopSampling`](struct.StopSamplingCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n## Events\n\n- [`HeapProfiler.addHeapSnapshotChunk`](struct.AddHeapSnapshotChunkEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`HeapProfiler.resetProfiles`](struct.ResetProfilesEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`HeapProfiler.reportHeapSnapshotProgress`](struct.ReportHeapSnapshotProgressEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`HeapProfiler.lastSeenObjectId`](struct.LastSeenObjectIdEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.\n- [`HeapProfiler.heapStatsUpdate`](struct.HeapStatsUpdateEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  If heap objects tracking has been started then backend may send update for one or more fragments\n\n##Types\n\n- [`HeapSnapshotObjectId`](type.HeapSnapshotObjectId.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Heap snapshot object id.\n- [`SamplingHeapProfileNode`](struct.SamplingHeapProfileNode.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Sampling Heap Profile node. Holds callsite information, allocation statistics and child nodes.\n- [`SamplingHeapProfile`](struct.SamplingHeapProfile.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Profile.\n"]
pub mod heap_profiler {
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `HeapProfiler.enable`\n\n*Domain Module:* [`cdp::proto::heap_profiler`](index.html)  \n*Command Struct:* [`cdp::proto::heap_profiler::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::proto::heap_profiler::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableCommand;
    impl ::serde::Serialize for EnableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for EnableCommand {
        fn command_name(&self) -> &str {
            "HeapProfiler.enable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for EnableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "HeapProfiler.enable" {
                Ok(
                    <EnableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `HeapProfiler.enable`\n\n*Domain Module:* [`cdp::proto::heap_profiler`](index.html)  \n*Command Struct:* [`cdp::proto::heap_profiler::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::proto::heap_profiler::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableResponse;
    impl ::serde::Serialize for EnableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for EnableCommand {
        type Response = EnableResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for EnableResponse {
        type Command = EnableCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `HeapProfiler.disable`\n\n*Domain Module:* [`cdp::proto::heap_profiler`](index.html)  \n*Command Struct:* [`cdp::proto::heap_profiler::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::proto::heap_profiler::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableCommand;
    impl ::serde::Serialize for DisableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for DisableCommand {
        fn command_name(&self) -> &str {
            "HeapProfiler.disable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for DisableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "HeapProfiler.disable" {
                Ok(
                    <DisableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `HeapProfiler.disable`\n\n*Domain Module:* [`cdp::proto::heap_profiler`](index.html)  \n*Command Struct:* [`cdp::proto::heap_profiler::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::proto::heap_profiler::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableResponse;
    impl ::serde::Serialize for DisableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for DisableCommand {
        type Response = DisableResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for DisableResponse {
        type Command = DisableCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `HeapProfiler.startTrackingHeapObjects`\n\n*Domain Module:* [`cdp::proto::heap_profiler`](index.html)  \n*Command Struct:* [`cdp::proto::heap_profiler::StartTrackingHeapObjectsCommand`](struct.StartTrackingHeapObjectsCommand.html)  \n*Response Struct:* [`cdp::proto::heap_profiler::StartTrackingHeapObjectsResponse`](struct.StartTrackingHeapObjectsResponse.html)"]
    pub struct StartTrackingHeapObjectsCommand {
        #[serde(rename = "trackAllocations", skip_serializing_if = "Option::is_none")]
        pub track_allocations: Option<bool>,
    }
    impl ::traits::SerializeCdpCommand for StartTrackingHeapObjectsCommand {
        fn command_name(&self) -> &str {
            "HeapProfiler.startTrackingHeapObjects"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for StartTrackingHeapObjectsCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "HeapProfiler.startTrackingHeapObjects" {
                Ok ( < StartTrackingHeapObjectsCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `HeapProfiler.startTrackingHeapObjects`\n\n*Domain Module:* [`cdp::proto::heap_profiler`](index.html)  \n*Command Struct:* [`cdp::proto::heap_profiler::StartTrackingHeapObjectsCommand`](struct.StartTrackingHeapObjectsCommand.html)  \n*Response Struct:* [`cdp::proto::heap_profiler::StartTrackingHeapObjectsResponse`](struct.StartTrackingHeapObjectsResponse.html)"]
    pub struct StartTrackingHeapObjectsResponse;
    impl ::serde::Serialize for StartTrackingHeapObjectsResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StartTrackingHeapObjectsResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StartTrackingHeapObjectsResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for StartTrackingHeapObjectsCommand {
        type Response = StartTrackingHeapObjectsResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for StartTrackingHeapObjectsResponse {
        type Command = StartTrackingHeapObjectsCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `HeapProfiler.stopTrackingHeapObjects`\n\n*Domain Module:* [`cdp::proto::heap_profiler`](index.html)  \n*Command Struct:* [`cdp::proto::heap_profiler::StopTrackingHeapObjectsCommand`](struct.StopTrackingHeapObjectsCommand.html)  \n*Response Struct:* [`cdp::proto::heap_profiler::StopTrackingHeapObjectsResponse`](struct.StopTrackingHeapObjectsResponse.html)"]
    pub struct StopTrackingHeapObjectsCommand {
        #[serde(rename = "reportProgress", skip_serializing_if = "Option::is_none")]
        #[doc = "If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken when the tracking is stopped."]
        pub report_progress: Option<bool>,
    }
    impl ::traits::SerializeCdpCommand for StopTrackingHeapObjectsCommand {
        fn command_name(&self) -> &str {
            "HeapProfiler.stopTrackingHeapObjects"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for StopTrackingHeapObjectsCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "HeapProfiler.stopTrackingHeapObjects" {
                Ok ( < StopTrackingHeapObjectsCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `HeapProfiler.stopTrackingHeapObjects`\n\n*Domain Module:* [`cdp::proto::heap_profiler`](index.html)  \n*Command Struct:* [`cdp::proto::heap_profiler::StopTrackingHeapObjectsCommand`](struct.StopTrackingHeapObjectsCommand.html)  \n*Response Struct:* [`cdp::proto::heap_profiler::StopTrackingHeapObjectsResponse`](struct.StopTrackingHeapObjectsResponse.html)"]
    pub struct StopTrackingHeapObjectsResponse;
    impl ::serde::Serialize for StopTrackingHeapObjectsResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StopTrackingHeapObjectsResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StopTrackingHeapObjectsResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for StopTrackingHeapObjectsCommand {
        type Response = StopTrackingHeapObjectsResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for StopTrackingHeapObjectsResponse {
        type Command = StopTrackingHeapObjectsCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `HeapProfiler.takeHeapSnapshot`\n\n*Domain Module:* [`cdp::proto::heap_profiler`](index.html)  \n*Command Struct:* [`cdp::proto::heap_profiler::TakeHeapSnapshotCommand`](struct.TakeHeapSnapshotCommand.html)  \n*Response Struct:* [`cdp::proto::heap_profiler::TakeHeapSnapshotResponse`](struct.TakeHeapSnapshotResponse.html)"]
    pub struct TakeHeapSnapshotCommand {
        #[serde(rename = "reportProgress", skip_serializing_if = "Option::is_none")]
        #[doc = "If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken."]
        pub report_progress: Option<bool>,
    }
    impl ::traits::SerializeCdpCommand for TakeHeapSnapshotCommand {
        fn command_name(&self) -> &str {
            "HeapProfiler.takeHeapSnapshot"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for TakeHeapSnapshotCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "HeapProfiler.takeHeapSnapshot" {
                Ok ( < TakeHeapSnapshotCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `HeapProfiler.takeHeapSnapshot`\n\n*Domain Module:* [`cdp::proto::heap_profiler`](index.html)  \n*Command Struct:* [`cdp::proto::heap_profiler::TakeHeapSnapshotCommand`](struct.TakeHeapSnapshotCommand.html)  \n*Response Struct:* [`cdp::proto::heap_profiler::TakeHeapSnapshotResponse`](struct.TakeHeapSnapshotResponse.html)"]
    pub struct TakeHeapSnapshotResponse;
    impl ::serde::Serialize for TakeHeapSnapshotResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for TakeHeapSnapshotResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| TakeHeapSnapshotResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for TakeHeapSnapshotCommand {
        type Response = TakeHeapSnapshotResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for TakeHeapSnapshotResponse {
        type Command = TakeHeapSnapshotCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `HeapProfiler.collectGarbage`\n\n*Domain Module:* [`cdp::proto::heap_profiler`](index.html)  \n*Command Struct:* [`cdp::proto::heap_profiler::CollectGarbageCommand`](struct.CollectGarbageCommand.html)  \n*Response Struct:* [`cdp::proto::heap_profiler::CollectGarbageResponse`](struct.CollectGarbageResponse.html)"]
    pub struct CollectGarbageCommand;
    impl ::serde::Serialize for CollectGarbageCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CollectGarbageCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| CollectGarbageCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for CollectGarbageCommand {
        fn command_name(&self) -> &str {
            "HeapProfiler.collectGarbage"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for CollectGarbageCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "HeapProfiler.collectGarbage" {
                Ok(
                    <CollectGarbageCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `HeapProfiler.collectGarbage`\n\n*Domain Module:* [`cdp::proto::heap_profiler`](index.html)  \n*Command Struct:* [`cdp::proto::heap_profiler::CollectGarbageCommand`](struct.CollectGarbageCommand.html)  \n*Response Struct:* [`cdp::proto::heap_profiler::CollectGarbageResponse`](struct.CollectGarbageResponse.html)"]
    pub struct CollectGarbageResponse;
    impl ::serde::Serialize for CollectGarbageResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CollectGarbageResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| CollectGarbageResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for CollectGarbageCommand {
        type Response = CollectGarbageResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for CollectGarbageResponse {
        type Command = CollectGarbageCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `HeapProfiler.getObjectByHeapObjectId`\n\n*Domain Module:* [`cdp::proto::heap_profiler`](index.html)  \n*Command Struct:* [`cdp::proto::heap_profiler::GetObjectByHeapObjectIdCommand`](struct.GetObjectByHeapObjectIdCommand.html)  \n*Response Struct:* [`cdp::proto::heap_profiler::GetObjectByHeapObjectIdResponse`](struct.GetObjectByHeapObjectIdResponse.html)"]
    pub struct GetObjectByHeapObjectIdCommand<'a> {
        #[serde(rename = "objectId")]
        pub object_id: ::proto::heap_profiler::HeapSnapshotObjectId<'a>,
        #[serde(rename = "objectGroup", skip_serializing_if = "Option::is_none")]
        #[doc = "Symbolic group name that can be used to release multiple objects."]
        pub object_group: Option<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::traits::SerializeCdpCommand for GetObjectByHeapObjectIdCommand<'a> {
        fn command_name(&self) -> &str {
            "HeapProfiler.getObjectByHeapObjectId"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for GetObjectByHeapObjectIdCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "HeapProfiler.getObjectByHeapObjectId" {
                Ok ( < GetObjectByHeapObjectIdCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `HeapProfiler.getObjectByHeapObjectId`\n\n*Domain Module:* [`cdp::proto::heap_profiler`](index.html)  \n*Command Struct:* [`cdp::proto::heap_profiler::GetObjectByHeapObjectIdCommand`](struct.GetObjectByHeapObjectIdCommand.html)  \n*Response Struct:* [`cdp::proto::heap_profiler::GetObjectByHeapObjectIdResponse`](struct.GetObjectByHeapObjectIdResponse.html)"]
    pub struct GetObjectByHeapObjectIdResponse<'a> {
        #[serde(rename = "result")]
        #[doc = "Evaluation result."]
        pub result: ::proto::runtime::RemoteObject<'a>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for GetObjectByHeapObjectIdCommand<'a> {
        type Response = GetObjectByHeapObjectIdResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for GetObjectByHeapObjectIdResponse<'a> {
        type Command = GetObjectByHeapObjectIdCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables console to refer to the node with given id via $x \\(see Command Line API for more details $x functions\\).\n\n# Command `HeapProfiler.addInspectedHeapObject`\n\n*Domain Module:* [`cdp::proto::heap_profiler`](index.html)  \n*Command Struct:* [`cdp::proto::heap_profiler::AddInspectedHeapObjectCommand`](struct.AddInspectedHeapObjectCommand.html)  \n*Response Struct:* [`cdp::proto::heap_profiler::AddInspectedHeapObjectResponse`](struct.AddInspectedHeapObjectResponse.html)"]
    pub struct AddInspectedHeapObjectCommand<'a> {
        #[serde(rename = "heapObjectId")]
        #[doc = "Heap snapshot object id to be accessible by means of $x command line API."]
        pub heap_object_id: ::proto::heap_profiler::HeapSnapshotObjectId<'a>,
    }
    impl<'a> ::traits::SerializeCdpCommand for AddInspectedHeapObjectCommand<'a> {
        fn command_name(&self) -> &str {
            "HeapProfiler.addInspectedHeapObject"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for AddInspectedHeapObjectCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "HeapProfiler.addInspectedHeapObject" {
                Ok ( < AddInspectedHeapObjectCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables console to refer to the node with given id via $x \\(see Command Line API for more details $x functions\\).\n\n# Command `HeapProfiler.addInspectedHeapObject`\n\n*Domain Module:* [`cdp::proto::heap_profiler`](index.html)  \n*Command Struct:* [`cdp::proto::heap_profiler::AddInspectedHeapObjectCommand`](struct.AddInspectedHeapObjectCommand.html)  \n*Response Struct:* [`cdp::proto::heap_profiler::AddInspectedHeapObjectResponse`](struct.AddInspectedHeapObjectResponse.html)"]
    pub struct AddInspectedHeapObjectResponse;
    impl ::serde::Serialize for AddInspectedHeapObjectResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for AddInspectedHeapObjectResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| AddInspectedHeapObjectResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for AddInspectedHeapObjectCommand<'a> {
        type Response = AddInspectedHeapObjectResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for AddInspectedHeapObjectResponse {
        type Command = AddInspectedHeapObjectCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `HeapProfiler.getHeapObjectId`\n\n*Domain Module:* [`cdp::proto::heap_profiler`](index.html)  \n*Command Struct:* [`cdp::proto::heap_profiler::GetHeapObjectIdCommand`](struct.GetHeapObjectIdCommand.html)  \n*Response Struct:* [`cdp::proto::heap_profiler::GetHeapObjectIdResponse`](struct.GetHeapObjectIdResponse.html)"]
    pub struct GetHeapObjectIdCommand<'a> {
        #[serde(rename = "objectId")]
        #[doc = "Identifier of the object to get heap object id for."]
        pub object_id: ::proto::runtime::RemoteObjectId<'a>,
    }
    impl<'a> ::traits::SerializeCdpCommand for GetHeapObjectIdCommand<'a> {
        fn command_name(&self) -> &str {
            "HeapProfiler.getHeapObjectId"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpCommand<'de> for GetHeapObjectIdCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "HeapProfiler.getHeapObjectId" {
                Ok(
                    <GetHeapObjectIdCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `HeapProfiler.getHeapObjectId`\n\n*Domain Module:* [`cdp::proto::heap_profiler`](index.html)  \n*Command Struct:* [`cdp::proto::heap_profiler::GetHeapObjectIdCommand`](struct.GetHeapObjectIdCommand.html)  \n*Response Struct:* [`cdp::proto::heap_profiler::GetHeapObjectIdResponse`](struct.GetHeapObjectIdResponse.html)"]
    pub struct GetHeapObjectIdResponse<'a> {
        #[serde(rename = "heapSnapshotObjectId")]
        #[doc = "Id of the heap snapshot object corresponding to the passed remote object id."]
        pub heap_snapshot_object_id: ::proto::heap_profiler::HeapSnapshotObjectId<'a>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for GetHeapObjectIdCommand<'a> {
        type Response = GetHeapObjectIdResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for GetHeapObjectIdResponse<'a> {
        type Command = GetHeapObjectIdCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `HeapProfiler.startSampling`\n\n*Domain Module:* [`cdp::proto::heap_profiler`](index.html)  \n*Command Struct:* [`cdp::proto::heap_profiler::StartSamplingCommand`](struct.StartSamplingCommand.html)  \n*Response Struct:* [`cdp::proto::heap_profiler::StartSamplingResponse`](struct.StartSamplingResponse.html)"]
    pub struct StartSamplingCommand {
        #[serde(rename = "samplingInterval", skip_serializing_if = "Option::is_none")]
        #[doc = "Average sample interval in bytes. Poisson distribution is used for the intervals. The default value is 32768 bytes."]
        pub sampling_interval: Option<f64>,
    }
    impl ::traits::SerializeCdpCommand for StartSamplingCommand {
        fn command_name(&self) -> &str {
            "HeapProfiler.startSampling"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for StartSamplingCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "HeapProfiler.startSampling" {
                Ok(
                    <StartSamplingCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `HeapProfiler.startSampling`\n\n*Domain Module:* [`cdp::proto::heap_profiler`](index.html)  \n*Command Struct:* [`cdp::proto::heap_profiler::StartSamplingCommand`](struct.StartSamplingCommand.html)  \n*Response Struct:* [`cdp::proto::heap_profiler::StartSamplingResponse`](struct.StartSamplingResponse.html)"]
    pub struct StartSamplingResponse;
    impl ::serde::Serialize for StartSamplingResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StartSamplingResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StartSamplingResponse)
        }
    }
    impl<'a> ::traits::HasCdpResponse<'a> for StartSamplingCommand {
        type Response = StartSamplingResponse;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for StartSamplingResponse {
        type Command = StartSamplingCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `HeapProfiler.stopSampling`\n\n*Domain Module:* [`cdp::proto::heap_profiler`](index.html)  \n*Command Struct:* [`cdp::proto::heap_profiler::StopSamplingCommand`](struct.StopSamplingCommand.html)  \n*Response Struct:* [`cdp::proto::heap_profiler::StopSamplingResponse`](struct.StopSamplingResponse.html)"]
    pub struct StopSamplingCommand;
    impl ::serde::Serialize for StopSamplingCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StopSamplingCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StopSamplingCommand)
        }
    }
    impl ::traits::SerializeCdpCommand for StopSamplingCommand {
        fn command_name(&self) -> &str {
            "HeapProfiler.stopSampling"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpCommand<'de> for StopSamplingCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "HeapProfiler.stopSampling" {
                Ok(
                    <StopSamplingCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `HeapProfiler.stopSampling`\n\n*Domain Module:* [`cdp::proto::heap_profiler`](index.html)  \n*Command Struct:* [`cdp::proto::heap_profiler::StopSamplingCommand`](struct.StopSamplingCommand.html)  \n*Response Struct:* [`cdp::proto::heap_profiler::StopSamplingResponse`](struct.StopSamplingResponse.html)"]
    pub struct StopSamplingResponse<'a> {
        #[serde(rename = "profile")]
        #[doc = "Recorded sampling heap profile."]
        pub profile: ::proto::heap_profiler::SamplingHeapProfile<'a>,
    }
    impl<'a> ::traits::HasCdpResponse<'a> for StopSamplingCommand {
        type Response = StopSamplingResponse<'a>;
    }
    impl<'a> ::traits::HasCdpCommand<'a> for StopSamplingResponse<'a> {
        type Command = StopSamplingCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Event `HeapProfiler.addHeapSnapshotChunk`\n\n*Domain Module:* [`cdp::proto::heap_profiler`](index.html)  \n*Event Struct:* [`cdp::proto::heap_profiler::AddHeapSnapshotChunkEvent`](struct.AddHeapSnapshotChunkEvent.html)"]
    pub struct AddHeapSnapshotChunkEvent<'a> {
        #[serde(rename = "chunk")]
        pub chunk: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::traits::SerializeCdpEvent for AddHeapSnapshotChunkEvent<'a> {
        fn event_name(&self) -> &str {
            "HeapProfiler.addHeapSnapshotChunk"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::traits::DeserializeCdpEvent<'de> for AddHeapSnapshotChunkEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "HeapProfiler.addHeapSnapshotChunk" {
                Ok ( < AddHeapSnapshotChunkEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Event `HeapProfiler.resetProfiles`\n\n*Domain Module:* [`cdp::proto::heap_profiler`](index.html)  \n*Event Struct:* [`cdp::proto::heap_profiler::ResetProfilesEvent`](struct.ResetProfilesEvent.html)"]
    pub struct ResetProfilesEvent;
    impl ::serde::Serialize for ResetProfilesEvent {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::proto::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ResetProfilesEvent {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::proto::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ResetProfilesEvent)
        }
    }
    impl ::traits::SerializeCdpEvent for ResetProfilesEvent {
        fn event_name(&self) -> &str {
            "HeapProfiler.resetProfiles"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpEvent<'de> for ResetProfilesEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "HeapProfiler.resetProfiles" {
                Ok(
                    <ResetProfilesEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Event `HeapProfiler.reportHeapSnapshotProgress`\n\n*Domain Module:* [`cdp::proto::heap_profiler`](index.html)  \n*Event Struct:* [`cdp::proto::heap_profiler::ReportHeapSnapshotProgressEvent`](struct.ReportHeapSnapshotProgressEvent.html)"]
    pub struct ReportHeapSnapshotProgressEvent {
        #[serde(rename = "done")]
        pub done: i32,
        #[serde(rename = "total")]
        pub total: i32,
        #[serde(rename = "finished", skip_serializing_if = "Option::is_none")]
        pub finished: Option<bool>,
    }
    impl ::traits::SerializeCdpEvent for ReportHeapSnapshotProgressEvent {
        fn event_name(&self) -> &str {
            "HeapProfiler.reportHeapSnapshotProgress"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpEvent<'de> for ReportHeapSnapshotProgressEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "HeapProfiler.reportHeapSnapshotProgress" {
                Ok ( < ReportHeapSnapshotProgressEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.\n\n# Event `HeapProfiler.lastSeenObjectId`\n\n*Domain Module:* [`cdp::proto::heap_profiler`](index.html)  \n*Event Struct:* [`cdp::proto::heap_profiler::LastSeenObjectIdEvent`](struct.LastSeenObjectIdEvent.html)"]
    pub struct LastSeenObjectIdEvent {
        #[serde(rename = "lastSeenObjectId")]
        pub last_seen_object_id: i32,
        #[serde(rename = "timestamp")]
        pub timestamp: f64,
    }
    impl ::traits::SerializeCdpEvent for LastSeenObjectIdEvent {
        fn event_name(&self) -> &str {
            "HeapProfiler.lastSeenObjectId"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpEvent<'de> for LastSeenObjectIdEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "HeapProfiler.lastSeenObjectId" {
                Ok(
                    <LastSeenObjectIdEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> If heap objects tracking has been started then backend may send update for one or more fragments\n\n# Event `HeapProfiler.heapStatsUpdate`\n\n*Domain Module:* [`cdp::proto::heap_profiler`](index.html)  \n*Event Struct:* [`cdp::proto::heap_profiler::HeapStatsUpdateEvent`](struct.HeapStatsUpdateEvent.html)"]
    pub struct HeapStatsUpdateEvent {
        #[serde(rename = "statsUpdate")]
        #[doc = "An array of triplets. Each triplet describes a fragment. The first integer is the fragment index, the second integer is a total count of objects for the fragment, the third integer is a total size of the objects for the fragment."]
        pub stats_update: Vec<i32>,
    }
    impl ::traits::SerializeCdpEvent for HeapStatsUpdateEvent {
        fn event_name(&self) -> &str {
            "HeapProfiler.heapStatsUpdate"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::traits::DeserializeCdpEvent<'de> for HeapStatsUpdateEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "HeapProfiler.heapStatsUpdate" {
                Ok(
                    <HeapStatsUpdateEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Heap snapshot object id."]
    pub type HeapSnapshotObjectId<'a> = ::std::borrow::Cow<'a, str>;
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Sampling Heap Profile node. Holds callsite information, allocation statistics and child nodes."]
    pub struct SamplingHeapProfileNode<'a> {
        #[serde(rename = "callFrame")]
        #[doc = "Function location."]
        pub call_frame: ::proto::runtime::CallFrame<'a>,
        #[serde(rename = "selfSize")]
        #[doc = "Allocations size in bytes for the node excluding children."]
        pub self_size: f64,
        #[serde(rename = "children")]
        #[doc = "Child nodes."]
        pub children: Vec<Box<::proto::heap_profiler::SamplingHeapProfileNode<'a>>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Profile."]
    pub struct SamplingHeapProfile<'a> {
        #[serde(rename = "head")]
        pub head: ::proto::heap_profiler::SamplingHeapProfileNode<'a>,
    }
}
